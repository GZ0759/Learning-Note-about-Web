> Git原理详解及实用指南 掘金小册  
> 扔物线 Android 开发者

# 1 什么是版本控制系统（VCS）

## 版本控制：最基本功能

版本控制系统（VCS）最基本的功能是版本控制。所谓版本控制，意思就是在文件的修改历程中保留修改历史，可以方便地撤销之前对文件的修改操作。最简化的版本控制模型，就是大多数主流文本编辑器都有的撤销（Undo）功能。

## 主动提交：程序代码和普通文本的区别

 VCS 和文本编辑器的撤销功能比起来，有一个很重要的区别是：程序代码的修改的生命周期非常长。 VCS 保存修改历史，使用的是主动提交改动的机制。在写完一段完整的代码之后，使用 commit 命令把改动和对改动的描述信息提交，这样就能记录到版本历史当中了。

## 多人合作的同步需求：中央仓库

中央仓库作为代码的存储中心，所有人的改动都会上传到这里，所有人也都能看到和下载别人上传的改动，解决同步的需求。

版本控制、主动提交和中央仓库这三个元素，共同构成了版本控制系统（VCS）的核心。开发团队中的每个人都向中央仓库主动提交自己的改动和同步别人的改动，并在需要的时候查看和操作历史版本，这就是版本控制系统。

## 中央式版本控制系统工作模型

第一次加入团队时，把中央仓库的代码取下来；
写完的新功能提交到中央仓库；
同事提交到中央仓库的新代码，及时同步下来。

这就是中央式 VCS 最基本的工作模型。实际的开发工作并没有简单到这种程序，因为时常需要处理代码冲突、查看版本历史、回退代码版本等。另外，Git 属于分布式 VCS ，它的概念也比中央式VCS要复杂一些。

# 2 什么是分布式版本控制系统（DVCS）

## 区别和功能比较

分布式 VCS （Distributed VCS / DVCS）和中央式的区别在于，分布式 VCS 除了中央仓库之外，还有本地仓库：团队中每一个成员的机器上都有一份本地仓库，这个仓库里包含了所有的版本历史，或者换句话说，每个人在自己的机器上就可以提交代码、查看历史，而无需联网和中央仓库交互——当然，取而代之的，你需要和本地仓库交互。

中央式 VCS 的中央仓库有两个主要功能：保存版本历、同步团队代码。而在分布式 VCS 中，保存版本历史的工作转交到了每个团队成员的本地仓库中，中央仓库就只剩下了同步团队代码这一个主要任务。它的中央仓库依然也保存了历史版本，但这份历史版本更多的是作为团队间的同步中转站。工作模型和上一节讲的「中央式 VCS 的工作模型」很相似，只是把代码的提交和上传过程拆开了。

## 优点与缺点

优点：

- 大多数的操作可以在本地进行，所以速度更快，而且由于无需联网，所以即使不在公司甚至没有在联网，你也可以提交代码、查看历史，从而极大地减小了开发者的网络条件和物理位置的限制（例如，你可以在飞机上提交代码、切换分支等等）；
- 由于可以提交到本地，所以你可以分步提交代码，把代码提交做得更细，而不是一个提交包含很多代码，难以 review 也难以回溯。

缺点：

- 由于每一个机器都有完整的本地仓库，所以初次获取项目的时候会比较耗时；
- 由于每个机器都有完整的本地仓库，所以本地占用的存储比中央式 VCS 要高。

# 3 上手 1：新公司用 Git 管理代码，怎么快速上手？

这个 `.git` 目录，就是本地仓库（Local Repository），所有版本信息都会存在这里。而 `.git` 所在的这个根目录，称为 Git 的工作目录（Working Directory），它保存了你当前从仓库中签出（checkout）的内容。

stage 这个词在 Git 里，是「集中收集改动以待提交」的意思。所谓的 staging area，是 `.git` 目录下一个叫做 `index` 的文件。通过 `add` 指令暂存的内容，都会被写进这个文件里。

# 4 上手 2：团队工作的基本工作模型

写完所有的 `commit` 后，不用考虑中央仓库是否有新的提交，直接 `push` 就好。

如果 `push` 失败，就用 `pull` 把本地仓库的提交和中央仓库的提交进行合并，然后再 `push` 一次。

`git pull` 这个指令的内部实现就是把远程仓库使用 `git fetch` 取下来以后再进行 merge 操作的。


# 5 进阶 1：HEAD、master 与 branch

## 引用：commit 的快捷键

在 Git 的使用中，经常会需要对指定的 `commit` 进行操作。每一个 `commit` 都有一个它唯一的指定方式——它的 SHA-1 校验和。两个 SHA-1 值的重复概率极低，所以你可以使用这个 SHA-1 值来指代 `commit`，也可以只使用它的前几位来指代它（例如第一个 `78bb0ab7d541…16b77`，你使用 `78bb0ab` 甚至 `78bb` 来指代它通常也可以），但毕竟这种没有任何含义的字符串是很难记忆的，所以 Git 提供了「引用」的机制：使用固定的字符串作为引用，指向某个 `commit`，作为操作 `commit` 时的快捷方式。

## HEAD：当前 commit 的引用。

 `HEAD` 是引用中最特殊的一个：它是指向当前 `commit` 的引用。所谓当前 `commit`这个概念很简单，它指的就是当前工作目录所对应的 `commit`。

 每次当有新的 `commit` 的时候，工作目录自动与最新的 `commit` 对应；而与此同时，`HEAD` 也会转而指向最新的 `commit`。事实上，当使用 `checkout`、`reset` 等指令手动指定改变当前 `commit` 的时候，`HEAD` 也会一起跟过去。所以永远可以用 `HEAD` 来操作当前 `commit`。

## branch

`HEAD` 是 Git 中一个独特的引用，它是唯一的。而除了 `HEAD` 之外，Git 还有一种引用，叫做 `branch`（分支）。`HEAD` 除了可以指向 `commit`，还可以指向一个 `branch`，当它指向某个 `branch` 的时候，会通过这个 `branch` 来间接地指向某个 `commit`；另外，当 `HEAD` 在提交时自动向前移动的时候，它会像一个拖钩一样带着它所指向的 `branch` 一起移动。

## master: 默认 branch

上面的这个 `master` ，其实是一个特殊的 `branch`：它是 Git 的默认 `branch`（俗称主 `branch` / 主分支）。

新创建的 repository（仓库）是没有任何 `commit` 的。但在它创建第一个 `commit` 时，会把 `master` 指向它，并把 `HEAD` 指向 `master`。

当有人使用 `git clone` 时，除了从远程仓库把 `.git` 这个仓库目录下载到工作目录中，还会 `checkout` （签出） `master`（`checkout` 的意思就是把某个 `commit` 作为当前 `commit`，把 `HEAD` 移动过去，并把工作目录的文件内容替换成这个 `commit` 所对应的内容）。

## branch 的通俗化理解

尽管在 Git 中，`branch` 只是一个指向 `commit` 的引用，但它有一个更通俗的理解：你还可以把一个 `branch` 理解为从初始 `commit` 到 `branch` 所指向的 `commit` 之间的所有 `commit`s 的一个「串」。

- 所有的 `branch` 之间都是平等的。
- `branch` 包含了从初始 `commit` 到它的所有路径，而不是一条路径。并且，这些路径之间也是彼此平等的。

## branch 的创建、切换和删除

如果你想在某处创建 `branch` ，只需要输入一行 `git branch 名称`。

不过新建的 `branch` 并不会自动切换，你的 `HEAD` 在这时依然是指向 `master` 的。你需要用 `checkout` 来主动切换到你的新 `branch` 去。然后 `HEAD` 就会指向新建的 `branch` 了

除此之外，你还可以用 `git checkout -b 名称` 来把上面两步操作合并执行。这行代码可以帮你用指定的名称创建 `branch` 后，再直接切换过去。

删除 `branch` 的方法非常简单：`git branch -d 名称`。

-  `HEAD` 指向的 `branch` 不能删除。如果要删除 `HEAD` 指向的 `branch`，需要先用 `checkout` 把 `HEAD` 指向其他地方。

-  由于 Git 中的 `branch` 只是一个引用，所以删除 `branch` 的操作也只会删掉这个引用，并不会删除任何的 `commit`。（不过如果一个 `commit` 不在任何一个 `branch` 的「路径」上，或者换句话说，如果没有任何一个 `branch` 可以回溯到这条 `commit`（也许可以称为野生 `commit`），那么在一定时间后，它会被 Git 的回收机制删除掉。）

-  出于安全考虑，没有被合并到 `master` 过的 `branch` 在删除时会失败（因为怕你误删掉「未完成」的 `branch` 啊）。这种情况如果你确认是要删除这个 `branch` ，可以把 `-d` 改成 `-D`，小写换成大写，就能删除了。

如果我们想要 HEAD 的第 10 个祖先提交，我们直接用 HEAD~10 就可以了。~ 用来表示一个提交的第 n 个祖先提交，如果不指定 n，那么默认为 1。另外，HEAD~~~ 和 HEAD~3 是等价的。

如果一个提交有多个父提交，那么 ~ 只会找第一个父提交。^ 用来表示一个提交的第 n 个父提交，如果不指定 n，那么默认为 1。和 ~ 不同的是，HEAD^^^ 并不等价于 HEAD^3，而是等价与 HEAD^1^1^1。

~ 获取第一个祖先提交，^ 可以获取第一个父提交。其实第一个祖先提交就是第一个父提交，反之亦然。因此，当 n 为 1 时，~ 和 ^ 其实是等价的。譬如：HEAD~~~ 和 HEAD^^^ 是等价的。

# 6 进阶 2：push 的本质

## push：把 branch 上传到远端仓库

实质上，`push` 做的事是：把当前 `branch` 的位置（即它指向哪个 `commit`）上传到远端仓库，并把它的路径上的 `commit`s 一并上传。

而如果这时候我再切到 `feature1` 去后再执行一次 `push`，就会把 `feature1` 以及它的 `commit` `4` 上传到远程仓库。

在 Git 中，默认情况下，用不加参数的 `git push` 只能上传那些之前从远端 `clone` 下来或者 `pull` 下来的分支，而如果需要 `push` 你本地的自己创建的分支，则需要手动指定目标仓库和目标分支（并且目标分支的名称必须和本地分支完全相同）。

```shell
git checkout feature1
git push origin feature1
```

`push` 的时候之后上传当前分支，并不会上传 `HEAD`；远程仓库的 `HEAD` 是永远指向默认分支（即 `master`）的。

# 7 进阶 3：merge：合并 commits

## 含义和用法

`pull` 的内部操作其实是把远程仓库取到本地后（使用的是 `fetch`），再用一次 `merge` 来把远端仓库的新 `commits` 合并到本地。

从目标 `commit` 和当前 `commit` （即 `HEAD` 所指向的 `commit`）分叉的位置起，把目标 `commit` 的路径上的所有 `commit` 的内容一并应用到当前 `commit`，然后自动生成一个新的 `commit`。

`merge` 操作会帮你自动地填写简要的提交信息。在提交信息修改完成后（或者你打算不修改默认的提交信息），就可以退出这个界面，然后这次 `merge` 就算完成了。

`merge` 最常用的场景有两处：

- 合并分支
- `pull` 的内部操作

## 特殊情况 1：冲突

如果两个分支修改了同一部分内容，`merge` 的自动算法就搞不定了。这种情况 Git 称之为：冲突（Conflict）。

虽然 Git 没有帮你完成自动 `merge`，但它对文件还是做了一些工作：它把两个分支冲突的内容放在了一起，并用符号标记出了它们的边界以及它们的出处。

在发生冲突后，Git 仓库处于一个「merge 冲突待解决」的中间状态，在这种状态下 `commit`，Git 就会自动地帮你添加「这是一个 merge commit」的提交信息。

同理，由于现在 Git 仓库处于冲突待解决的中间状态，所以如果最终决定放弃这次 `merge`，也需要执行一次 `merge --abort` 来手动取消它：

```shell
git merge --abort
```

## 特殊情况 2：HEAD 领先于目标 commit

如果 `merge` 时的目标 `commit` 和 `HEAD` 处的 `commit` 并不存在分叉，而是 `HEAD` 领先于目标 `commit`：

那么 `merge` 就没必要再创建一个新的 `commit` 来进行合并操作，因为并没有什么需要合并的。在这种情况下， Git 什么也不会做，`merge` 是一个空操作。

## 特殊情况 3：HEAD 落后于 目标 commit——fast-forward

而另一种情况：如果 `HEAD` 和目标 `commit` 依然是不存在分叉，但 `HEAD` 不是领先于目标 `commit`，而是落后于目标 `commit`。那么 Git 会直接把 `HEAD`（以及它所指向的 `branch`，如果有的话）移动到目标 `commit`。这种操作有一个专有称谓，叫做 "fast-forward"（快速前移）。

一般情况下，创建新的 `branch` 都是会和原 `branch` 并行开发的，不然没必要开 `branch` ，直接在原 `branch` 上开发就好。但事实上，上图中的情形其实很常见，因为这其实是 `pull` 操作的一种经典情形：本地的 `master` 没有新提交，而远端仓库中有同事提交了新内容到 `master`。

# 8 进阶 4：Feature Branching：最流行的工作流

## 简介

这种工作流的核心内容可以总结为两点：

- 任何新的功能（feature）或 bug 修复全都新建一个 `branch` 来写；
- `branch` 写完后，合并到 `master`，然后删掉这个 `branch`。

实质上，Feature Branching 这种工作流，为团队开发时两个关键的问题——代码分享和一人多任务——提供了解决方案。

## 1. 代码分享

还可以利用 Pull Request 来进一步简化。Pull Request 并不是 Git 的内容，而是一些 Git 仓库服务提供方（例如 GitHub）所提供的一种便捷功能，它可以让团队的成员方便地讨论一个 `branch` ，并在讨论结束后一键合并这个 `branch` 到 `master`。

- 把 `branch` `push` 到中央仓库；
- 在中央仓库处创建一个 Pull Request。

同事就可以在 GitHub 上看到创建的 Pull Request 了。他们可以在 GitHub 的这个页面查看你的 `commit`s，也可以给你评论表示赞同或提意见，你接下来也可以根据他们的意见把新的 `commit`s `push` 上来，这也页面会随着你新的 `push` 而展示出最新的 `commits`。

最后需要点一下页面中那个绿色的 "Merge pull request" 按钮，GitHub 就会自动地在中央仓库帮你把 `branch` 合并到 `master` 了。另外，GitHub 还设计了一个贴心的 "Delete branch" 按钮，方便你在合并之后一键删除 `branch`。

## 2. 一人多任务

如果是在独立的 `branch` 上做事，切换任务是很简单的。只要稍微把目前未提交的代码简单收尾一下，然后做一个带有「未完成」标记的提交（例如，在提交信息里标上「TODO」），然后回到 `master` 去创建一个新的 `branch` 就好了。

# 9 进阶 5：关于 add

## add 后面加个点 "."：全部暂存

`add` 指令除了 `git add 文件名` 这种用法外，还可以使用 `add .` 来直接把工作目录下的所有改动全部放进暂存区。

## add 添加的是文件改动，而不是文件名

通过 `add` 添加进暂存区的不是文件名，而是具体的文件改动内容。在 `add` 时的改动都被添加进了暂存区，但在 `add` 之后的新改动并不会自动被添加进暂存区。

# 10 进阶 6：看看我都改了什么

## 查看历史记录

`git log` 可以查看历史记录。

`log -p` 查看详细历史。可以看到每一个 `commit` 的每一行改动，所以很适合用于代码 review。`-p` 是 `--patch` 的缩写。

`log --stat` 查看简要统计。大致看一下改动内容，但不想深入到每一行的细节。

`show` 查看具体的 commit。如果你想看某个具体的 `commit` 的改动内容，可以用 `show`。

- 通过`git show`查看当前 `commit`

- 通过`commit`引用（`branch`或`HEAD`标记）或它的`SHA-1`码看任意一个`commit`。

- 在 `commit` 的引用或 `SHA-1` 后输入文件名，可以看指定 commit 中的指定文件。

## 看未提交的内容

如果想看未提交的内容，可以用 `diff`。

- 使用 `git diff --staged` 可以显示暂存区和上一条提交之间的不同。`--staged` 有一个等价的选项叫做 `--cached`。这里所谓的「等价」，是真真正正的等价，它们的意思完全相同。

- 使用 `git diff` （不加选项参数）可以显示工作目录和暂存区之间的不同。

- 使用 `git diff HEAD` 可以显示工作目录和上一条提交之间的不同，它是上面这二者的内容相加。如果把 `HEAD` 换成别的 `commit`，也可以显示当前工作目录和这条 `commit` 的区别。

# 11 高级 1：不喜欢 merge 的分叉？用 rebase 吧

# 12 高级 2：刚刚提交的代码，发现写错了怎么办？

# 13 高级 3：写错的不是最新的提交，而是倒数第二个？

# 14 高级 4：比错还错，想直接丢弃刚写的提交？

# 15 高级 5：想丢弃的也不是最新的提交？

# 16 高级 6：代码已经 push 上去了才发现写错？

# 17 高级 7：reset 的本质——不止可以撤销提交

# 18 高级 8：checkout 的本质

# 19 高级 9：紧急情况：「立即给我打个包，现在马上！」

# 20 高级 10：branch 删过了才想起来有用？

# 21 额外说点：.gitignore——排除不想被管理的文件和目录

# 22 总结
