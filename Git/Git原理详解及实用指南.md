> Git原理详解及实用指南 掘金小册  
> 扔物线 Android 开发者

# 1 什么是版本控制系统（VCS）

## 版本控制：最基本功能

版本控制系统（VCS）最基本的功能是版本控制。所谓版本控制，意思就是在文件的修改历程中保留修改历史，可以方便地撤销之前对文件的修改操作。最简化的版本控制模型，就是大多数主流文本编辑器都有的撤销（Undo）功能。

## 主动提交：程序代码和普通文本的区别

 VCS 和文本编辑器的撤销功能比起来，有一个很重要的区别是：程序代码的修改的生命周期非常长。 VCS 保存修改历史，使用的是主动提交改动的机制。在写完一段完整的代码之后，使用 commit 命令把改动和对改动的描述信息提交，这样就能记录到版本历史当中了。

## 多人合作的同步需求：中央仓库

中央仓库作为代码的存储中心，所有人的改动都会上传到这里，所有人也都能看到和下载别人上传的改动，解决同步的需求。

版本控制、主动提交和中央仓库这三个元素，共同构成了版本控制系统（VCS）的核心。开发团队中的每个人都向中央仓库主动提交自己的改动和同步别人的改动，并在需要的时候查看和操作历史版本，这就是版本控制系统。

## 中央式版本控制系统工作模型

第一次加入团队时，把中央仓库的代码取下来；
写完的新功能提交到中央仓库；
同事提交到中央仓库的新代码，及时同步下来。

这就是中央式 VCS 最基本的工作模型。实际的开发工作并没有简单到这种程序，因为时常需要处理代码冲突、查看版本历史、回退代码版本等。另外，Git 属于分布式 VCS ，它的概念也比中央式VCS要复杂一些。

# 2 什么是分布式版本控制系统（DVCS）

## 区别和功能比较

分布式 VCS （Distributed VCS / DVCS）和中央式的区别在于，分布式 VCS 除了中央仓库之外，还有本地仓库：团队中每一个成员的机器上都有一份本地仓库，这个仓库里包含了所有的版本历史，或者换句话说，每个人在自己的机器上就可以提交代码、查看历史，而无需联网和中央仓库交互——当然，取而代之的，你需要和本地仓库交互。

中央式 VCS 的中央仓库有两个主要功能：保存版本历、同步团队代码。而在分布式 VCS 中，保存版本历史的工作转交到了每个团队成员的本地仓库中，中央仓库就只剩下了同步团队代码这一个主要任务。它的中央仓库依然也保存了历史版本，但这份历史版本更多的是作为团队间的同步中转站。工作模型和上一节讲的「中央式 VCS 的工作模型」很相似，只是把代码的提交和上传过程拆开了。

## 优点与缺点

优点：

- 大多数的操作可以在本地进行，所以速度更快，而且由于无需联网，所以即使不在公司甚至没有在联网，你也可以提交代码、查看历史，从而极大地减小了开发者的网络条件和物理位置的限制（例如，你可以在飞机上提交代码、切换分支等等）；
- 由于可以提交到本地，所以你可以分步提交代码，把代码提交做得更细，而不是一个提交包含很多代码，难以 review 也难以回溯。

缺点：

- 由于每一个机器都有完整的本地仓库，所以初次获取项目的时候会比较耗时；
- 由于每个机器都有完整的本地仓库，所以本地占用的存储比中央式 VCS 要高。

# 3 上手 1：新公司用 Git 管理代码，怎么快速上手？

这个 `.git` 目录，就是本地仓库（Local Repository），所有版本信息都会存在这里。而 `.git` 所在的这个根目录，称为 Git 的工作目录（Working Directory），它保存了你当前从仓库中签出（checkout）的内容。

stage 这个词在 Git 里，是「集中收集改动以待提交」的意思。所谓的 staging area，是 `.git` 目录下一个叫做 `index` 的文件。通过 `add` 指令暂存的内容，都会被写进这个文件里。

# 4 上手 2：团队工作的基本工作模型

写完所有的 `commit` 后，不用考虑中央仓库是否有新的提交，直接 `push` 就好。

如果 `push` 失败，就用 `pull` 把本地仓库的提交和中央仓库的提交进行合并，然后再 `push` 一次。

`git pull` 这个指令的内部实现就是把远程仓库使用 `git fetch` 取下来以后再进行 merge 操作的。


# 5 进阶 1：HEAD、master 与 branch

## 引用：commit 的快捷键

在 Git 的使用中，经常会需要对指定的 `commit` 进行操作。每一个 `commit` 都有一个它唯一的指定方式——它的 SHA-1 校验和。两个 SHA-1 值的重复概率极低，所以你可以使用这个 SHA-1 值来指代 `commit`，也可以只使用它的前几位来指代它（例如第一个 `78bb0ab7d541…16b77`，你使用 `78bb0ab` 甚至 `78bb` 来指代它通常也可以），但毕竟这种没有任何含义的字符串是很难记忆的，所以 Git 提供了「引用」的机制：使用固定的字符串作为引用，指向某个 `commit`，作为操作 `commit` 时的快捷方式。

## HEAD：当前 commit 的引用。

 `HEAD` 是引用中最特殊的一个：它是指向当前 `commit` 的引用。所谓当前 `commit`这个概念很简单，它指的就是当前工作目录所对应的 `commit`。

 每次当有新的 `commit` 的时候，工作目录自动与最新的 `commit` 对应；而与此同时，`HEAD` 也会转而指向最新的 `commit`。事实上，当使用 `checkout`、`reset` 等指令手动指定改变当前 `commit` 的时候，`HEAD` 也会一起跟过去。所以永远可以用 `HEAD` 来操作当前 `commit`。

## branch

`HEAD` 是 Git 中一个独特的引用，它是唯一的。而除了 `HEAD` 之外，Git 还有一种引用，叫做 `branch`（分支）。`HEAD` 除了可以指向 `commit`，还可以指向一个 `branch`，当它指向某个 `branch` 的时候，会通过这个 `branch` 来间接地指向某个 `commit`；另外，当 `HEAD` 在提交时自动向前移动的时候，它会像一个拖钩一样带着它所指向的 `branch` 一起移动。

## master: 默认 branch

上面的这个 `master` ，其实是一个特殊的 `branch`：它是 Git 的默认 `branch`（俗称主 `branch` / 主分支）。

新创建的 repository（仓库）是没有任何 `commit` 的。但在它创建第一个 `commit` 时，会把 `master` 指向它，并把 `HEAD` 指向 `master`。

当有人使用 `git clone` 时，除了从远程仓库把 `.git` 这个仓库目录下载到工作目录中，还会 `checkout` （签出） `master`（`checkout` 的意思就是把某个 `commit` 作为当前 `commit`，把 `HEAD` 移动过去，并把工作目录的文件内容替换成这个 `commit` 所对应的内容）。

## branch 的通俗化理解

尽管在 Git 中，`branch` 只是一个指向 `commit` 的引用，但它有一个更通俗的理解：你还可以把一个 `branch` 理解为从初始 `commit` 到 `branch` 所指向的 `commit` 之间的所有 `commit`s 的一个「串」。

- 所有的 `branch` 之间都是平等的。
- `branch` 包含了从初始 `commit` 到它的所有路径，而不是一条路径。并且，这些路径之间也是彼此平等的。

## branch 的创建、切换和删除

如果你想在某处创建 `branch` ，只需要输入一行 `git branch 名称`。

不过新建的 `branch` 并不会自动切换，你的 `HEAD` 在这时依然是指向 `master` 的。你需要用 `checkout` 来主动切换到你的新 `branch` 去。然后 `HEAD` 就会指向新建的 `branch` 了

除此之外，你还可以用 `git checkout -b 名称` 来把上面两步操作合并执行。这行代码可以帮你用指定的名称创建 `branch` 后，再直接切换过去。

删除 `branch` 的方法非常简单：`git branch -d 名称`。

-  `HEAD` 指向的 `branch` 不能删除。如果要删除 `HEAD` 指向的 `branch`，需要先用 `checkout` 把 `HEAD` 指向其他地方。

-  由于 Git 中的 `branch` 只是一个引用，所以删除 `branch` 的操作也只会删掉这个引用，并不会删除任何的 `commit`。（不过如果一个 `commit` 不在任何一个 `branch` 的「路径」上，或者换句话说，如果没有任何一个 `branch` 可以回溯到这条 `commit`（也许可以称为野生 `commit`），那么在一定时间后，它会被 Git 的回收机制删除掉。）

-  出于安全考虑，没有被合并到 `master` 过的 `branch` 在删除时会失败（因为怕你误删掉「未完成」的 `branch` 啊）。这种情况如果你确认是要删除这个 `branch` ，可以把 `-d` 改成 `-D`，小写换成大写，就能删除了。

如果我们想要 HEAD 的第 10 个祖先提交，我们直接用 HEAD~10 就可以了。~ 用来表示一个提交的第 n 个祖先提交，如果不指定 n，那么默认为 1。另外，HEAD~~~ 和 HEAD~3 是等价的。

如果一个提交有多个父提交，那么 ~ 只会找第一个父提交。^ 用来表示一个提交的第 n 个父提交，如果不指定 n，那么默认为 1。和 ~ 不同的是，HEAD^^^ 并不等价于 HEAD^3，而是等价与 HEAD^1^1^1。

~ 获取第一个祖先提交，^ 可以获取第一个父提交。其实第一个祖先提交就是第一个父提交，反之亦然。因此，当 n 为 1 时，~ 和 ^ 其实是等价的。譬如：HEAD~~~ 和 HEAD^^^ 是等价的。

# 6 进阶 2：push 的本质

## push：把 branch 上传到远端仓库

实质上，`push` 做的事是：把当前 `branch` 的位置（即它指向哪个 `commit`）上传到远端仓库，并把它的路径上的 `commit`s 一并上传。

而如果这时候我再切到 `feature1` 去后再执行一次 `push`，就会把 `feature1` 以及它的 `commit` `4` 上传到远程仓库。

在 Git 中，默认情况下，用不加参数的 `git push` 只能上传那些之前从远端 `clone` 下来或者 `pull` 下来的分支，而如果需要 `push` 你本地的自己创建的分支，则需要手动指定目标仓库和目标分支（并且目标分支的名称必须和本地分支完全相同）。

```shell
git checkout feature1
git push origin feature1
```

`push` 的时候之后上传当前分支，并不会上传 `HEAD`；远程仓库的 `HEAD` 是永远指向默认分支（即 `master`）的。

# 7 进阶 3：merge：合并 commits

## 含义和用法

`pull` 的内部操作其实是把远程仓库取到本地后（使用的是 `fetch`），再用一次 `merge` 来把远端仓库的新 `commits` 合并到本地。

从目标 `commit` 和当前 `commit` （即 `HEAD` 所指向的 `commit`）分叉的位置起，把目标 `commit` 的路径上的所有 `commit` 的内容一并应用到当前 `commit`，然后自动生成一个新的 `commit`。

`merge` 操作会帮你自动地填写简要的提交信息。在提交信息修改完成后（或者你打算不修改默认的提交信息），就可以退出这个界面，然后这次 `merge` 就算完成了。

`merge` 最常用的场景有两处：

- 合并分支
- `pull` 的内部操作

## 特殊情况 1：冲突

如果两个分支修改了同一部分内容，`merge` 的自动算法就搞不定了。这种情况 Git 称之为：冲突（Conflict）。

虽然 Git 没有帮你完成自动 `merge`，但它对文件还是做了一些工作：它把两个分支冲突的内容放在了一起，并用符号标记出了它们的边界以及它们的出处。

在发生冲突后，Git 仓库处于一个「merge 冲突待解决」的中间状态，在这种状态下 `commit`，Git 就会自动地帮你添加「这是一个 merge commit」的提交信息。

同理，由于现在 Git 仓库处于冲突待解决的中间状态，所以如果最终决定放弃这次 `merge`，也需要执行一次 `merge --abort` 来手动取消它：

```shell
git merge --abort
```

## 特殊情况 2：HEAD 领先于目标 commit

如果 `merge` 时的目标 `commit` 和 `HEAD` 处的 `commit` 并不存在分叉，而是 `HEAD` 领先于目标 `commit`：

那么 `merge` 就没必要再创建一个新的 `commit` 来进行合并操作，因为并没有什么需要合并的。在这种情况下， Git 什么也不会做，`merge` 是一个空操作。

## 特殊情况 3：HEAD 落后于 目标 commit——fast-forward

而另一种情况：如果 `HEAD` 和目标 `commit` 依然是不存在分叉，但 `HEAD` 不是领先于目标 `commit`，而是落后于目标 `commit`。那么 Git 会直接把 `HEAD`（以及它所指向的 `branch`，如果有的话）移动到目标 `commit`。这种操作有一个专有称谓，叫做 "fast-forward"（快速前移）。

一般情况下，创建新的 `branch` 都是会和原 `branch` 并行开发的，不然没必要开 `branch` ，直接在原 `branch` 上开发就好。但事实上，上图中的情形其实很常见，因为这其实是 `pull` 操作的一种经典情形：本地的 `master` 没有新提交，而远端仓库中有同事提交了新内容到 `master`。

# 8 进阶 4：Feature Branching：最流行的工作流

## 简介

这种工作流的核心内容可以总结为两点：

- 任何新的功能（feature）或 bug 修复全都新建一个 `branch` 来写；
- `branch` 写完后，合并到 `master`，然后删掉这个 `branch`。

实质上，Feature Branching 这种工作流，为团队开发时两个关键的问题——代码分享和一人多任务——提供了解决方案。

## 1. 代码分享

还可以利用 Pull Request 来进一步简化。Pull Request 并不是 Git 的内容，而是一些 Git 仓库服务提供方（例如 GitHub）所提供的一种便捷功能，它可以让团队的成员方便地讨论一个 `branch` ，并在讨论结束后一键合并这个 `branch` 到 `master`。

- 把 `branch` `push` 到中央仓库；
- 在中央仓库处创建一个 Pull Request。

同事就可以在 GitHub 上看到创建的 Pull Request 了。他们可以在 GitHub 的这个页面查看你的 `commit`s，也可以给你评论表示赞同或提意见，你接下来也可以根据他们的意见把新的 `commit`s `push` 上来，这也页面会随着你新的 `push` 而展示出最新的 `commits`。

最后需要点一下页面中那个绿色的 "Merge pull request" 按钮，GitHub 就会自动地在中央仓库帮你把 `branch` 合并到 `master` 了。另外，GitHub 还设计了一个贴心的 "Delete branch" 按钮，方便你在合并之后一键删除 `branch`。

## 2. 一人多任务

如果是在独立的 `branch` 上做事，切换任务是很简单的。只要稍微把目前未提交的代码简单收尾一下，然后做一个带有「未完成」标记的提交（例如，在提交信息里标上「TODO」），然后回到 `master` 去创建一个新的 `branch` 就好了。

# 9 进阶 5：关于 add

## add 后面加个点 "."：全部暂存

`add` 指令除了 `git add 文件名` 这种用法外，还可以使用 `add .` 来直接把工作目录下的所有改动全部放进暂存区。

## add 添加的是文件改动，而不是文件名

通过 `add` 添加进暂存区的不是文件名，而是具体的文件改动内容。在 `add` 时的改动都被添加进了暂存区，但在 `add` 之后的新改动并不会自动被添加进暂存区。

# 10 进阶 6：看看我都改了什么

## 查看历史记录

`git log` 可以查看历史记录。

`log -p` 查看详细历史。可以看到每一个 `commit` 的每一行改动，所以很适合用于代码 review。`-p` 是 `--patch` 的缩写。

`log --stat` 查看简要统计。大致看一下改动内容，但不想深入到每一行的细节。

`show` 查看具体的 commit。如果你想看某个具体的 `commit` 的改动内容，可以用 `show`。

- 通过`git show`查看当前 `commit`

- 通过`commit`引用（`branch`或`HEAD`标记）或它的`SHA-1`码看任意一个`commit`。

- 在 `commit` 的引用或 `SHA-1` 后输入文件名，可以看指定 commit 中的指定文件。

## 看未提交的内容

如果想看未提交的内容，可以用 `diff`。

- 使用 `git diff --staged` 可以显示暂存区和上一条提交之间的不同。`--staged` 有一个等价的选项叫做 `--cached`。这里所谓的「等价」，是真真正正的等价，它们的意思完全相同。

- 使用 `git diff` （不加选项参数）可以显示工作目录和暂存区之间的不同。

- 使用 `git diff HEAD` 可以显示工作目录和上一条提交之间的不同，它是上面这二者的内容相加。如果把 `HEAD` 换成别的 `commit`，也可以显示当前工作目录和这条 `commit` 的区别。

# 11 高级 1：不喜欢 merge 的分叉？用 rebase 吧

## 11.1 rebase——在新位置重新提交

`rebase` 的意思是，给你的 `commit` 序列重新设置基础点（也就是父 `commit`）。展开来说就是，把你指定的 `commit` 以及它所在的 `commit` 串，以指定的目标 `commit` 为基础，依次重新提交一次。通过这样的方式，就让本来分叉了的提交历史重新回到了一条线。

```shell
git checkout branch1
git rebase master

git checkout master
git merge branch1
```

为了避免和远端仓库发生冲突，一般不要从 `master` 向其他 `branch` 执行 `rebase` 操作。而如果是 `master` 以外的 `branch` 之间的 `rebase`（比如 `branch1` 和 `branch2` 之间），就不必这么多费一步，直接 `rebase` 就好。

# 12 高级 2：刚刚提交的代码，发现写错了怎么办？

amend" 是「修正」的意思。在提交时，如果加上 `--amend` 参数，Git 不会在当前 `commit` 上增加 `commit`，而是会把当前 `commit` 里的内容和暂存区（stageing area）里的内容合并起来后创建一个新的 `commit`，用这个新的 `commit` 把当前 `commit` 替换掉。所以 `commit --amend` 做的事就是它的字面意思：对最新一条 `commit` 进行修正。

```shell
git add 笑声.txt
git commit --amend
```

需要注意的有一点：`commit --amend` 并不是直接修改原 `commit` 的内容，而是生成一条新的 `commit`。

# 13 高级 3：写错的不是最新的提交，而是倒数第二个？

## rebase -i：交互式 rebase

`rebase -i` 是 `rebase --interactive` 的缩写形式，意为「交互式 rebase」。所谓「交互式 rebase」，就是在 `rebase` 的操作执行之前，你可以指定要 `rebase` 的 `commit` 链中的每一个 `commit` 是否需要进一步修改。

说明：在 Git 中，有两个「偏移符号」： `^` 和 `~`。`^` 的用法：在 `commit` 的后面加一个或多个 `^` 号，可以把 `commit` 往回偏移，偏移的数量是 `^` 的数量。例如：`master^` 表示 `master` 指向的 `commit` 之前的那个 `commit`； `HEAD^^`  表示 `HEAD` 所指向的 `commit` 往前数两个 `commit`。`~` 的用法：在 `commit` 的后面加上 `~` 号和一个数，可以把 `commit` 往回偏移，偏移的数量是 `~` 号后面的数。例如：`HEAD~5` 表示 `HEAD` 指向的 `commit`往前数 5 个 `commit`。

```shell
git rebase -i HEAD^^
```

如果没有 `-i` 参数的话，这种「原地 rebase」相当于空操作，会直接结束。而在加了 `-i` 后，就会跳到一个新的界面。

## 编辑界面：选择 commit 和对应的操作

这两行指示了两个信息：

1. 需要处理哪些 `commit`s；
2. 怎么处理它们。

需要修改这两行的内容来指定你需要的操作。每个 `commit` 默认的操作都是 `pick` ，表示「直接应用这个 `commit`」。所以如果你现在直接退出编辑界面，那么结果仍然是空操作。

需要把它的操作指令从 `pick` 改成 `edit` 。 `edit` 的意思是「应用这个 commit，然后停下来等待继续修正」。把 `pick` 修改成 `edit` 后，就可以退出编辑界面了。

## 修改写错的 commit

修改完成之后，和上节里的方法一样，用 `commit --amend` 来把修正应用到当前最新的 `commit`：

```shell
git add 笑声
git commit --amend
```

## 继续 rebase 过程

在修复完成之后，就可以用 `rebase --continue` 来继续 `rebase` 过程，把后面的 `commit` 直接应用上去。

```shell
git rebase --continue
```

# 14 高级 4：比错还错，想直接丢弃刚写的提交？

## reset --hard 丢弃最新的提交

提交了`commit`，写完回头看了看，你觉得「不行这得重新写」。那么你可以用 `reset --hard` 来撤销这条 `commit`。

```shell
git reset --hard HEAD^
```

不过，你被撤销的那条提交并没有消失，只是你不再用到它了。如果你在撤销它之前记下了它的 `SHA-1` 码，那么你还可以通过 `SHA-1` 来找到他它。

# 15 高级 5：想丢弃的也不是最新的提交？

## 用交互式 rebase 撤销提交

之前讲的修正 `commit` 的方法是把要修改的 `commit` 左边的 `pick` 改成 `edit`，而如果你要撤销某个 `commit` ，做法就更加简单粗暴一点：直接删掉这一行就好。

`pick` 的直接意思是「选取」，在这个界面的意思就是应用这个 `commit`。而如果把这一行删掉，那就相当于在 `rebase` 的过程中跳过了这个 `commit`，从而也就把这个 `commit` 撤销掉了。

## 用 rebase --onto 撤销提交

`rebase` 加上 `--onto` 选项之后，可以指定 `rebase` 的「起点」。一般的 `rebase`，告诉 Git 的是「我要把当前 `commit` 以及它之前的 `commit`s 重新提交到目标 `commit` 上去，这其中，`rebase` 的「起点」是自动判定的：选取当前 `commit` 和目标 `commit` 在历史上的交叉点作为起点。而 `--onto` 参数，就可以额外给 rebase 指定它的起点。`--onto` 参数后面有三个附加参数：目标 `commit`、起点 `commit`（注意：rebase 的时候会把起点排除在外）、终点 `commit`。

```shell
git rebase --onto HEAD^^ HEAD^ branch1
```

上面这行代码的意思是：以倒数第二个 `commit` 为起点（起点不包含在 `rebase` 序列里哟），`branch1` 为终点，`rebase` 到倒数第三个 `commit` 上。

# 16 高级 6：代码已经 push 上去了才发现写错？

## 出错的内容在你自己的 branch

假如是某个你自己独立开发的 `branch` 出错了，不会影响到其他人，那没关系用前面几节讲的方法把写错的 `commit` 修改或者删除掉，然后再 `push` 上去就好了。由于你在本地对已有的 `commit` 做了修改，这时你再 `push` 就会失败，因为中央仓库包含本地没有的 `commit`s。你本来就希望用本地的内容覆盖掉中央仓库的内容。那么这时就不要乖乖听话，按照提示去先 `pull` 一下再 `push` 了，而是要选择「强行」`push`。

```shell
git push origin branch1 -f
```

## 出错的内容已经合并到 master

增加一个新的提交，把之前提交的内容抹掉。例如之前你增加了一行代码，你希望撤销它，那么你就做一个删掉这行代码的提交；如果你删掉了一行代码，你希望撤销它，那么你就做一个把这行代码还原回来的提交。这种事做起来也不算麻烦，因为 Git 有一个对应的指令：`revert`。

它的用法很简单，你希望撤销哪个 `commit`，就把它填在后面：

```shell
git revert HEAD^
```

上面这行代码就会增加一条新的 `commit`，它的内容和倒数第二个 `commit` 是相反的，从而和倒数第二个 `commit` 相互抵消，达到撤销的效果。

在 `revert` 完成之后，把新的 `commit` 再 `push` 上去，这个 `commit` 的内容就被撤销了。它和前面所介绍的撤销方式相比，最主要的区别是，这次改动只是被「反转」了，并没有在历史中消失掉，你的历史中会存在两条 `commit` ：一个原始 `commit` ，一个对它的反转 `commit`。

# 17 高级 7：reset 的本质——不止可以撤销提交

## reset 的本质：移动 HEAD 以及它所指向的 branch

`reset`的本质是移动`HEAD`，并且捎带上`HEAD`所指向的`branch`，也就是说它是用来重置`HEAD`以及它所指向的`branch`的位置的。而 `reset --hard HEAD^` 之所以起到了撤销 `commit` 的效果，是因为它把 `HEAD` 和它所指向的 `branch` 一起移动到了当前 `commit` 的父 `commit` 上，从而起到了「撤销」的效果。

所以同理，`reset --hard` 不仅可以撤销提交，还可以用来把 `HEAD` 和 `branch` 移动到其他的任何地方。

## reset --hard：重置工作目录
## reset --soft：保留工作目录
## reset 不加参数：保留工作目录，并清空暂存区

# 18 高级 8：checkout 的本质

实质上，`checkout` 并不止可以切换 `branch`。`checkout` 本质上的功能其实是：签出（ checkout ）指定的 `commit`。

`git checkout branch名` 的本质，其实是把 `HEAD` 指向指定的 `branch`，然后签出这个 `branch` 所对应的 `commit` 的工作目录。所以同样的，`checkout` 的目标也可以不是 `branch`，而直接指定某个 `commit`。

在 `git status` 的提示语中，Git 会告诉你可以用 `checkout -- 文件名` 的格式，通过「签出」的方式来撤销指定文件的修改。

## checkout 和 reset 的不同

`checkout` 和 `reset` 都可以切换 `HEAD` 的位置，它们除了有许多细节的差异外，最大的区别在于：`reset` 在移动 `HEAD` 时会带着它所指向的 `branch` 一起移动，而 `checkout` 不会。当你用 `checkout` 指向其他地方的时候，`HEAD` 和 它所指向的 `branch` 就自动脱离了。

事实上，`checkout` 有一个专门用来只让 `HEAD` 和 `branch` 脱离而不移动 `HEAD` 的用法：

```shell
git checkout --detach
```

执行这行代码，Git 就会把 `HEAD` 和 `branch` 脱离，直接指向当前 `commit`。

# 19 高级 9：紧急情况：「立即给我打个包，现在马上！」

## stash：临时存放工作目录的改动

"stash" 这个词，和它意思比较接近的中文翻译是「藏匿」，是「把东西放在一个秘密的地方以备未来使用」的意思。在 Git 中，`stash` 指令可以帮你把工作目录的内容全部放在你本地的一个独立的地方，它不会被提交，也不会被删除，你把东西放起来之后就可以去做你的临时工作了，做完以后再来取走，就可以继续之前手头的事了。

注意：没有被 track 的文件（即从来没有被 add 过的文件不会被 stash 起来，因为 Git 会忽略它们。如果想把这些文件也一起 stash，可以加上 `-u` 参数，它是 `--include-untracked` 的简写。

```shell
git stash -u
```

# 20 高级 10：branch 删过了才想起来有用？

## reflog ：引用的 log

`reflog` 是 "reference log" 的缩写，使用它可以查看 Git 仓库中的引用的移动记录。如果不指定引用，它会显示 `HEAD` 的移动记录。假如你误删了 `branch1` 这个 `branch`，那么你可以查看一下 `HEAD` 的移动历史。

`HEAD` 的最后一次移动行为是「从 `branch1` 移动到 `master`」。而在这之后，`branch1` 就被删除了。所以它之前的那个 `commit` 就是 `branch1` 被删除之前的位置了，也就是第二行的 `c08de9a`。

所以现在就可以切换回 `c08de9a`，然后重新创建 `branch1` ：

```shell
git checkout c08de9a
git checkout -b branch1
```

这样，你刚删除的 `branch1` 就找回来了。

注意：不再被引用直接或间接指向的 `commit`s 会在一定时间后被 Git 回收，所以使用 `reflog` 来找回删除的 `branch` 的操作一定要及时，不然有可能会由于 `commit` 被回收而再也找不回来。

## 查看其他引用的 reflog

`reflog` 默认查看 `HEAD` 的移动历史，除此之外，也可以手动加上名称来查看其他引用的移动历史，例如某个 `branch`。

```shell
git reflog master
```

# 21 额外说点：.gitignore——排除不想被管理的文件和目录

在 Git 中有一个特殊的文本文件：`.gitignore`。这个文本文件记录了所有你希望被 Git 忽略的目录和文件。

如果你是在 GitHub 上创建仓库，你可以在创建仓库的界面中就通过选项来让 GitHub 帮你创建好一个符合项目类型的 `.gitignore` 文件，你就不用再自己麻烦去写一大堆的配置了。不过如果你不是在 GitHub 上创建的项目，或者你对 GitHub 帮你创建的 `.gitignore` 文件有一些额外的补充，那么你可以自己来编辑这个文件。

文件中 `#` 打头的是注释文件，其他的都是对忽略文件的配置。匹配规则从上图中就能看出个大致，具体的匹配规则可以去官网的相关条目查看。

# 22 总结

除了这本小册里讲到的那些「关键点」，还有些 Git 的相关知识虽然也比较有用，但属于稍微研究一下就可以学会的内容。

## tag：不可移动的 branch

`tag` 是一个和 `branch` 非常相似的概念，它和 `branch` 最大的区别是：`tag` 不能移动。所以在很多团队中，`tag` 被用来在关键版本处打标记用。

## cherry-pick：把选中的 commits 一个个合并进来

`cherry-pick` 是一种特殊的合并操作，使用它可以点选一批 `commit`s，按序合并。

## git config： Git 的设置

`git config` 可以对 Git 做出基础设置，例如用户名、用户邮箱，以及界面的展示形式。内容虽然多，但都不难。

## Git Flow：复杂又高效的工作流

除了前面讲到的 "Feature Branching"，还有一个也很流行的工作流：Git Flow。Git Flow 的机制非常完善，很适合大型团队的代码管理。不过由于它的概念比较复杂（虽然难度并不高），所以并不适合新手直接学习，而更适合在不断的自我研究中逐渐熟悉，或者在团队合作中慢慢掌握。