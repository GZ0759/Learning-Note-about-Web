> Git原理详解及实用指南 掘金小册
> 扔物线 Android 开发者

# 1 什么是版本控制系统（VCS）

## 版本控制：最基本功能

版本控制系统（VCS）最基本的功能是版本控制。所谓版本控制，意思就是在文件的修改历程中保留修改历史，可以方便地撤销之前对文件的修改操作。最简化的版本控制模型，就是大多数主流文本编辑器都有的撤销（Undo）功能。

## 主动提交：程序代码和普通文本的区别

 VCS 和文本编辑器的撤销功能比起来，有一个很重要的区别是：程序代码的修改的生命周期非常长。 VCS 保存修改历史，使用的是主动提交改动的机制。在写完一段完整的代码之后，使用 commit 命令把改动和对改动的描述信息提交，这样就能记录到版本历史当中了。

## 多人合作的同步需求：中央仓库

中央仓库作为代码的存储中心，所有人的改动都会上传到这里，所有人也都能看到和下载别人上传的改动，解决同步的需求。

版本控制、主动提交和中央仓库这三个元素，共同构成了版本控制系统（VCS）的核心。开发团队中的每个人都向中央仓库主动提交自己的改动和同步别人的改动，并在需要的时候查看和操作历史版本，这就是版本控制系统。

## 中央式版本控制系统工作模型

第一次加入团队时，把中央仓库的代码取下来；
写完的新功能提交到中央仓库；
同事提交到中央仓库的新代码，及时同步下来。

这就是中央式 VCS 最基本的工作模型。实际的开发工作并没有简单到这种程序，因为时常需要处理代码冲突、查看版本历史、回退代码版本等。另外，Git 属于分布式 VCS ，它的概念也比中央式VCS要复杂一些。

# 2 什么是分布式版本控制系统（DVCS）

## 区别和功能比较

分布式 VCS （Distributed VCS / DVCS）和中央式的区别在于，分布式 VCS 除了中央仓库之外，还有本地仓库：团队中每一个成员的机器上都有一份本地仓库，这个仓库里包含了所有的版本历史，或者换句话说，每个人在自己的机器上就可以提交代码、查看历史，而无需联网和中央仓库交互——当然，取而代之的，你需要和本地仓库交互。

中央式 VCS 的中央仓库有两个主要功能：保存版本历、同步团队代码。而在分布式 VCS 中，保存版本历史的工作转交到了每个团队成员的本地仓库中，中央仓库就只剩下了同步团队代码这一个主要任务。它的中央仓库依然也保存了历史版本，但这份历史版本更多的是作为团队间的同步中转站。工作模型和上一节讲的「中央式 VCS 的工作模型」很相似，只是把代码的提交和上传过程拆开了。

## 优点与缺点

优点：

- 大多数的操作可以在本地进行，所以速度更快，而且由于无需联网，所以即使不在公司甚至没有在联网，你也可以提交代码、查看历史，从而极大地减小了开发者的网络条件和物理位置的限制（例如，你可以在飞机上提交代码、切换分支等等）；
- 由于可以提交到本地，所以你可以分步提交代码，把代码提交做得更细，而不是一个提交包含很多代码，难以 review 也难以回溯。

缺点：

- 由于每一个机器都有完整的本地仓库，所以初次获取项目的时候会比较耗时；
- 由于每个机器都有完整的本地仓库，所以本地占用的存储比中央式 VCS 要高。

# 3 上手 1：新公司用 Git 管理代码，怎么快速上手？

这个 `.git` 目录，就是本地仓库（Local Repository），所有版本信息都会存在这里。而 `.git` 所在的这个根目录，称为 Git 的工作目录（Working Directory），它保存了你当前从仓库中签出（checkout）的内容。

stage 这个词在 Git 里，是「集中收集改动以待提交」的意思。所谓的 staging area，是 `.git` 目录下一个叫做 `index` 的文件。通过 `add` 指令暂存的内容，都会被写进这个文件里。

# 4 上手 2：团队工作的基本工作模型

写完所有的 `commit` 后，不用考虑中央仓库是否有新的提交，直接 `push` 就好。

如果 `push` 失败，就用 `pull` 把本地仓库的提交和中央仓库的提交进行合并，然后再 `push` 一次。

`git pull` 这个指令的内部实现就是把远程仓库使用 `git fetch` 取下来以后再进行 merge 操作的。


# 5 进阶 1：HEAD、master 与 branch

## 引用：commit 的快捷键

在 Git 的使用中，经常会需要对指定的 `commit` 进行操作。每一个 `commit` 都有一个它唯一的指定方式——它的 SHA-1 校验和。两个 SHA-1 值的重复概率极低，所以你可以使用这个 SHA-1 值来指代 `commit`，也可以只使用它的前几位来指代它（例如第一个 `78bb0ab7d541…16b77`，你使用 `78bb0ab` 甚至 `78bb` 来指代它通常也可以），但毕竟这种没有任何含义的字符串是很难记忆的，所以 Git 提供了「引用」的机制：使用固定的字符串作为引用，指向某个 `commit`，作为操作 `commit` 时的快捷方式。

## HEAD：当前 commit 的引用。

 `HEAD` 是引用中最特殊的一个：它是指向当前 `commit` 的引用。所谓当前 `commit`这个概念很简单，它指的就是当前工作目录所对应的 `commit`。

 每次当有新的 `commit` 的时候，工作目录自动与最新的 `commit` 对应；而与此同时，`HEAD` 也会转而指向最新的 `commit`。事实上，当使用 `checkout`、`reset` 等指令手动指定改变当前 `commit` 的时候，`HEAD` 也会一起跟过去。所以永远可以用 `HEAD` 来操作当前 `commit`。

## branch

`HEAD` 是 Git 中一个独特的引用，它是唯一的。而除了 `HEAD` 之外，Git 还有一种引用，叫做 `branch`（分支）。`HEAD` 除了可以指向 `commit`，还可以指向一个 `branch`，当它指向某个 `branch` 的时候，会通过这个 `branch` 来间接地指向某个 `commit`；另外，当 `HEAD` 在提交时自动向前移动的时候，它会像一个拖钩一样带着它所指向的 `branch` 一起移动。

## master: 默认 branch

上面的这个 `master` ，其实是一个特殊的 `branch`：它是 Git 的默认 `branch`（俗称主 `branch` / 主分支）。

新创建的 repository（仓库）是没有任何 `commit` 的。但在它创建第一个 `commit` 时，会把 `master` 指向它，并把 `HEAD` 指向 `master`。

当有人使用 `git clone` 时，除了从远程仓库把 `.git` 这个仓库目录下载到工作目录中，还会 `checkout` （签出） `master`（`checkout` 的意思就是把某个 `commit` 作为当前 `commit`，把 `HEAD` 移动过去，并把工作目录的文件内容替换成这个 `commit` 所对应的内容）。

## branch 的通俗化理解

尽管在 Git 中，`branch` 只是一个指向 `commit` 的引用，但它有一个更通俗的理解：你还可以把一个 `branch` 理解为从初始 `commit` 到 `branch` 所指向的 `commit` 之间的所有 `commit`s 的一个「串」。

- 所有的 `branch` 之间都是平等的。
- `branch` 包含了从初始 `commit` 到它的所有路径，而不是一条路径。并且，这些路径之间也是彼此平等的。

## branch 的创建、切换和删除

如果你想在某处创建 `branch` ，只需要输入一行 `git branch 名称`。

不过新建的 `branch` 并不会自动切换，你的 `HEAD` 在这时依然是指向 `master` 的。你需要用 `checkout` 来主动切换到你的新 `branch` 去。然后 `HEAD` 就会指向新建的 `branch` 了

除此之外，你还可以用 `git checkout -b 名称` 来把上面两步操作合并执行。这行代码可以帮你用指定的名称创建 `branch` 后，再直接切换过去。

删除 `branch` 的方法非常简单：`git branch -d 名称`。

-  `HEAD` 指向的 `branch` 不能删除。如果要删除 `HEAD` 指向的 `branch`，需要先用 `checkout` 把 `HEAD` 指向其他地方。

-  由于 Git 中的 `branch` 只是一个引用，所以删除 `branch` 的操作也只会删掉这个引用，并不会删除任何的 `commit`。（不过如果一个 `commit` 不在任何一个 `branch` 的「路径」上，或者换句话说，如果没有任何一个 `branch` 可以回溯到这条 `commit`（也许可以称为野生 `commit`），那么在一定时间后，它会被 Git 的回收机制删除掉。）

-  出于安全考虑，没有被合并到 `master` 过的 `branch` 在删除时会失败（因为怕你误删掉「未完成」的 `branch` 啊）。这种情况如果你确认是要删除这个 `branch` ，可以把 `-d` 改成 `-D`，小写换成大写，就能删除了。

如果我们想要 HEAD 的第 10 个祖先提交，我们直接用 HEAD~10 就可以了。~ 用来表示一个提交的第 n 个祖先提交，如果不指定 n，那么默认为 1。另外，HEAD~~~ 和 HEAD~3 是等价的。

如果一个提交有多个父提交，那么 ~ 只会找第一个父提交。^ 用来表示一个提交的第 n 个父提交，如果不指定 n，那么默认为 1。和 ~ 不同的是，HEAD^^^ 并不等价于 HEAD^3，而是等价与 HEAD^1^1^1。

~ 获取第一个祖先提交，^ 可以获取第一个父提交。其实第一个祖先提交就是第一个父提交，反之亦然。因此，当 n 为 1 时，~ 和 ^ 其实是等价的。譬如：HEAD~~~ 和 HEAD^^^ 是等价的。

# 6 进阶 2：push 的本质

## push：把 branch 上传到远端仓库

实质上，`push` 做的事是：把当前 `branch` 的位置（即它指向哪个 `commit`）上传到远端仓库，并把它的路径上的 `commit`s 一并上传。

而如果这时候我再切到 `feature1` 去后再执行一次 `push`，就会把 `feature1` 以及它的 `commit` `4` 上传到远程仓库。

在 Git 中，默认情况下，用不加参数的 `git push` 只能上传那些之前从远端 `clone` 下来或者 `pull` 下来的分支，而如果需要 `push` 你本地的自己创建的分支，则需要手动指定目标仓库和目标分支（并且目标分支的名称必须和本地分支完全相同）。

```shell
git checkout feature1
git push origin feature1
```

`push` 的时候之后上传当前分支，并不会上传 `HEAD`；远程仓库的 `HEAD` 是永远指向默认分支（即 `master`）的。

# 7 进阶 3：merge：合并 commits

# 8 进阶 4：Feature Branching：最流行的工作流

# 9 进阶 5：关于 add

# 10 进阶 6：看看我都改了什么

# 11 高级 1：不喜欢 merge 的分叉？用 rebase 吧

# 12 高级 2：刚刚提交的代码，发现写错了怎么办？

# 13 高级 3：写错的不是最新的提交，而是倒数第二个？

# 14 高级 4：比错还错，想直接丢弃刚写的提交？

# 15 高级 5：想丢弃的也不是最新的提交？

# 16 高级 6：代码已经 push 上去了才发现写错？

# 17 高级 7：reset 的本质——不止可以撤销提交

# 18 高级 8：checkout 的本质

# 19 高级 9：紧急情况：「立即给我打个包，现在马上！」

# 20 高级 10：branch 删过了才想起来有用？

# 21 额外说点：.gitignore——排除不想被管理的文件和目录

# 22 总结
