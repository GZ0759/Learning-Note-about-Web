> JavaScript高级程序设计第三版  
> Professional JavaScript for Web Developers  
> 2012年3月第一次出版  

# 第1章 JavaScript简介　

JavaScript 诞生于 1995 年。当时，它的主要目的是处理以前由服务器端语言（如 Perl）负责的一些输入验证操作。

1.1 JavaScript简史　

## 1.2 JavaScript实现　

ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMA-262标准的实现和扩展。

一个完整的JavaScript实现应该由下列三个不同的部分组成，核心（ECMAScript）、文档对象模型（DOM）、浏览器对象模型（BOM）。

组成部分包括语法、类型、语句、关键字、保留字、操作符和对象。

文档对象模型（DOM）。文档对象模型是针对XML但经过扩展用于HTML的应用程序标称接口（API）。
- DOM1级由DOM核心和DOM HTML两个模块组成，目标主要是映射文档的结构。
- DOM2级在原来DOM的基础上又扩充了鼠标和用户界面时间、范围、遍历等细分模块，而且通过对象接口增加了对CSS的支持。
- DOM3级引入了以统一方式加载和保存文档的方法、新增了验证文档的方法，对DOM核心进行了扩展。

浏览器对象模型（BOM）。可以访问和操作浏览器窗口，使用 BOM 可以控制浏览器显示的页面以外的部分。从本质上来说，BOM 只处理浏览器窗口和框架，但是人们习惯把所有针对浏览器的 JavaScript 扩展算作 BOM 的一部分。
- 弹出新浏览器窗口的功能；
- 移动、缩放和关闭浏览器窗口的功能；
- 提供浏览器详细信息的 navigator 对象；
- 提供浏览器所加载页面的详细信息的 location 对象；
- 提供用户显示器分辨率详细信息的 screen 对象；
- 对 cookies 的支持；
- 像 XMLHttpRequest 和 IE 的 ActiveXObject 这样的自定义对象。

1.3 JavaScript版本　
1.4 小结　

# 第2章 在HTML中使用JavaScript　

## 2.1 `<script>`元素　

向HTML页面中插入JavaScript的主要方法，就是使用`<script>`元素。HTML 4.01为`<script>`定义了六个属性。

- `async`：可选。异步，表示应该立即下载脚本，但不应妨碍页面中的其他操作。
- `charset`：可选。表示通过 src 属性指定的代码的字符集。
- `defer`：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。
- `language`：已废弃。
- `src`：可选。表示包含要执行代码的外部文件。
- `type`：可选。可以看成是 language 的替代属性；表示编写代码使用的脚本语言的内容类型（也称为 MIME 类型）

标签的位置。按照传统的做法，所有`<script>`元素都应该放在页面的`<head>`元素中。这种做法的目的是把所有外部文件的引用都放在相同的地方。

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Example HTML Page</title>
    <script type="text/javascript" src="example1.js"></script>
    <script type="text/javascript" src="example2.js"></script>
  </head>
  <body>
  <!-- 这里放内容 -->
  </body>
</html>
```

现代 Web 应用程序一般都把全部 JavaScript 引用放在`<body>`元素中页面内容的后面。这样，在解析包含的 JavaScript 代码之前，页面的内容将完全呈现在浏览器中，窗口显示空白页面的时间缩短。

HTML 4.01 为`<script>`标签定义了 defer 属性，脚本会被延迟到整个页面都解析完毕后再运行。HTML5 为`<script>`元素定义了 async 属性，表示异步脚本，只适用于外部脚本文件，并告诉浏览器立即下载文件。但标记为 async 的脚本并不保证按照指定它们的先后顺序执行。

## 2.2 嵌入代码与外部文件　

在 HTML 中嵌入 JavaScript 代码虽然没有问题，但一般认为最好的做法还是尽可能使用外部文件来包含 JavaScript 代码。优点如下：

- 可维护性：遍及不同 HTML 页面的 JavaScript 会造成维护问题。
- 可缓存：浏览器能够根据具体的设置缓存链接的所有外部 JavaScript 文件,加快页面加载的速度。
- 适应未来：通过外部文件来包含 JavaScript 无须使用前面提到 XHTML 或注释 hack。

## 2.3 文档模式　

IE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（doctype）切换实现的。虽然这两种模式主要影响 CSS 内容的呈现，但在某些情况下也会影响到 JavaScript 的解释执行。在此之后， IE 又提出一种所谓的准标准模式（almost standards mode）。

- 混杂模式（quirks mode）。让 IE 的行为与（包含非标准特性的）IE5 相同。
- 标准模式（standards mode）。让 IE 的行为更接近标准行为。

如果在文档开始处没有发现文档类型声明，则所有浏览器都会默认开启混杂模式。但采用混杂模式不是什么值得推荐的做法，因为不同浏览器在这种模式下的行为差异非常大，如果不使用某些 hack 技术，跨浏览器的行为根本就没有一致性可言。

对于标准模式，可以通过使用下面任何一种文档类型来开启：

```html
<!-- HTML 4.01 严格型 -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">

<!-- XHTML 1.0 严格型 -->
<!DOCTYPE html PUBLIC
"-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<!-- HTML 5 -->
<!DOCTYPE html>
```

而对于准标准模式，则可以通过使用过渡型（transitional）或框架集型（frameset）文档类型来触发，如下所示：

```html
<!-- HTML 4.01 过渡型 -->
<!DOCTYPE HTML PUBLIC
"-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<!-- HTML 4.01 框架集型 -->
<!DOCTYPE HTML PUBLIC
"-//W3C//DTD HTML 4.01 Frameset//EN"
"http://www.w3.org/TR/html4/frameset.dtd">

<!-- XHTML 1.0 过渡型 -->
<!DOCTYPE html PUBLIC
"-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- XHTML 1.0 框架集型 -->
<!DOCTYPE html PUBLIC
"-//W3C//DTD XHTML 1.0 Frameset//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
```

## 2.4 `<noscript>`元素　

早期浏览器都面临一个特殊的问题，即当浏览器不支持 JavaScript 时如何让页面平稳地退化。对这个问题的最终解决方案就是创造一个`<noscript>`元素，用以在不支持 JavaScript 的浏览器中显示替代
的内容。这个元素可以包含能够出现在文档`<body>`中的任何 HTML 元素——`<script>`元素除外。包含在`<noscript>`元素中的内容只有在下列情况下才会显示出来：

- 浏览器不支持脚本；
- 浏览器支持脚本，但脚本被禁用。

2.5　小结　

# 第3章 基本概念　

## 3.1 语法　

### 3.1.1 区分大小写

ECMAScript 中的一切都区分大小写，例如变量、函数名和操作符。这也就意味着，变量名 test 和变量名 Test 分别表示两个不同的变量，而函数名不能使用 typeof，因为它是一个关键字，但 typeOf 则完全可以是一个有效的函数名。

### 3.1.2 标识符

所谓标识符，就是指变量、函数、属性的名字，或者函数的参数。标识符可以是按照下列格式规则组合起来的一或多个字符：

- 第一个字符必须是一个字母、下划线（_）或一个美元符号（$）；
- 其他字符可以是字母、下划线、美元符号或数字。

标识符中的字母也可以包含扩展的 ASCII 或 Unicode 字母字符（如 À 和 Æ），但不推荐这样做。

按照惯例， ECMAScript 标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的首字母大写，例如：

- firstSecond
- myCar
- doSomethingImportant

不能把关键字、保留字、 true、 false 和 null 用作标识符。

### 3.1.3 注释

ECMAScript 使用 C 风格的注释，包括单行注释和块级注释。单行注释以两个斜杠开头，块级注释以一个斜杠和一个星号（`/*`）开头，以一个星号和一个斜杠（`*/`）结尾。

```js
// 单行注释

/*
* 这是一个多行
* （块级）注释
*/
```

虽然上面注释中的第二和第三行都以一个星号开头，但这不是必需的。之所以添加那两个星号，纯粹是为了提高注释的可读性。

CSS无论是单行注释还是跨行注释都是使用`/*`和`*/`包围，而 HTML 则是使用`<!--注释内容-->`进行注释。

### 3.1.4 严格模式

ECMAScript 5 引入了严格模式（strict mode）的概念。严格模式是为 JavaScript 定义了一种不同的解析与执行模型。在严格模式下， ECMAScript 3 中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码：

```js
"use strict";
```

这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指示（pragma），用于告诉支持的 JavaScript 引擎切换到严格模式。这是为不破坏 ECMAScript 3 语法而特意选定的语法。在函数内部的上方包含这条编译指示，也可以指定函数在严格模式下执行：

```js
function doSomething(){
"use strict";
//函数体
}
```

### 3.1.5 语句

ECMAScript 中的语句以一个分号结尾；如果省略分号，则由解析器确定语句的结尾，如下例所示：

```js
var sum = a + b // 即使没有分号也是有效的语句——不推荐
var diff = a - b; // 有效的语句——推荐
```

虽然语句结尾的分号不是必需的，但建议任何时候都不要省略它。因为加上这个分号可以避免很多错误（例如不完整的输入），开发人员也可以放心地通过删除多余的空格来压缩 ECMAScript 代码（代码行结尾处没有分号会导致压缩错误）。另外，加上分号也会在某些情况下增进代码的性能，因为这样解析器就不必再花时间推测应该在哪里插入分号了。

可以使用 C 风格的语法把多条语句组合到一个代码块中，即代码块以左花括号（`{`）开头，以右花括号（`}`）结尾：

```js
if (test){
  test = false;
  alert(test);
}
```

虽然条件控制语句（如 if 语句）只在执行多条语句的情况下才要求使用代码块，但最佳实践是始终在控制语句中使用代码块——即使代码块中只有一条语句，例如：

```js
if (test)
  alert(test); // 有效但容易出错，不要使用

if (test){ // 推荐使用
  alert(test);
}
```

在控制语句中使用代码块可以让编码意图更加清晰，而且也能降低修改代码时出错的几率。

## 3.2 关键字和保留字　

ECMA-262 描述了一组具有特定用途的关键字，这些关键字可用于表示控制语句的开始或结束，或者用于执行特定操作等。按照规则，关键字也是语言保留的，不能用作标识符。ECMA-262 还描述了另外一组不能用作标识符的保留字。尽管保留字在这门语言中还没有任何特定的用途，但它们有可能在将来被用作关键字。

第 5 版把在非严格模式下运行时的保留字缩减为下列这些：

| class | enum   | extends | super |
| const | export | import  |       |

在严格模式下，第 5 版还对以下保留字施加了限制：

| implements | package   | public |
| interface  | private   | static |
| let        | protected | yield  |

在实现 ECMAScript 3 的 JavaScript 引擎中使用关键字作标识符，会导致“Identifier Expected”错误。而使用保留字作标识符可能会也可能不会导致相同的错误，具体取决于特定的引擎。

第 5 版对使用关键字和保留字的规则进行了少许修改。关键字和保留字虽然仍然不能作为标识符使用，但现在可以用作对象的属性名。一般来说，最好都不要使用关键字和保留字作为标识符和属性名，以便与将来的 ECMAScript 版本兼容。

除了上面列出的保留字和关键字， ECMA-262 第 5 版对 eval 和 arguments 还施加了限制。在严格模式下，这两个名字也不能作为标识符或属性名，否则会抛出错误。

## 3.3 变量　

ECMAScript 的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。换句话说，每个变量仅仅是一个用于保存值的占位符而已。定义变量时要使用 var 操作符（注意 var 是一个关键字），后跟变量名（即一个标识符）。如果变量是未经过初始化的，会保存一个特殊的值——undefined。 ECMAScript 也支持直接初始化变量，因此在定义变量的同时就可以设置变量的值。

```js
// 未经过初始化
var message;

// 初始化变量
var message = "hi";
```

可以在修改变量值的同时修改值的类型。但是不建议修改变量所保存值的类型，虽然这种操作在 ECMAScript 中完全有效。

```js
var message = "hi";
message = 100; // 有效，但不推荐
```

有一点必须注意，即用 var 操作符定义的变量将成为定义该变量的作用域中的局部变量。也就是说，如果在函数中使用 var 定义一个变量，那么这个变量在函数退出后就会被销毁。不过，可以省略 var 操作符，从而创建一个全局变量。虽然省略 var 操作符可以定义全局变量，但这不是推荐的做法。给未经声明的变量赋值在严格模式下会导致抛出 ReferenceError 错误。

```JavaScript
function test(){
  var message = "hi"; // 局部变量
}
test();
alert(message); // 错误！
```

```JavaScript
function test(){
  message = "hi"; // 全局变量
}
test();
alert(message); // "hi"
```

可以使用一条语句定义多个变量，只要像下面这样把每个变量（初始化或不初始化均可）用逗号分隔开即可。虽然代码里的换行和变量缩进不是必需的，但这样做可以提高可读性。在严格模式下，不能定义名为 eval 或 arguments 的变量，否则会导致语法错误。

```js
var message = "hi",
found = false,
age = 29;
```

## 3.4 数据类型　

ECMAScript 中有五种简单数据类型（也称为基本数据类型）：`Undefined`、`Null`、`Boolean`、`Number`和 `String`。还有一种复杂数据类型——`Object`，`Object` 本质上是由一组无序的名值对组成的。ECMAScript不支持任何创建自定义类型的机制，而所有值最终都将是上述六种数据类型之一。由于 ECMAScript 数据类型具有动态性，因此没有再定义其他数据类型的必要了。

### 3.4.1 typeof 操作符

鉴于 ECMAScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型——`typeof` 就是负责提供这方面信息的操作符。对一个值使用 `typeof` 操作符可能返回下列某个字符串：

1. "undefined"——如果这个值未定义；
2. "boolean"——如果这个值是布尔值；
3. "string"——如果这个值是字符串；
4. "number"——如果这个值是数值；
5. "object"——如果这个值是对象或 null；
6. "function"——如果这个值是函数。

`typeof` 操作符的操作数可以是变量，也可以是数值字面量。注意，`typeof` 是一个操作符而不是函数，因此例子中的圆括号尽管可以使用，但不是必需的。

```js
var message = "some string";
alert(typeof message); // "string"
alert(typeof(message)); // "string"
alert(typeof 95); // "number"
```

有些时候， `typeof` 操作符会返回一些令人迷惑但技术上却正确的值。比如，调用 `typeof null` 会返回"object"，因为特殊值 null 被认为是一个空的对象引用。从技术角度讲，函数在 ECMAScript 中是对象，不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过 `typeof` 操作符来区分函数和其他对象是有必要的。

### 3.4.2 Undefined 类型

`Undefined` 类型是只有一个值，即特殊的 undefined，在使用 var 声明但未对其加以初始化时，这个变量的值就是 undefined。

```js
var message1;
alert(message1 == undefined); //true

var message2 = undefined;
alert(message2 == undefined); //true
```

包含 undefined 值的变量与尚未定义的变量还是不一样的。如果未声明却在使用，则会报错。但是，两者使用 typeof 操作符检测时都显示为 undefined。

```js
var message; // 这个变量声明之后默认取得了 undefined 值
// 下面这个变量并没有声明
// var age

alert(message); // "undefined"
alert(age); // 产生错误

alert(typeof message); // "undefined"
alert(typeof age); // "undefined"
```

即便未初始化的变量会自动被赋予 undefined 值，但显式地初始化变量依然是明智的选择。如果能够做到这一点，那么当 typeof 操作符返回"undefined"值时，我们就知道被检测的变量还没有被声明，而不是尚未初始化。

### 3.4.3 Null 类型

`Null` 类型是第二个只有一个值的数据类型，这个特殊的值是 `null`。从逻辑角度来看， `null` 值表示一个空对象指针，而这也正是使用 typeof 操作符检测 `null` 值时会返回"object"的原因。

```js
var car = null;
alert(typeof car); // "object"
```

如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null 而不是其他值。这样一来，只要直接检查 null 值就可以知道相应的变量是否已经保存了一个对象的引用。

```js
if (car != null){
  // 对 car 对象执行某些操作
}
```

实际上， undefined 值是派生自 null 值的，因此 ECMA-262 规定对它们的相等性测试要返回 true：

```js
alert(null == undefined); //true
NullExample02.htm
```

尽管 null 和 undefined 有这样的关系，但它们的用途完全不同。如前所述，无论在什么情况下都没有必要把一个变量的值显式地设置为 undefined，可是同样的规则对 null 却不适用。换句话说，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存 null 值。这样做不仅可以体现 null 作为空对象指针的惯例，而且也有助于进一步区分 null 和 undefined。

### 3.4.4 Boolean 类型

Boolean 类型是 ECMAScript 中使用得最多的一种类型，该类型只有两个字面值：`true `和 `false`。需要注意的是，Boolean 类型的字面值 `true `和 `false` 是区分大小写的。也就是说，True 和 False （以及其他的混合大小写形式）都不是 Boolean 值，只是标识符。

虽然 Boolean 类型的字面值只有两个，但 ECMAScript 中所有类型的值都有与这两个 Boolean 值等价的值。要将一个值转换为其对应的 Boolean 值，可以调用转型函数 `Boolean()`。下表给出了各种数据类型及其对应的转换规则。

| 数据类型  |        转换为true的值        | 转换为false的值 |
| --------- | ---------------------------- | --------------- |
| Boolean   | true                         | false           |
| String    | 任何非空字符串               | ""（空字符串）  |
| Number    | 任何非零数字值（包括无穷大） | 0和NaN          |
| Object    | 任何对象                     | null            |
| Undefined |                              | undefined       |

这些转换规则对理解流控制语句（如 if 语句）自动执行相应的 Boolean 转换非常重要。因此确切地知道在流控制语句中使用的是什么变量至关重要。错误地使用一个对象而不是一个 Boolean 值，就有可能彻底改变应用程序的流程。

```js
var message = "Hello world!";
if (message){
  alert("Value is true");
}
```

### 3.4.5 Number 类型

Number 类型使用 IEEE754 格式来表示整数和浮点数值（浮点数值在某些语言中也被称为双精度数值）。为支持各种数值类型， ECMA-262 定义了不同的数值字面量格式。最基本的数值字面量格式是十进制整数，十进制整数可以这样直接在代码中输入。整数还可以通过八进制（以 8 为基数）或十六进制（以 16 为基数）的字面值来表示。其中，八进制字面值的第一位必须是零（0），然后是八进制数字序列（0～7）。如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析。

```js
var intNum = 55; // 整数
var octalNum1 = 070; // 八进制的 56
var octalNum2 = 079; // 无效的八进制数值——解析为 79
var octalNum3 = 08; // 无效的八进制数值——解析为 8
```

八进制字面量在严格模式下是无效的，会导致支持的 JavaScript 引擎抛出错误。十六进制字面值的前两位必须是 0x，后跟任何十六进制数字（0～9 及 A～F）。其中，字母 A～F 可以大写，也可以小写。

```js
var hexNum1 = 0xA; // 十六进制的 10
var hexNum2 = 0x1f; // 十六进制的 31
```

在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。

**浮点数值**。所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。虽然小数点前面可以没有整数，但我们不推荐这种写法。由于保存浮点数值需要的内存空间是保存整数值的两倍，因此 ECMAScript 会不失时机地将浮点数值转换为整数值。显然，如果小数点后面没有跟任何数字，那么这个数值就可以作为整数值来保存。同样地，如果浮点数值本身表示的就是一个整数（如 1.0），那么该值也会被转换为整数。

对于那些极大或极小的数值，可以用 e 表示法（即科学计数法）表示的浮点数值表示。用 e 表示法表示的数值等于 e 前面的数值乘以 10 的指数次幂。 ECMAScript 中 e 表示法的格式也是如此，即前面是一个数值（可以是整数也可以是浮点数），中间是一个大写或小写的字母 E，后面是 10 的幂中的指数，该幂值将用来与前面的数相乘。

```js
var floatNum = 3.125e7; // 等于 31250000
```

浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。例如， 0.1 加 0.2 的结果不是 0.3，而是 0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。关于浮点数值计算会产生舍入误差的问题，有一点需要明确：这是使用基于 IEEE754 数值的浮点计算的通病， ECMAScript 并非独此一家。

```js
var a = 0.1, b = 0.2
if (a + b == 0.3){ // 不要做这样的测试！
  alert("You got 0.3.");
}
```

**数值范围**。由于内存的限制， ECMAScript 并不能保存世界上所有的数值。 ECMAScript 能够表示的最小数值保存在 `Number.MIN_VALUE` 中——在大多数浏览器中，这个值是 5e-324；能够表示的最大数值保存在`Number.MAX_VALUE` 中——在大多数浏览器中，这个值是 1.7976931348623157e+308。如果某次计算的结果得到了一个超出 JavaScript 数值范围的值，那么这个数值将被自动转换成特殊的 Infinity 值。具体来说，如果这个数值是负数，则会被转换成-Infinity（负无穷），如果这个数值是正数，则会被转换成 Infinity（正无穷）。

如果某次计算返回了正或负的 Infinity 值，那么该值将无法继续参与下一次的计算，因为 Infinity 不是能够参与计算的数值。要想确定一个数值是不是有穷的（换句话说，是不是位于最
小和最大的数值之间），可以使用 `isFinite()`函数。这个函数在参数位于最小与最大数值之间时会返回 true。

```js
var result = Number.MAX_VALUE + Number.MAX_VALUE;
alert(isFinite(result)); //false
```

尽管在计算中很少出现某些值超出表示范围的情况，但在执行极小或极大数值的计算时，检测监控这些值是可能的，也是必需的。

**NaN**。`NaN`，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，在其他编程语言中，任何数值除以 0 都会导致错误，从而停止代码执行。但在 ECMAScript 中，任何数值除以 0 会返回 NaN，因此不会影响其他代码的执行。NaN 本身有两个非同寻常的特点。首先，任何涉及 NaN 的操作（例如 NaN/10）都会返回 NaN，这个特点在多步计算中有可能导致问题。其次， NaN 与任何值都不相等，包括 NaN 本身。

```js
alert(NaN == NaN); //false
```

针对 NaN 的这两个特点， ECMAScript 定义了 `isNaN()`函数。这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”。 `isNaN()`在接收到一个值之后，会尝试将这个值转换为数值。某些不是数值的值会直接转换为数值，例如字符串"10"或 Boolean 值。而任何不能被转换为数值的值都会导致这个函数返回 true。

```js
alert( isNaN(NaN) ); //true
alert( isNaN(10) ); //false（ 10 是一个数值）
alert( isNaN("10") ); //false（可以被转换成数值 10）
alert( isNaN("blue") ); //true（不能转换成数值）
alert( isNaN(true) ); //false（可以被转换成数值 1）
```

**数值转换**。有 3 个函数可以把非数值转换为数值： `Number()`、 `parseInt()`和 `parseFloat()`。第一个函数，即转型函数 `Number()`可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。这 3 个函数对于同样的输入会有返回不同的结果。

`Number()`函数的转换规则如下。

- 如果是 Boolean 值， true 和 false 将分别被转换为 1 和 0。
- 如果是数字值，只是简单的传入和返回。
- 如果是 null 值，返回 0。
- 如果是 undefined，返回 NaN。
- 如果是字符串，遵循下列规则：
  - 如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即"1"会变成 1， "123"会变成 123，而"011"会变成 11（注意：前导的零被忽略了）；
  - 如果字符串中包含有效的浮点格式，如"1.1"，则将其转换为对应的浮点数值（同样，也会忽略前导零）；
  - 如果字符串中包含有效的十六进制格式，例如"0xf"，则将其转换为相同大小的十进制整数值；
  - 如果字符串是空的（不包含任何字符），则将其转换为 0；
  - 如果字符串中包含除上述格式之外的字符，则将其转换为 NaN。
- 如果是对象，则调用对象的 `valueOf()`方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN，则调用对象的 `toString()`方法，然后再次依照前面的规则转换返回的字符串值。

```js
var num1 = Number("Hello world!"); //NaN
var num2 = Number(""); //0
var num3 = Number("000011"); //11
var num4 = Number(true); //1
```

由于 `Number()`函数在转换字符串时比较复杂而且不够合理，因此在处理整数的时候更常用的是`parseInt()`函数。 `parseInt()`函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直至找到第一个非空格字符。

- 如果第一个字符不是数字字符或者负号， `parseInt()`就会返回 NaN；也就是说，用 `parseInt()`转换空字符串会返回 NaN（`Number()`对空字符返回 0）。

- 如果第一个字符是数字字符， `parseInt()`会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。

- 如果字符串中的第一个字符是数字字符， `parseInt()`也能够识别出各种整数格式（即前面讨论的十进制、八进制和十六进制数）。

```js
var num1 = parseInt("1234blue"); // 1234
var num2 = parseInt(""); // NaN
var num3 = parseInt("0xA"); // 10（十六进制数）
var num4 = parseInt(22.5); // 22
var num5 = parseInt("070"); // 56（八进制数）
var num6 = parseInt("70"); // 70（十进制数）
var num7 = parseInt("0xf"); // 15（十六进制数）
```

在使用 `parseInt()`解析像八进制字面量的字符串时， ECMAScript 3 和 5 存在分歧。例如：

```js
//ECMAScript 3 认为是 56（八进制）， ECMAScript 5 认为是 70（十进制）
var num = parseInt("070");
```

为了消除在使用 `parseInt()`函数时可能导致的上述困惑，可以为这个函数提供第二个参数：转换时使用的基数（即多少进制）。如果知道要解析的值是十六进制格式的字符串，那么指定基数 16 作为第二个参数，可以保证得到正确的结果。

与`parseInt()`函数类似， `parseFloat()`也是从第一个字符（位置 0）开始解析每个字符。而且也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的第一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。

除了第一个小数点有效之外， `parseFloat()`与 `parseInt()`的第二个区别在于它始终都会忽略前导的零。 `parseFloat()`可以识别前面讨论过的所有浮点数值格式，也包括十进制整数格式。但十六进制格式的字符串则始终会被转换成 0。由于 `parseFloat()`只解析十进制值，因此它没有用第二个参数指定基数的用法。最后还要注意一点：如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后都是零）， `parseFloat()`会返回整数。

```js
var num1 = parseFloat("1234blue"); //1234 （整数）
var num2 = parseFloat("0xA"); //0
var num3 = parseFloat("22.5"); //22.5
var num4 = parseFloat("22.34.5"); //22.34
var num5 = parseFloat("0908.5"); //908.5
var num6 = parseFloat("3.125e7"); //31250000
```

### 3.4.6 String 类型

String 类型用于表示由零或多个 16 位 Unicode 字符组成的字符序列，即字符串。字符串可以由双引号（"）或单引号（'）表示。。用双引号表示的字符串和用单引号表示的字符串完全相同。不过，以双引号开头的字符串也必须以双引号结尾，而以单引号开头的字符串必须以单引号结尾。

```js
var firstName = "Nicholas";
var lastName = 'Zakas';
```

**字符字面量**。String 数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符，或者具有其他用途的字符。

| 字 面 量 |                          含 义                          |
| -------- | ------------------------------------------------------- |
| `\n`     | 换行                                                    |
| `\t`     | 制表                                                    |
| `\b`     | 空格                                                    |
| `\r`     | 回车                                                    |
| `\f`     | 进纸                                                    |
| `\\`     | 斜杠                                                    |
| `\'`     | 单引号（ '）                                            |
| `\"`     | 双引号（ "）                                            |
| `\xnn`   | 以十六进制代码nn表示的一个字符（其中n为0～ F）          |
| `\unnnn` | 以十六进制代码nnnn表示的一个Unicode字符（其中n为0～ F） |

这些字符字面量可以出现在字符串中的任意位置，而且也将被作为一个字符来解析。任何字符串的长度都可以通过访问其 length 属性取得，其中一个转义序列表示一个字符。

**字符串的特点**。ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。

**转换为字符串**。要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的 toString()方法。这个方法唯一要做的就是返回相应值的字符串表现。但 null 和 undefined 值没有这个方法。在调用数值的 toString()方法时，可以传递一个参数：输出数值的基数。

```js
var num = 10;
alert(num.toString()); // "10"
alert(num.toString(2)); // "1010"
alert(num.toString(8)); // "12"
alert(num.toString(10)); // "10"
alert(num.toString(16)); // "a"
```

在不知道要转换的值是不是 null 或 undefined 的情况下，还可以使用转型函数 `String()`，这个函数能够将任何类型的值转换为字符串。 `String()`函数遵循下列转换规则。

- 如果值有 toString()方法，则调用该方法（没有参数）并返回相应的结果；
- 如果值是 null，则返回"null"；
- 如果值是 undefined，则返回"undefined"。

要把某个值转换为字符串，可以使用加号操作符。

### 3.4.7 Object 类型

ECMAScript 中的对象其实就是一组数据和功能的集合。对象可以通过执行 new 操作符后跟要创建的对象类型的名称来创建。而创建 Object 类型的实例并为其添加属性和（或）方法，就可以创建自定义对象。

```js
var o = new Object();
```

这个语法与 Java 中创建对象的语法相似；但在 ECMAScript 中，如果不给构造函数传递参数，则可以省略后面的那一对圆括号。也就是说，在像前面这个示例一样不传递参数的情况下，完全可以省略那对圆括号（但这不是推荐的做法）：

```js
var o = new Object; // 有效，但不推荐省略圆括号
```

仅仅创建 Object 的实例并没有什么用处，但关键是要理解一个重要的思想：即在 ECMAScript 中，（就像 Java 中的 java.lang.Object 对象一样） Object 类型是所有它的实例的基础。换句话说，Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。

Object 的每个实例都有如下属性和方法。

1. `constructor`：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是 `Object()`。
2. `hasOwnProperty(propertyName)`：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如： `o.hasOwnProperty("name")`）。
3. `isPrototypeOf(object)`：用于检查传入的对象是否是传入对象的原型。
4. `propertyIsEnumerable(propertyName)`：用于检查给定的属性是否能够使用 for-in 语句来枚举。与 `hasOwnProperty()`方法一样，作为参数的属性名必须以字符串形式指定。
5. `toLocalString`：返回对象的字符串表示，该字符串与执行环境的地区对应。
6. `toString()`：返回对象的字符串表示。
7. `valueOf()`：返回对象的字符串、数值或布尔值表示。通常与 `toString()`方法的返回值相同。

由于在 ECMAScript 中 Object 是所有对象的基础，因此所有对象都具有这些基本的属性和方法。第 5 章和第 6 章将详细介绍 Object 与其他对象的关系。

## 3.5 操作符　

ECMA-262 描述了一组用于操作数据值的操作符，它们能够适用于很多值，例如字符串、数字值、布尔值，甚至对象。不过，在应用于对象时，相应的操作符通常都会调用对象的 `valueOf()` 和（或）`toString()`方法，以便取得可以操作的值。

### 3.5.1 一元操作符

递增和递减操作符

只能操作一个值的操作符叫做一元操作符。一元操作符是 ECMAScript 中最简单的操作符。

递增和递减操作符直接借鉴自 C，而且各有两个版本：前置型和后置型。顾名思义，前置型应该位于要操作的变量之前，而后置型则应该位于要操作的变量之后。因此，在使用前置递增操作符给一个数值加 1 时，要把两个加号（++）放在这个数值变量前面。

```js
var age = 29;
// 相当于age = age + 1;
++age;
```

执行前置递增和递减操作时，变量的值都是在语句被求值以前改变的。（在计算机科学领域，这种情况通常被称作副效应。）

```js
var age = 29;
var anotherAge = --age + 2;
alert(age); // 输出 28
alert(anotherAge); // 输出 30
```

后置型递增和递减操作符的语法不变（仍然分别是++和--），只不过要放在变量的后面而不是前面。后置递增和递减与前置递增和递减有一个非常重要的区别，即递增和递减操作是在包含它们的语句被求值之后才执行的。这个区别在某些情况下不是什么问题。

```js
var age = 29;
age++;
```

但是，当语句中还包含其他操作时，上述区别就会非常明显了。

```js
var num1 = 2;
var num2 = 20;
var num3 = num1-- + num2; // 等于 22
var num4 = num1 + num2; // 等于 21
```

所有这 4 个操作符对任何值都适用，也就是它们不仅适用于整数，还可以用于字符串、布尔值、浮点数值和对象。在应用于不同的值时，递增和递减操作符遵循下列规则。

- 在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减 1 的操作。字符串变量变成数值变量。
- 在应用于一个不包含有效数字字符的字符串时，将变量的值设置为 NaN 。字符串变量变成数值变量。
- 在应用于布尔值 false 时，先将其转换为 0 再执行加减 1 的操作。布尔值变量变成数值变量。
- 在应用于布尔值 true 时，先将其转换为 1 再执行加减 1 的操作。布尔值变量变成数值变量。
- 在应用于浮点数值时，执行加减 1 的操作。
- 在应用于对象时，先调用对象的 `valueOf()`方法以取得一个可供操作的值。然后对该值应用前述规则。如果结果是 NaN，则在调用 `toString()`方法后再应用前述规则。对象变量变成数值变量。

```js
var s1 = "2";
var s2 = "z";
var b = false;
var f = 1.1;
var o = {
  valueOf: function() {
    return -1;
  }
};
s1++; // 值变成数值 3
s2++; // 值变成 NaN
b++; // 值变成数值 1
f--; // 值变成 0.10000000000000009（由于浮点舍入错误所致）
o--; // 值变成数值-2
```

### 3.5.2 位操作符

位操作符，有按位非、按位与、按位或、按位异或、左移、有符号的右移、无符号的右移多种。

### 3.5.3 布尔操作符

布尔操作符，有逻辑非、逻辑与、逻辑或三种。

### 3.5.4 乘性操作符

乘性操作符有三个，乘法、除法和求模。

### 3.5.5 加性操作符

加性操作符有两种，加法、减法。

### 3.5.6 关系操作符

关系操作符有四种，小于、大于、小于等于和大于等于。

### 3.5.7 相等操作符

相等操作符有相等和不相等、全等和不全等四种，前面两种是先转换再比较，后面一种是比较而不转换。

### 3.5.8 条件操作符

条件操作符，条件（三元）运算符是JavaScript仅有的使用三个操作数的运算符。本运算符经常作为if语句的简短形式来使用。

### 3.5.9 赋值操作符

赋值操作符由等于号表示，每个主要算术操作符都有对应的复合赋值操作符，但设计这些操作符的主要目的就是简化赋值操作，使用他们不会带来任何性能的提升。

### 3.5.10 逗号操作符

逗号操作符，可以在一条语句中执行多个操作，主要用于声明多个变量、用于赋值。

## 3.6 语句　

ECMA-262 规定了一组语句（也称为流控制语句）。从本质上看，语句定义了 ECMAScript 中的主要语法，语句通常使用一或多个关键字来完成给定任务。语句可以很简单，例如通知函数退出；也可以比较复杂，例如指定重复执行某个命令的次数。

### 3.6.1 if语句

大多数编程语言中最为常用的一个语句就是 if 语句。

```js
if (condition) statement1 else statement2
```

其中的 condition（条件）可以是任意表达式；而且对这个表达式求值的结果不一定是布尔值。ECMAScript 会自动调用`Boolean()`转换函数将这个表达式的结果转换为一个布尔值。

如果对 condition 求值的结果是 true，则执行 statement1（语句 1），如果对 condition 求值的结果是 false，则执行 statement2 （语句 2）。而且这两个语句既可以是一行代码，也可以是一个代码块（以一对花括号括起来的多行代码）。不过，业界普遍推崇的最佳实践是始终使用代码块，即使要执行的只有一行代码。

```js
if (i > 25)
alert("Greater than 25."); // 单行语句
else {
alert("Less than or equal to 25."); // 代码块中的语句
}
IfStatementExample01.htm
```

### 3.6.2 do-while语句

do-while 语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。换句话说，在对条件表达式求值之前，循环体内的代码至少会被执行一次。

```js
do {
statement
} while (expression);
```

### 3.6.3 while语句

while 语句属于前测试循环语句，也就是说，在循环体内的代码被执行之前，就会对出口条件求值。因此，循环体内的代码有可能永远不会被执行。

```js
while(expression) statement
```

### 3.6.4 for语句

for 语句也是一种前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。使用 while 循环做不到的，使用 for 循环同样也做不到。也就是说， for 循环只是把与循环有关的代码集中在了一个位置。

```js
for (initialization; expression; post-loop-expression) statement
```

有必要指出的是，在 for 循环的变量初始化表达式中，也可以不使用 var 关键字。该变量的初始化可以在外部执行。由于 ECMAScript 中不存在块级作用域，因此在循环内部定义的变量也可以在外部访问到。

此外， for 语句中的初始化表达式、控制表达式和循环后表达式都是可选的。将这三个表达式全部省略，就会创建一个无限循环。

### 3.6.5 for-in语句

for-in 语句是一种精准的迭代语句，可以用来枚举对象的属性。

```js
for (property in expression) statement
```

ECMAScript 对象的属性没有顺序。因此，通过 for-in 循环输出的属性名的顺序是不可预测的。具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。

但是，如果表示要迭代的对象的变量值为 null 或 undefined， for-in 语句会抛出错误。ECMAScript 5 更正了这一行为；对这种情况不再抛出错误，而只是不执行循环体。为了保证最大限度的兼容性，建议在使用 for-in 循环之前，先检测确认该对象的值不是 null 或 undefined。

### 3.6.6 label语句

使用 label 语句可以在代码中添加标签，以便将来使用。

```js
label: statement
```

加标签的语句一般都要与 for 语句等循环语句配合使用。

```js
start: for (var i=0; i < count; i++) {
  alert(i);
}
```

### 3.6.7 break和continue语句

break 和 continue 语句用于在循环中精确地控制代码的执行。其中， break 语句会立即退出循环，强制继续执行循环后面的语句。而 continue 语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。

```js
var num = 0;
for (var i=1; i < 10; i++) {
  if (i % 5 == 0) {
    break;
  }
  num++;
}
alert(num); //4
```

```js
var num = 0;
for (var i=1; i < 10; i++) {
  if (i % 5 == 0) {
    continue;
  }
  num++;
}
alert(num); //8
```

break 和 continue 语句都可以与 label 语句联合使用，从而返回代码中特定的位置。这种联合使用的情况多发生在循环嵌套的情况下。

```js
var num = 0;
outermost:
for (var i=0; i < 10; i++) {
  for (var j=0; j < 10; j++) {
    if (i == 5 && j == 5) {
      break outermost;
    }
    num++; 
  }
}
alert(num); //55
```

```js
var num = 0;
outermost:
for (var i=0; i < 10; i++) {
  for (var j=0; j < 10; j++) {
    if (i == 5 && j == 5) {
      continue outermost;
    }
    num++;
  }
}
alert(num); //95
```

虽然联用 break、 continue 和 label 语句能够执行复杂的操作，但如果使用过度，也会给调试带来麻烦。在此，我们建议如果使用 label 语句，一定要使用描述性的标签，同时不要嵌套过多的循环。

### 3.6.8 with语句

with 语句的作用是将代码的作用域设置到一个特定的对象中。 

```js
with (expression) statement;
```

定义 with 语句的目的主要是为了简化多次编写同一个对象的工作

```js
var qs = location.search.substring(1);
var hostName = location.hostname;
var url = location.href;

// 相当于
with(location){
var qs = search.substring(1);
var hostName = hostname;
var url = href;
}
```

严格模式下不允许使用 with 语句，否则将视为语法错误。由于大量使用 with 语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用 with 语句。

### 3.6.9 switch语句

switch 语句与 if 语句的关系最为密切，而且也是在其他语言中普遍使用的一种流控制语句。ECMAScript 中 switch 语句的语法与其他基于 C 的语言非常接近。

```js
switch (expression) {
  case value: statement
    break;
  case value: statement
    break;
  case value: statement
    break;
  case value: statement
    break;
  default: statement
}
```

通过为每个 case 后面都添加一个 break 语句，就可以避免同时执行多个 case 代码的情况。假如确实需要混合几种情形，不要忘了在代码中添加注释，说明是有意省略了 break 关键字。

虽然 ECMAScript 中的 switch 语句借鉴自其他语言，但这个语句也有自己的特色。首先，可以在 switch 语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有问题。其次，每个 case 的值不一定是常量，可以是变量，甚至是表达式。

```js
switch ("hello world") {
  case "hello" + " world":
    alert("Greeting was found.");
    break;
  case "goodbye":
    alert("Closing was found.");
    break;
  default:
    alert("Unexpected message was found.");
}
```

使用表达式作为 case 值还可以实现下列操作。

```js
var num = 25;
switch (true) {
  case num < 0:
    alert("Less than 0.");
    break;
  case num >= 0 && num <= 10:
    alert("Between 0 and 10.");
    break;
  case num > 10 && num <= 20:
    alert("Between 10 and 20.");
    break;
  default:
   alert("More than 20.");
}
```

switch 语句在比较值时使用的是全等操作符，因此不会发生类型转换。

## 3.7 函数　

函数对任何语言来说都是一个核心的概念。通过函数可以封装任意多条语句，而且可以在任何地方、任何时候调用执行。 ECMAScript 中的函数使用 function 关键字来声明，后跟一组参数以及函数体。

函数可以通过其函数名来调用，后面还要加上一对圆括号和参数（圆括号中的参数如果有多个，可以用逗号隔开）。

```js
function sayHi(name, message) {
  alert("Hello " + name + "," + message);
}

sayHi("Nicholas", "how are you today?");
```

ECMAScript 中的函数在定义时不必指定是否返回值。实际上，任何函数在任何时候都可以通过 return 语句后跟要返回的值来实现返回值。而位于 return 语句之后的任何代码都永远不会执行。

```js
function sum(num1, num2) {
  return num1 + num2;
}
```

当然，一个函数中也可以包含多个 return 语句。

```js
function diff(num1, num2) {
  if (num1 < num2) {
    return num2 - num1;
  } else {
    return num1 - num2;
  }
}
```

另外， return 语句也可以不带有任何返回值。在这种情况下，函数在停止执行后将返回 undefined值。这种用法一般用在需要提前停止函数执行而又不需要返回值的情况下。

推荐的做法是要么让函数始终都返回一个值，要么永远都不要返回值。否则，如果函数有时候返回值，有时候有不返回值，会给调试代码带来不便。

### 3.7.1 理解参数

ECMAScript 中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）。如果这个数组中不包含任何元素，无所谓；如果包含多个元素，也没有问题。实际上，在函数体内可以通过 arguments 对象来
访问这个参数数组，从而获取传递给函数的每一个参数。

其实， arguments 对象只是与数组类似（它并不是 Array 的实例），因为可以使用方括号语法访问它的每一个元素（即第一个元素是 `arguments[0]`，第二个元素是 `argumetns[1]`，以此类推），使用 length 属性来确定传递进来多少个参数。

关于 arguments 的行为，还有一点比较有意思。那就是它的值永远与对应命名参数的值保持同步。不过，这并不是说读取这两个值会访问相同的内存空间；它们的内存空间是独立的，但它们的值会同步。

另外还要记住，如果只传入了一个参数，那么为 `arguments[1]`设置的值不会反应到命名参数中。这是因为 arguments 对象的长度是由传入的参数个数决定的，不是由定义函数时的命名参数的个数决定的。

关于参数还要记住最后一点：没有传递值的命名参数将自动被赋予 undefined 值。这就跟定义了变量但又没有初始化一样。

### 3.7.2 没有重载

ECMAScript 函数不能像传统意义上那样实现重载。而在其他语言（如 Java）中，可以为一个函数编写两个定义，只要这两个定义的签名（接受的参数的类型和数量）不同即可。

如果在 ECMAScript 中定义了两个名字相同的函数，则该名字只属于后定义的函数。

```js
function addSomeNumber(num){
  return num + 100;
}
function addSomeNumber(num) {
  return num + 200;
}
var result = addSomeNumber(100); //300
```

但可以通过检查传入函数中的参数的类型和数量并做出不同的反应，模仿方法的重载。

## 3.8 小结　

JavaScript 的核心语言特性在 ECMA-262 中是以名为 ECMAScript 的伪语言的形式来定义的。ECMAScript 中包含了所有基本的语法、操作符、数据类型以及完成基本的计算任务所必需的对象，但没有对取得输入和产生输出的机制作出规定。理解 ECMAScript 及其纷繁复杂的各种细节，是理解其在Web 浏览器中的实现——JavaScript 的关键。目前大多数实现所遵循的都是 ECMA-262 第 3 版，但很多也已经着手开始实现第 5 版了。以下简要总结了 ECMAScript 中基本的要素。

+ ECMAScript 中的基本数据类型包括 Undefined、 Null、 Boolean、 Number 和 String。
+ 与其他语言不同， ECMScript 没有为整数和浮点数值分别定义不同的数据类型， Number 类型可用于表示所有数值。
+ ECMAScript 中也有一种复杂的数据类型，即 Object 类型，该类型是这门语言中所有对象的基础类型。
+ 严格模式为这门语言中容易出错的地方施加了限制。
+ ECMAScript 提供了很多与 C 及其他类 C 语言中相同的基本操作符，包括算术操作符、布尔操作符、关系操作符、相等操作符及赋值操作符等。
+ ECMAScript 从其他语言中借鉴了很多流控制语句，例如 if 语句、 for 语句和 switch 语句等。

ECMAScript 中的函数与其他语言中的函数有诸多不同之处。

+ 无须指定函数的返回值，因为任何 ECMAScript 函数都可以在任何时候返回任何值。
+ 实际上，未指定返回值的函数返回的是一个特殊的 undefined 值。
+ ECMAScript 中也没有函数签名的概念，因为其函数参数是以一个包含零或多个值的数组的形式传递的。
+ 可以向 ECMAScript 函数传递任意数量的参数，并且可以通过 arguments 对象来访问这些参数。
+ 由于不存在函数签名的特性， ECMAScript 函数不能重载。

# 第4章 变量、作用域和内存问题　

JavaScript 变量松散类型的本质，决定了它只是在特定时间用于保存特定值的一个名字而已。由于不存在定义某个变量必须要保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。

## 4.1 基本类型和引用类型的值

EXMAScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值值那些可能由多个值构成的对象。

五种基本数据类型，Undefined、Null、Boolean、Number 和 String，是按值访问的，因为可以操作保存在变量中的实际的值；引用类型的值是保存在内存中的对象，引用类型的值是按引用访问的，而不是直接访问内存中的位置。

除了保存的方式不同之外，在从一个变量向另一个变量复制基本类型值和引用类型值时，也存在不同。前者是创建新值，后者是创建一个指向储存在堆中的一个对象的指针。

ECMAScript中所有函数的参数都是按值传递的。无论该参数是基本类型值还是引用类型值，引用类型值的传递，则如同引用类型变量的复制一样，将储存在变量对象中的值复制一份放到为新变量分配的空间中，这个值的副本却是一个指针，指向储存在堆中的一个对象，如果在函数体内重写该对象，则是一个局部对象而已。

检查类型，如果只是对象，比如对象或 null，则 typeof 操作符会就能检测出。如果是引用类型对象，则需要使用 instanceof 操作符，正确才返回 true ，错误就返回 false 。

## 4.2 执行环境及作用域　

执行环境，也叫环境，定义了变量或函数有权访问的其他数据，决定它们各自的行为。每个执行环境都有一个与之关联的变量对象。环境中定义的所有变量和函数都保存在这个对象中，不能访问但是解析器会在后台使用。

全局执行环境是最外围的一个执行环境，一般被认为是 window 对象，环境中代码执行完，环境就被销毁，保存在其中的所有变量和函数也随之销毁，因此全局执行环境直到应用程序退出时才会被销毁。

每个函数都有自己的执行环境，当执行流进入一个函数时，函数的执行环境就会被推入一个环境栈中，在该函数执行周后将其弹出，把控制权返回给之前的执行环境。

当代码在一个环境中执行时，会创建变量对象的一个作用域链，保证对执行环境有权访问的所有变量和函数的有序访问。开始只包含arguments对象（这个在全局变量中不存在），下一个变量对象来自包含的外部环境，而下一个变量对象则来自下一个包含环境，延续到全局执行环境。因此全局执行环境的变量始终都是作用域链中的最后一个对象。标识符解析是沿着作用链域一级一级地搜索标识符的过程，先从作用域链的前端开始向后回溯。

延长作用域链。 try-catch 语句的 catch 块和 with 语句，会在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移出。前者是创建一个新的变量对象，其中包含被抛出错误对象的声明。后者是将指定的对象添加到作用域链中。

没有块级作用域。一般的语言都会有块级作用域，用ECMAScript的话来讲就是自己的执行环境，但是JavaScript没有。如果没有使用var声明，该变量会自动被添加到全局环境，使用则var声明则被添加到最接近的环境。在 JavaScript 中， if 语句中的变量声明也会将变量添加到当前的执行环境中，如果在全局中调用 if 语句，则将变量添加到全局环境中。for 语句创建的变量 i 即使在 for 循环执行结束后，也依旧会存在于循环外部的执行环境中。  

查询标识符，当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索作用域链来确定该标识符代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符，找到就停止搜索过程。如果直到全局环境也没有找到，则意味这个变量尚未声明。在JS中所有可以由我们自主命名的都可以称为是标识符，例如：变量名、函数名、属性名都属于标识符。

## 4.3 垃圾收集　

JavaScript具有自动垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存。在编写 JavaScript 程序时，开发人员不用再关心内存使用问题，所需内存的分配以及无用内存的回收完全实现了自动管理。这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变量，然后释放其占用的内存。用于标识无用变量的策略可能会因实现而异，而具体到浏览器中的实现，则通常有两个策略。

- 标记清除（mark-and-sweep）。当变量无论是进入环境时还是离开环境时都会进行相应的标记。垃圾收集器在运行的时候给存储在内存中的所有变量都加上标记 ，然后会去掉环境中的变量以及被环境中的变量所应用的变量的标记，而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

- 引用计数，它跟踪记录每个值被引用的次数，在垃圾收集器下次运行时释放那些引用次数为零的值所占用的内存。但会出现循环引用的问题，两个对象互相引用，引用次数不会是0，就回导致大量内存得不到回收。

垃圾收集器是周期性运行的。需要确定垃圾收集的时间间隔，定期进行回收工作。同时，一般分配给 Web 浏览器的可用内存数量通常比分配给桌面应用程序的少，所以需要确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做解除引用（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用。

## 4.4 小结　

JavaScript 变量可以用来保存两种类型的值：基本类型值和引用类型值。基本类型的值源自以下 5 种基本数据类型： Undefined、 Null、 Boolean、 Number 和 String。基本类型值和引用类型值具有以下特点：

+ 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；
+ 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；
+ 引用类型的值是对象，保存在堆内存中；
+ 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；
+ 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象；
+ 确定一个值是哪种基本类型可以使用 typeof 操作符，而确定一个值是哪种引用类型可以使用 instanceof 操作符。

所有变量（包括基本类型和引用类型）都存在于一个执行环境（也称为作用域）当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几点总结：

+ 执行环境有全局执行环境（也称为全局环境）和函数执行环境之分；
+ 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；
+ 函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全局环境；
+ 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；
+ 变量的执行环境有助于确定应该何时释放内存。

JavaScript 是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。可以对 JavaScript 的垃圾收集例程作如下总结。

+ 离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。
+ “标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。
+ 另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。 JavaScript 引擎目前都不再使用这种算法；但在 IE 中访问非原生 JavaScript 对象（如 DOM 元素）时，这种算法仍然可能会导致问题。
+ 当代码中存在循环引用现象时，“引用计数”算法就会导致问题。
+ 解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。

# 第5章 引用类型　

引用类型的值（对象）是引用类型的一个实例。在 ECMAScript 中，引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称为类，但这种称呼并不妥当。尽管 ECMAScript 从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。

如前所述，对象是某个特定引用类型的实例。新对象是使用 new 操作符后跟一个构造函数来创建的。构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。请看下面这行代码：

```js
var person = new Object();
```

ECMAScript 提供了很多原生引用类型（例如 Object），以便开发人员用以实现常见的计算任务。

## 5.1 Object类型

大多数引用类型值都是 Object 类型的实例；而且， Object 也是ECMAScript 中使用最多的一个类型。虽然 Object 的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。

创建 Object 实例的方式有两种，第一种使用 new 操作符后跟 Object 构造函数。

```js
var person = new Object();
person.name = "Nicholas";
person.age = 29;
```

另一种方式是使用对象字面量表示法。对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。

```js
var person = {
  name : "Nicholas",
  age : 29
};
```

在对象字面量中，使用逗号来分隔不同的属性，因此"Nicholas"后面是一个逗号。但是，在 age 属性的值 29 的后面不能添加逗号，因为 age 是这个对象的最后一个属性。在最后一个属性后面添加逗号，会在 IE7 及更早版本和 Opera 中导致错误。

在使用对象字面量语法时，属性名也可以使用字符串，如下面这个例子所示。

```js
var person = {
  "name" : "Nicholas",
  "age" : 29,
  5 : true
};
```

另外，使用对象字面量语法时，如果留空其花括号，则可以定义只包含默认属性和方法的对象，如下所示：

```js
var person = {}; //与 new Object()相同
person.name = "Nicholas";
person.age = 29;
```

> 在通过对象字面量定义对象时，实际上不会调用 Object 构造函数（Firefox 2 及更早版本会调用 Object 构造函数；但 Firefox 3 之后就不会了）。

虽然可以使用前面介绍的任何一种方法来定义对象，但开发人员更青睐对象字面量语法，因为这种语法要求的代码量少，而且能够给人封装数据的感觉。实际上，对象字面量也是向函数传递大量可选参数的首选方式，例如：

```js
function displayInfo(args) {
  var output = "";
  if (typeof args.name == "string"){
    output += "Name: " + args.name + "\n";
  }
  if (typeof args.age == "number") {
    output += "Age: " + args.age + "\n";
  }
  alert(output);
}

displayInfo({
  name: "Nicholas",
  age: 29
});

displayInfo({
  name: "Greg"
});
```

> 这种传递参数的模式最适合需要向函数传入大量可选参数的情形。一般来讲，命名参数虽然容易处理，但在有多个可选参数的情况下就会显示不够灵活。最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数。

一般来说，访问对象属性时使用的都是点表示法，这也是很多面向对象语言中通用的语法。不过，在 JavaScript 也可以使用方括号表示法来访问对象的属性。在使用方括号语法时，应该将要访问的属性以字符串的形式放在方括号中，如下面的例子所示。

```js
alert(person["name"]); //"Nicholas"
alert(person.name); //"Nicholas"
```

从功能上看，这两种访问对象属性的方法没有任何区别。但方括号语法的主要优点是可以通过变量来访问属性，例如：

```js
var propertyName = "name";
alert(person[propertyName]); //"Nicholas"
```

如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括号表示法。例如：

```js
person["first name"] = "Nicholas";
```

由于"first name"中包含一个空格，所以不能使用点表示法来访问它。然而，属性名中是可以包含非字母非数字的，这时候就可以使用方括号表示法来访问它们。

通常，除非必须使用变量来访问属性，否则我们建议使用点表示法。

## 5.2 Array类型　

虽然 ECMAScript 数组与其他语言中的数组都是数据的有序列表，但与其他语言不同的是， ECMAScript 数组的每一项可以保存任何类型的数据。而且， ECMAScript 数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。

创建数字的基本方式有两种，第一是使用 Array 构造函数，可以保留 new 操作符也可以省略；第二种基本方法是使用数组字面量表示法，数组字面量是由包含数组项的方括号表示，多个数组项之间以逗号隔开。如果在数组字面量的最后一项添加逗号，由于 IE 的实现与其他浏览器不一致，可能导致不同的结果，因此强烈建议不要使用这种语法。

```js
var colors = new Array(3); // 创建一个包含 3 项的数组
var names = new Array("Greg"); // 创建一个包含 1 项，即字符串"Greg"的数组

var colors = Array(3); // 创建一个包含 3 项的数组
var names = Array("Greg"); // 创建一个包含 1 项，即字符串"Greg"的数组

var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
var names = []; // 创建一个空数组
var values = [1,2,]; // 不要这样！这样会创建一个包含 2 或 3 项的数组
var options = [,,,,,]; // 不要这样！这样会创建一个包含 5 或 6 项的数组
```

在读取和设置数组的值时，要使用方括号并提供相应值的基于 0 的的数字索引。方括号中的索引表示要访问的值。如果索引小于数组中的项数，则返回对应项的值。

```js
var colors = ["red", "blue", "green"]; // 定义一个字符串数组
alert(colors[0]); // 显示第一项
colors[2] = "black"; // 修改第三项
colors[3] = "brown"; // 新增第四项
```
设置数组的值也使用相同的语法，但会替换指定位置的值。如果设置某个值的索引超过了数组现有项数，则数组的长度也会相应增加。

数组的项数保存在其 length 属性中，这个属性始终会返回 0 或更大的值。利用 length 属性也可以方便地在数组末尾添加新项。

```js
var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
colors[99] = "black"; // （在位置 99）添加一种颜色
alert(colors.length); // 100
```

数组最多可以包含 4 294 967 295 个项，这几乎已经能够满足任何编程需求了。如果想添加的项数超过这个上限值，就会发生异常。而创建一个初始大小与这个上限值接近的数组，则可能会导致运行时间超长的脚本错误。

### 5.2.1 检查数组

自从 ECMAScript 3 做出规定以后，就出现了确定某个对象是不是数组的经典问题。对于一个网页，或者一个全局作用域而言，使用 `instanceof` 操作符就能得到满意的结果：

```js
if (value instanceof Array){
  //对数组执行某些操作
}
```

instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的 Array 构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。

为了解决这个问题， ECMAScript 5 新增了 `Array.isArray()`方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。这个方法的用法如下。

```js
if (Array.isArray(value)){
  //对数组执行某些操作
}
```

### 5.2.2 转换方法

如前所述，所有对象都具有 `toLocaleString()`、`toString()`和` valueOf()`方法。其中，调用数组的 `toString()`方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而调用 `valueOf()`返回的还是数组。实际上，为了创建这个字符串会调用数组每一项的`toString()`方法。由于 `alert()`要接收字符串参数，所以它会在后台调用 `toString()`方法，由此会得到与直接调用 `toString()`方法相同的结果。

```js
var colors = ["red", "blue", "green"]; // 创建一个包含 3 个字符串的数组
alert(colors.toString()); // red,blue,green
alert(colors.valueOf()); // red,blue,green
alert(colors); // red,blue,green

console.log(colors.toString()); // red,blue,green
console.log(colors.valueOf()); // (3) ["red", "blue", "green"]
console.log(colors); // (3) ["red", "blue", "green"]
```

另外， `toLocaleString()`方法经常也会返回与 `toString()`和 `valueOf()`方法相同的值，但也不总是如此。当调用数组的 `toLocaleString()`方法时，它也会创建一个数组值的以逗号分隔的字符串。而与前两个方法唯一的不同之处在于，这一次为了取得每一项的值，调用的是每一项的 `toLocaleString()`方法，而不是 `toString()`方法。

```js
var person1 = {
  toLocaleString : function () {
    return "Nikolaos";
  },
  toString : function() {
    return "Nicholas";
  }
};
var person2 = {
  toLocaleString : function () {
    return "Grigorios";
  },
  toString : function() {
    return "Greg";
  }
};
var people = [person1, person2];
alert(people); //Nicholas,Greg
alert(people.toString()); //Nicholas,Greg
alert(people.toLocaleString()); //Nikolaos,Grigorios
```

数组继承的 `toLocaleString()`、 `toString()`和 `valueOf()`方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项。而如果使用 `join()`方法，则可以使用不同的分隔符来构建这个字符串。 `join()`方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。

```js
var colors = ["red", "green", "blue"];
alert(colors.join(",")); //red,green,blue
alert(colors.join("||")); //red||green||blue
```

如果数组中的某一项的值是 null 或者 undefined，那么该值在 `join()`、`toLocaleString()`、 `toString()`和 `valueOf()`方法返回的结果中以空字符串表示。

### 5.2.3 栈方法

栈方法有 `push()` 和 `pop()` 方法。栈是一种 LIFO（ Last-In-First-Out，后进先出）的数据结构，也就是最新添加的项最早被移除。

- `push()` 方法可以接受任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度；
- `pop()` 方法则从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。

```js
var colors = new Array(); // 创建一个数组
var count = colors.push("red", "green"); // 推入两项
alert(count); //2
count = colors.push("black"); // 推入另一项
alert(count); //3

var item = colors.pop(); // 取得最后一项
alert(item); //"black"
alert(colors.length); //2
```

### 5.2.4 队列方法

队列方法有 `unshift()` 和 `shift()` 方法。队列数据结构的访问规则是 FIFO（ First-In-First-Out，先进先出）。队列在列表的末端添加项，从列表的前端移除项。

- `unshift()` 方法能在数组的前端添加任意个项并返回新数组的长度。
- `shift()` 方法能够移除数组中的第一个项并返回该项，同时将数组长度减1。

### 5.2.5 重排序方法

数组中已经存在两个可以直接用来重排序的方法： `reverse()`和 `sort()`。

默认情况下， `sort()`方法按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。为了实现排序， `sort()`方法会调用每个数组项的 `toString()`转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值， `sort()`方法比较的也是字符串。

```js
var values = [0, 1, 5, 10, 15];
values.sort();
alert(values); //0,1,10,15,5
```

不用说，这种排序方式在很多情况下都不是最佳方案。因此 `sort()`方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。

```js
function compare(value1, value2) {
  if (value1 < value2) {
    return -1;
  } else if (value1 > value2) {
    return 1;
  } else {
    return 0;
  }
}

var values = [0, 1, 5, 10, 15];
values.sort(compare);
alert(values); //0,1,5,10,15
```

对于数值类型或者其 `valueOf()`方法会返回数值类型的对象类型，可以使用一个更简单的比较函数。这个函数只要用第二个值减第一个值即可。

```JavaScript
// 降序
function compare(value1, value2){
  return value2 - value1;
}
```

### 5.2.6 操作方法

ECMAScript 为操作已经包含在数组中的项提供了很多方法。其中， `concat()`方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 `concat()`方法传递参数的情况下，它只是复制当前数组并返回副本。如果传递给 `concat()`方法的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。

```js
var colors = ["red", "green", "blue"];
var colors2 = colors.concat("yellow", ["black", "brown"]);
alert(colors); //red,green,blue
alert(colors2); //red,green,blue,yellow,black,brown
```

下一个方法是 `slice()`，它能够基于当前数组中的一或多个项创建一个新数组。 `slice()`方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下， `slice()`方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。注意， `slice()`方法不会影响原始数组。

```js
var colors = ["red", "green", "blue", "yellow", "purple"];
var colors2 = colors.slice(1);
var colors3 = colors.slice(1,4);
alert(colors2); //green,blue,yellow,purple
alert(colors3); //green,blue,yellow
```

如果 `slice()`方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。例如，在一个包含 5 项的数组上调用 `slice(-2,-1)`与调用 `slice(3,4)`得到的结果相同。如果结束位置小于起始位置，则返回空数组。

下面我们来介绍 `splice()`方法，这个方法恐怕要算是最强大的数组方法了，它有很多种用法。`splice()`的主要用途是向数组的中部插入项，但使用这种方法的方式则有如下 3 种。

- 删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。

- 插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。

- 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。

`splice()`方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。

```javascript
// slice()
// 删除第一项 
var colors = ["red", "green", "blue"]; 
var removed = colors.splice(0, 1); 
alert(colors); // green,blue 
alert(removed); // red

// splice()
// 从位置 1 开始插入一项 
removed = colors.splice(1, 0, "yellow"); 
alert(colors); // green,yellow,blue 
alert(removed); // []

// splice()
// 插入一项，删除一项
removed = colors.splice(1, 1, "red"); 
alert(colors); // green,red,blue 
alert(removed); // yellow
```

### 5.2.7 位置方法

ECMAScript 5 为数组实例添加了两个位置方法： `indexOf()`和 `lastIndexOf()`。这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， `indexOf()`方法从数组的开头（位置 0）开始向后查找， `lastIndexOf()`方法则从数组的末尾开始向前查找。这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用全等操作符；也就是说，要求查找的项必须严格相等（就像使用===一样）。

```js
var numbers = [1,2,3,4,5,4,3,2,1];
alert(numbers.indexOf(4)); //3
alert(numbers.lastIndexOf(4)); //5
alert(numbers.indexOf(4, 4)); //5
alert(numbers.lastIndexOf(4, 4)); //3

var person = { name: "Nicholas" };
var people = [{ name: "Nicholas" }];
var morePeople = [person];
alert(people.indexOf(person)); //-1
alert(morePeople.indexOf(person)); //0
```

### 5.2.8 迭代方法

ECMAScript 5 为数组定义了 5 个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响 this 的值。传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响方法的返回值。

以下方法都不会修改数组中的包含的值。

- `every()`：遍历运行函数，如果该函数对每一项都返回 true，则返回 true。
- `filter()`：遍历运行函数，返回该函数会返回 true 的项组成的数组。
- `forEach()`：遍历运行函数。这个方法没有返回值。
- `map()`：遍历运行函数，返回每次函数调用的结果组成的数组。
- `some()`：遍历运行函数，如果该函数对任一项返回 true，则返回 true。

在这些方法中，最相似的是 `every()`和 `some()`，它们都用于查询数组中的项是否满足某个条件。

```js
var numbers = [1,2,3,4,5,4,3,2,1];
var everyResult = numbers.every(function(item, index, array){
  return (item > 2);
});
alert(everyResult); //false

var someResult = numbers.some(function(item, index, array){
  return (item > 2);
});
alert(someResult); //true
```

再看一看 `filter()`函数，它利用指定的函数确定是否在返回的数组中包含某一项。

```js
var numbers = [1,2,3,4,5,4,3,2,1];
var filterResult = numbers.filter(function(item, index, array){
return (item > 2);
});
alert(filterResult); //[3,4,5,4,3]
```

`map()`也返回一个数组，而这个数组的每一项都是在原始数组中的对应项上运行传入函数的结果。

```js
var numbers = [1,2,3,4,5,4,3,2,1];
var mapResult = numbers.map(function(item, index, array){
  return item * 2;
});
alert(mapResult); //[2,4,6,8,10,8,6,4,2]
```

最后一个方法是 `forEach()`，它只是对数组中的每一项运行传入的函数。这个方法没有返回值，本质上与使用 for 循环迭代数组一样。

```js
var numbers = [1,2,3,4,5,4,3,2,1];
numbers.forEach(function(item, index, array){
  //执行某些操作
});
```

### 5.2.9 归并方法

ECMAScript 5 还新增了两个归并数组的方法： `reduce()`和 `reduceRight()`。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中， `reduce()`方法从数组的第一项开始，逐个遍历到最后。而 `reduceRight()`则从数组的最后一项开始，向前遍历到第一项。

这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给 `reduce()`和 `reduceRight()`的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。

```js
// 求数组中所有值之和
var values = [1,2,3,4,5];
var sum = values.reduce(function(prev, cur, index, array){
  return prev + cur;
});
alert(sum); //15
```

## 5.3 Date类型 

Date类型使用自UTC国际协调时间，1970年1月1日零时开始经过的毫秒数来保存时间。在使用这种数据存储格式的条件下，Date类型保存的日期能够精确到1970年1月1日之前或之后的285616.

在调用Date构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想获得特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数。

而转化日期毫秒数，有方法 `Date.parse ()` 表示接收一个表示日期的字符串参数，然后返回相应日期的毫秒数，不能表示日期的字符串则会导致返回NaN；方法 Dare.UTC () 同样也返回表示日期的毫秒数，但它的参数分别是年份、基于0的月份、月中的哪一天、小时数、分钟、秒以及毫秒数，只有前面两个参数是必须的，如果省略其它的，月中的天数为1，其它为0.同样的， Date () 也可以传递日期数，从而返回毫秒数，但是这是基于本地时区而不是GMT来创建。`Data.now()`方法，则是返回调用方法时当前时间的毫秒。

## 5.4 RegExp类型 

通过 RegExp 类型来支持正则表达式，其中的模式部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定类、分组、向前查找以及反向引用。

同时，每个增则表达式都可待一或多个标志，用于表明正则表达式的行为，支持以下三个标志：

- g：表示全局（ global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止； 
- i：表示不区分大小写（ case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写； 
- m：表示多行（ multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。  

与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。

除了使用字面量形式来定义正则表达式，另一种创建正则表达式的方式是使用RegExp构造函数，接受两个参数：匹配的字符串模式和可选的标志字符串。

RegExp 的每个实例都具有五个属性，通过这些属性可以取得有关模式的各种信息。

- global：布尔值，表示是否设置了 g 标志。 
- ignoreCase：布尔值，表示是否设置了 i 标志。 
- lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从 0 算起。 
- multiline：布尔值，表示是否设置了 m 标志。 
- source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。  

RegExp 对象的主要方法是 `exec ()` ，该方法是专门为捕获组而设计；第二个方法是 test () ，接受一个字符串阐述。

RegExp构造函数包含一些属性，这些属性分别有一个长属性名和一个短属性名。但 ECMAScript 正则表达式有一些不支持的特性。

## 5.5 Function类型　

函数实际上是对象。每个函数都是 Function 类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。函数通常是使用函数声明语法定义的。这与使用函数表达式定义函数的方式几乎相差无几。另外，还要注意函数末尾有一个分号，就像声明其他变量时一样。

```js
// 函数声明语法
function sum (num1, num2) {
  return num1 + num2;
}

// 函数表达式
var sum = function(num1, num2){
  return num1 + num2;
};
```

最后一种定义函数的方式是使用 Function 构造函数。Function 构造函数可以接收任意数量的参数，但最后一个参数始终都被看成是函数体，而前面的参数则枚举出了新函数的参数。从技术角度讲，这是一个函数表达式。但是，不推荐使用这种方法定义函数，因为这种语法会导致解析两次代码（第一次是解析常规 ECMAScript 代码，第二次是解析传入构造函数中的字符串），从而影响性能。不过，这种语法对于理解“函数是对象，函数名是指针”的概念倒是非常直观的。

```js
var sum = new Function("num1", "num2", "return num1 + num2"); // 不推荐
```

由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。换句话说，一个函数可能会有多个名字。注意，使用不带圆括号的函数名是访问函数指针，而非调用函数。

```js
function sum(num1, num2){
  return num1 + num2;
}
alert(sum(10,10)); //20
var anotherSum = sum;
alert(anotherSum(10,10)); //20
sum = null;
alert(anotherSum(10,10)); //20
```

### 5.1 没有重载（深入理解）

将函数名想象为指针，也有助于理解为什么 ECMAScript 中没有函数重载的概念。

```js
function addSomeNumber(num){
  return num + 100;
}
function addSomeNumber(num) {
  return num + 200;
}
var result = addSomeNumber(100); //300
```

这个例子中声明了两个同名函数，而结果则是后面的函数覆盖了前面的函数。以上代码实际与下面的代码没有什么区别。

```js
var addSomeNumber = function (num){
  return num + 100;
};
addSomeNumber = function (num) {
  return num + 200;
};
var result = addSomeNumber(100); //300
```

### 5.2 函数声明与函数表达式

实际上，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。

```js
alert(sum(10,10));
function sum(num1, num2){
  return num1 + num2;
}
```

因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时， JavaScript 引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面， JavaScript 引擎也能把函数声明提升到顶部。

如果把上面的函数声明改为等价的函数表达式，就会在执行期间导致错误。原因在于函数位于一个初始化语句中，而不是一个函数声明。而且，由于第一行代码就会导致“unexpected identifier”（意外标识符）错误，实际上也不会执行到下一行。

```js
alert(sum(10,10));
var sum = function(num1, num2){
return num1 + num2;
};
```

除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。

### 5.3 作为值的函数

因为 ECMAScript 中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。

```js
function callSomeFunction(someFunction, someArgument){
  return someFunction(someArgument);
}
```

这个函数接受两个参数。第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。然后，就可以像下面的例子一样传递函数了。这里的`callSomeFunction()`函数是通用的，即无论第一个参数中传递进来的是什么函数，它都会返回执行第一个参数后的结果。

```js
function add10(num){
  return num + 10;
}

var result1 = callSomeFunction(add10, 10);
alert(result1); //20

function getGreeting(name){
  return "Hello, " + name;
}
var result2 = callSomeFunction(getGreeting, "Nicholas");
alert(result2); //"Hello, Nicholas"
```

当然，可以从一个函数中返回另一个函数，而且这也是极为有用的一种技术。例如，假设有一个对象数组，我们想要根据某个对象属性对数组进行排序。而传递给数组 `sort()`方法的比较函数要接收两个参数，即要比较的值。可是，我们需要一种方式来指明按照哪个属性来排序。要解决这个问题，可以定义一个函数，它接收一个属性名，然后根据这个属性名来创建一个比较函数，下面就是这个函数的定义。

```js
// 调用 createComparisonFunction("name")方法创建了一个比较函数，
// 以便按照每个对象的 name 属性值进行排序。
function createComparisonFunction(propertyName) {
  return function(object1, object2){
    var value1 = object1[propertyName];
    var value2 = object2[propertyName];
    if (value1 < value2){
      return -1;
    } else if (value1 > value2){
      return 1;
    } else {
      return 0;
    }
  };
}

var data = [{name: "Zachary", age: 28}, {name: "Nicholas", age: 29}];

data.sort(createComparisonFunction("name"));
alert(data[0].name); //Nicholas

data.sort(createComparisonFunction("age"));
alert(data[0].name); //Zachary
```

### 5.4 函数的内部属性

在函数内部，有两个特殊的对象： arguments 和 this。其中， arguments 是一个类数组对象，包含着传入函数中的所有参数。虽然 arguments 的主要用途是保存函数参数，但这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments 对象的函数。请看下面这个非常经典的阶乘函数。使用`arguments.callee`可以让函数与函数名解耦。

```js
function factorial(num){
  if (num <= 1) {
    return 1;
  } else {
    return num * arguments.callee(num-1)
  }
}

var trueFactorial = factorial;

factorial = function(){
  return 0;
};

alert(trueFactorial(5)); //120
alert(factorial(5)); //0
```

函数内部的另一个特殊对象是 this，其行为与 Java 和 C#中的 this 大致类似。换句话说， this 引用的是函数据以执行的环境对象——或者也可以说是 this 值（当在网页的全局作用域中调用函数时，this 对象引用的就是 window）。

```js
window.color = "red";
var o = { color: "blue" };

function sayColor(){
  alert(this.color);
}

sayColor(); //"red"
o.sayColor = sayColor;
o.sayColor(); //"blue"
```

> 函数的名字仅仅是一个包含指针的变量而已。因此，即使是在不同的环境中执行，全局的 `sayColor()`函数与 `o.sayColor()`指向的仍然是同一个函数。

ECMAScript 5 也规范化了另一个函数对象的属性： caller。这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为 null。为了实现更松散的耦合，也可以通过 `arguments.callee.caller`来访问相同的信息。

```js
function outer(){
  inner();
}

function inner(){
  // alert(inner.caller);
  // 相当于
  alert(arguments.callee.caller);
}

outer();
```

当函数在严格模式下运行时，访问 `arguments.callee` 会导致错误。 ECMAScript 5 还定义了`arguments.caller` 属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是undefined。定义这个属性是为了分清 `arguments.caller` 和函数的 `caller` 属性。以上变化都是为了加强这门语言的安全性，这样第三方代码就不能在相同的环境里窥视其他代码了。严格模式还有一个限制：不能为函数的 caller 属性赋值，否则会导致错误。

### 5.5.5 函数属性和方法

函数是对象，因此函数也有属性和方法，每个函数都有 length 和 prototype 两个属性。 length 表示函数希望接收的命名函数的个数， prototype 是保存所有实例方法的真正所在，诸如 `toString ()` 和 `valueOf ()` 等方法都保存在 prototype 名下，不过只是通过各自对象的实例访问。在创建自定义引用类型以及实现继承时， prototype 属性的作用是极为重要的。在 ECMAScript 5 中， prototype 属性是不可枚举的，因此使用 for-in 无法发现。

```js
function sayName(name){
  alert(name);
}
function sum(num1, num2){
  return num1 + num2;
}
function sayHi(){
  alert("hi");
}
alert(sayName.length); //1
alert(sum.length); //2
alert(sayHi.length); //0
```

每个函数一般还包含连个非继承而来的方法： `apply ()` 和 `call ()` ，这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。首先 `apply ()` 方法接收两个参数：第一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是 Array 的实例，也可以是 arguments 对象。

```js
function sum(num1, num2){
  return num1 + num2;
}
function callSum1(num1, num2){
  return sum.apply(this, arguments); // 传入 arguments 对象
}
function callSum2(num1, num2){
  return sum.apply(this, [num1, num2]); // 传入数组
}
alert(callSum1(10,10)); //20
alert(callSum2(10,10)); //20
```

`call()`方法与 `apply()`方法的作用相同，它们的区别仅在于接收参数的方式不同。对于 `call()`方法而言，第一个参数是 this 值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用`call()`方法时，传递给函数的参数必须逐个列举出来。

```js
function sum(num1, num2){
  return num1 + num2;
}
function callSum(num1, num2){
  return sum.call(this, num1, num2);
}
alert(callSum(10,10)); //20
```

事实上，传递参数并非 `apply()`和 `call()`真正的用武之地；它们真正强大的地方是能够扩充函数赖以运行的作用域。使用 `call()`（或 `apply()`）来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。

```js
window.color = "red";
var o = { color: "blue" };
function sayColor(){
  alert(this.color);
}
sayColor(); //red
sayColor.call(this); //red
sayColor.call(window); //red
sayColor.call(o); //blue
```

ECMAScript 5 还定义了一个方法： `bind()`。这个方法会创建一个函数的实例，其 this 值会被绑定到传给`bind()`函数的值。

```javascript
window.color = "red";
var o = { color: "blue" };
function sayColor(){ 
  alert(this.color ); 
}
var objectSayColor = sayColor.bind(o);
objectSayColor(); //blue
```

每个函数继承的 `toLocaleString()`和 `toString()`方法始终都返回函数的代码。返回代码的格式则因浏览器而异——有的返回的代码与源代码中的函数代码一样，而有的则返回函数代码的内部表示，即由解析器删除了注释并对某些代码作了改动后的代码。由于存在这些差异，我们无法根据这两个方法返回的结果来实现任何重要功能；不过，这些信息在调试代码时倒是很有用。另外一个继承的`valueOf()`方法同样也只返回函数代码。

## 5.6 基本包装类型

为了便于操作基本类型值，ECMAScript还提供了三个特殊的引用类型： Boolean 、 Number 和 String ，这些类型与其他应用类型相似，但同时也具有各自的基本类型相应的特殊行为。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。

```js
var s1 = "some text";
var s2 = s1.substring(2);
```

在读取模式中访问字符串时，后台都会自动完成下列处理。这也分别适用于 Boolean 和 Number 类型对应的布尔值和数字值。

1. 创建 String 类型的一个实例；
2. 在实例上调用指定的方法；
3. 销毁这个实例。

```js
var s1 = new String("some text");
var s2 = s1.substring(2);
s1 = null;
```

引用类型与基本包装类型的主要区别就是对象的生存期。使用 new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。

```js
var s1 = "some text";
s1.color = "red";
alert(s1.color); //undefined
```

当然，可以显式地调用 Boolean、 Number 和 String 来创建基本包装类型的对象。不过，应该在绝对必要的情况下再这样做，因为这种做法很容易让人分不清自己是在处理基本类型还是引用类型的值。对基本包装类型的实例调用 typeof 会返回"object"，而且所有基本包装类型的对象都会被转换为布尔值 true。

Object 构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。

```js
var obj = new Object("some text");
alert(obj instanceof String); //true
```

要注意的是，使用 new 调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。

```js
var value = "25";
var number = Number(value); //转型函数
alert(typeof number); //"number"
var obj = new Number(value); //构造函数
alert(typeof obj); //"object"
```

尽管我们不建议显式地创建基本包装类型的对象，但它们操作基本类型值的能力还是相当重要的。而每个基本包装类型都提供了操作相应值的便捷方法。

### 5.6.1 Boolean类型

Boolean 类型是与布尔值对应的引用类型。要创建 Boolean 对象，可以像下面这样调用 Boolean 构造函数并传入 true 或 false 值。

```js
var booleanObject = new Boolean(true);
```

Boolean 类型的实例重写了 `valueOf()`方法，返回基本类型值 true 或 false；重写了 `toString()` 方法，返回字符串"true"和"false"。可是， Boolean 对象在 ECMAScript 中的用处不大，因为它经常会造成人们的误解。其中最常见的问题就是在布尔表达式中使用 Boolean 对象。

```js
var falseObject = new Boolean(false);

var result = falseObject && true;
alert(result); //true

var falseValue = false;
result = falseValue && true;
alert(result); //false
```

基本类型与引用类型的布尔值还有两个区别。首先， typeof 操作符对基本类型返回"boolean"，而对引用类型返回"object"。其次，由于 Boolean 对象是 Boolean 类型的实例，所以使用 instanceof 操作符测试 Boolean 对象会返回 true，而测试基本类型的布尔值则返回 false。

```js
alert(typeof falseObject); //object
alert(typeof falseValue); //boolean
alert(falseObject instanceof Boolean); //true
alert(falseValue instanceof Boolean); //false
```

### 5.6.2 Number类型

Number 是与数字值对应的引用类型。要创建 Number 对象，可以在调用 Number 构造函数时向其中传递相应的数值。

```js
var numberObject = new Number(10);
```

与 Boolean 类型一样， Number 类型也重写了 `valueOf()`、 `toLocaleString()`和` toString()` 方法。重写后的 `valueOf()`方法返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的数值。

```js
var num = 10;
alert(num.toString()); //"10"
alert(num.toString(2)); //"1010"
alert(num.toString(8)); //"12"
alert(num.toString(10)); //"10"
alert(num.toString(16)); //"a"
```

除了继承的方法之外， Number 类型还提供了一些用于将数值格式化为字符串的方法。其中， `toFixed()`方法会按照指定的小数位返回数值的字符串表示。如果数值本身包含的小数位比指定的还多，那么接近指定的最大小数位的值就会舍入。其中的舍入是银行家舍入:所谓银行家舍入法，其实质是一种四舍六入五取偶（又称四舍六入五留双）法。

```js
var num = 10;
alert(num.toFixed(2)); //"10.00"

var num = 10.005;
alert(num.toFixed(2)); //"10.01"
```

另外可用于格式化数值的方法是 `toExponential()`，该方法返回以指数表示法（也称 e 表示法）表示的数值的字符串形式。与 `toFixed()`一样， `toExponential()`也接收一个参数，而且该参数同样也是指定输出结果中的小数位数。

```js
var num = 10;
alert(num.toExponential(1)); //"1.0e+1"
```

对于一个数值来说， toPrecision()方法可能会返回固定大小（fixed）格式，也可能返回指数（exponential）格式；具体规则是看哪种格式最合适。这个方法接收一个参数，即表示数值的所有数字的位数（不包括指数部分）。

```js
var num = 99;
alert(num.toPrecision(1)); //"1e+2"
alert(num.toPrecision(2)); //"99"
alert(num.toPrecision(3)); //"99.0"
```

与 Boolean 对象类似， Number 对象也以后台方式为数值提供了重要的功能。但与此同时，我们仍然不建议直接实例化 Number 类型，而原因与显式创建 Boolean 对象一样。具体来讲，就是在使用typeof 和 instanceof 操作符测试基本类型数值与引用类型数值时，得到的结果完全不同。

```javascript
var numberObject = new Number(10);
var numberValue = 10;
alert(typeof numberObject); //"object"
alert(typeof numberValue); //"number"
alert(numberObject instanceof Number); //true
alert(numberValue instanceof Number); //false
```

### 5.6.3 String类型

String 类型是字符串的对象包装类型，可以像下面这样使用 String 构造函数来创建。

```js
var stringObject = new String("hello world");
```

String 对象的方法也可以在所有基本的字符串值中访问到。其中，继承的 `valueOf()`、`toLocaleString()`和 `toString()`方法，都返回对象所表示的基本字符串值。

String 类型的每个实例都有一个 length 属性，表示字符串中包含多个字符。

```js
var stringValue = "hello world";
alert(stringValue.length); //"11"
```

String 类型提供了很多方法，用于辅助完成对 ECMAScript 中字符串的解析和操作。

#### 5.6.3.1 字符方法

两个用于访问字符串中特定字符的方法是： `charAt()`和 `charCodeAt()`。这两个方法都接收一个参数，即基于 0 的字符位置。其中， `charAt()`方法以单字符字符串的形式返回给定位置的那个字符（ECMAScript 中没有字符类型），`charCodeAt()`返回字符编码。

```js
var stringValue = "hello world";
alert(stringValue.charAt(1)); //"e"

alert(stringValue.charCodeAt(1)); //输出"101"
```

ECMAScript 5 还定义了另一个访问个别字符的方法。在支持此方法的浏览器中，可以使用方括号加数字索引来访问字符串中的特定字符

```js
var stringValue = "hello world";
alert(stringValue[1]); //"e"
```

#### 5.6.3.2 字符串操作方法

第一个就是 `concat()`，用于将一或多个字符串拼接起来，返回拼接得到的新字符串。实际上， `concat()`方法可以接受任意多个参数，也就是说可以通过它拼接任意多个字符串。

```js
var stringValue = "hello ";
var result = stringValue.concat("world", "!");
alert(result); //"hello world!"
alert(stringValue); //"hello"
```

虽然 `concat()`是专门用来拼接字符串的方法，但实践中使用更多的还是加号操作符（+）。而且，使用加号操作符在大多数情况下都比使用 `concat()`方法要简便易行（特别是在拼接多个字符串的情况下）。

ECMAScript还提供了三个基于子字符串创建新字符串的方法： `slice()`、 `substr()`和 `substring()`。这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字符串的开始位置，第二个参数（在指定的情况下）表示子字符串到哪里结束。   
具体来说， `slice()`和`substring()`的第二个参数指定的是子字符串最后一个字符后面的位置。而 `substr()`的第二个参数指定的则是返回的字符个数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。 

```js
var stringValue = "hello world";

alert(stringValue.slice(3)); //"lo world"
alert(stringValue.substring(3)); //"lo world"
alert(stringValue.substr(3)); //"lo world"

alert(stringValue.slice(3, 7)); //"lo w"
alert(stringValue.substring(3,7)); //"lo w"
alert(stringValue.substr(3, 7)); //"lo worl"
```

与`concat()`方法一样， `slice()`、 `substr()`和 `substring()`也不会修改字符串本身的值——它们只是返回一个基本类型的字符串值，对原始字符串没有任何影响。

在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。其中， `slice()`方法会将传入的负值与字符串的长度相加， `substr()`方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为 0。最后， `substring()`方法会把所有负值参数都转换为 0。

```js
// stringValue.length: 11
var stringValue = "hello world";

alert(stringValue.slice(-3)); //"rld" 
alert(stringValue.substring(-3)); //"hello world"
alert(stringValue.substr(-3)); //"rld"

alert(stringValue.slice(3, -4)); //"lo w"
alert(stringValue.substring(3, -4)); //"hel"
alert(stringValue.substr(3, -4)); //""（空字符串）
```

- 字符串位置方法。有两个可以从字符串中查找子字符串的方法： indexOf () 和 lastIndexOf () 。这两个方法都是从一个字符串中搜索给定的字符串，然后返回子字符串的位置，没有找到则返回 -1 。区别在于，前者从字符串的开头向后搜索子字符串  ，后者从字符串的末尾向前搜索子字符串。

#### 5.6.3.3 字符串位置方法

有两个可以从字符串中查找子字符串的方法： indexOf()和 lastIndexOf()。这两个方法都是从一个字符串中搜索给定的子字符串，然后返子字符串的位置（如果没有找到该子字符串，则返回-1）。这两个方法的区别在于： indexOf()方法从字符串的开头向后搜索子字符串，而 lastIndexOf()方法是从字符串的末尾向前搜索子字符串。

```js
var stringValue = "hello world";
alert(stringValue.indexOf("o")); //4
alert(stringValue.lastIndexOf("o")); //7
```

这两个方法都可以接收可选的第二个参数，表示从字符串中的哪个位置开始搜索。换句话说，indexOf()会从该参数指定的位置向后搜索，忽略该位置之前的所有字符；而 lastIndexOf()则会从指定的位置向前搜索，忽略该位置之后的所有字符。

```js
var stringValue = "hello world";
alert(stringValue.indexOf("o", 6)); //7
alert(stringValue.lastIndexOf("o", 6)); //4
```

在使用第二个参数的情况下，可以通过循环调用 indexOf()或 lastIndexOf()来找到所有匹配的子字符串。

```js
var stringValue = "Lorem ipsum dolor sit amet, consectetur adipisicing elit";
var positions = new Array();
var pos = stringValue.indexOf("e");
while(pos > -1){
  positions.push(pos);
  pos = stringValue.indexOf("e", pos + 1);
}
alert(positions); //"3,24,32,35,52"
```

#### 5.6.3.4 trim()方法

ECMAScript 5 为所有字符串定义了 `trim()`方法。这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。

```js
var stringValue = " hello world ";
var trimmedStringValue = stringValue.trim();
alert(stringValue); //" hello world "
alert(trimmedStringValue); //"hello world"
```

由于 `trim()`返回的是字符串的副本，所以原始字符串中的前置及后缀空格会保持不变。

#### 5.6.3.5 字符串大小写转换方法

CMAScript 中涉及字符串大小写转换的方法有 4 个： `toLowerCase()`、 `toLocaleLowerCase()`、 `toUpperCase()`和 `toLocaleUpperCase()`。其中， `toLowerCase()`和 `toUpperCase()`是两个经典的方法，借鉴自 java.lang.String 中的同名方法。而 `toLocaleLowerCase()`和 `toLocaleUpperCase()`方法则是针对特定地区的实现。对有些地区来说，针对地区的方法与其通用方法得到的结果相同，但少数语言（如土耳其语）会为 Unicode 大小写转换应用特殊的规则，这时候就必须使用针对地区的方法来保证实现正确的转换。

```js
var stringValue = "hello world";
alert(stringValue.toLocaleUpperCase()); //"HELLO WORLD"
alert(stringValue.toUpperCase()); //"HELLO WORLD"
alert(stringValue.toLocaleLowerCase()); //"hello world"
alert(stringValue.toLowerCase()); //"hello world"
```

#### 5.6.3.6 字符串的模式匹配方法

String 类型定义了几个用于在字符串中匹配模式的方法。第一个方法就是 `match()`，在字符串上调用这个方法，本质上与调用 RegExp 的 `exec()`方法相同。 `match()`方法只接受一个参数，要么是一个正则表达式，要么是一个 RegExp 对象。

```js
var text = "cat, bat, sat, fat";
var pattern = /.at/;
//与 pattern.exec(text)相同
var matches = text.match(pattern);
alert(matches.index); //0
alert(matches[0]); //"cat"
alert(pattern.lastIndex); //0
```

另一个用于查找模式的方法是 `search()`。这个方法的唯一参数与 `match()`方法的参数相同：由字符串或 RegExp 对象指定的一个正则表达式。 `search()`方法返回字符串中第一个匹配项的索引；如果没有找到匹配项，则返回-1。而且， `search()`方法始终是从字符串开头向后查找模式。

```js
var text = "cat, bat, sat, fat";
var pos = text.search(/at/);
alert(pos); //1
```

为了简化替换子字符串的操作， ECMAScript 提供了 `replace()`方法。这个方法接受两个参数：第一个参数可以是一个 RegExp 对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局（g）标志。

```js
var text = "cat, bat, sat, fat";
var result = text.replace("at", "ond");
alert(result); //"cond, bat, sat, fat"
result = text.replace(/at/g, "ond");
alert(result); //"cond, bond, sond, fond"
```

`replace()`方法的第二个参数也可以是一个函数。在只有一个匹配项（即与模式匹配的字符串）的情况下，会向这个函数传递 3 个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项……，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始字符串。这个函数应该返回一个字符串，表示应该被替换的匹配项使用函数作为 `replace()`方法的第二个参数可以实现更加精细的替换操作。

```js
function htmlEscape(text){
  return text.replace(/[<>"&]/g, function(match, pos, originalText){
    switch(match){
      case "<":
      return "&lt;";
      case ">":
      return "&gt;";
      case "&":
      return "&amp;";
      case "\"":
      return "&quot;";
    }
  });
}
alert(htmlEscape("<p class=\"greeting\">Hello world!</p>"));
//&lt;p class=&quot;greeting&quot;&gt;Hello world!&lt;/p&gt;
```

最后一个与模式匹配有关的方法是 `split()`，这个方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个 RegExp 对象（这个方法不会将字符串看成正则表达式）。 `split()`方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。

```js
var colorText = "red,blue,green,yellow";
var colors1 = colorText.split(","); //["red", "blue", "green", "yellow"]
var colors2 = colorText.split(",", 2); //["red", "blue"]
var colors3 = colorText.split(/[^\,]+/); //["", ",", ",", ",", ""]
```

#### 5.6.3.7 localeCompare()方法

与操作字符串有关的最后一个方法是 `localeCompare()`，这个方法比较两个字符串，并返回下列值中的一个：
- 如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1，具体的值要视实现而定）；
- 如果字符串等于字符串参数，则返回 0；
- 如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是 1，具体的值同样要视实现而定）。

#### 5.6.3.8 fromCharCode()方法  

另外， String 构造函数本身还有一个静态方法： `fromCharCode()`。这个方法的任务是接收一或多个字符编码，然后将它们转换成一个字符串。从本质上来看，这个方法与实例方法 `charCodeAt()`执行的是相反的操作。

```js
alert(String.fromCharCode(104, 101, 108, 108, 111)); //"hello"
```

#### 5.6.3.9 HTML()方法  

早期的 Web 浏览器提供商觉察到了使用 JavaScript 动态格式化 HTML 的需求。于是，这些提供商就扩展了标准，实现了一些专门用于简化常见 HTML 格式化任务的方法。不过，需要请读者注意的是，应该尽量不使用这些方法，因为它们创建的标记通常无法表达语义。

## 5.7 单体内置对象　

内置对象是不依赖于宿主环境的对象，除了Object、Array和String这几个内置对象，还有两个单体内置对象：Global和Math。

Global全局对象是最特别的一个对象。不属于任何对象的属性和方法，最终都是它的属性和方法，没有全局变量或全局函数，所有在全局作用域中定义的属性和函数，都是Global对象的属性。Global 对象的 encodeURI () 和  encodeURIComponent () 方法可以对 URI（ Uniform Resource Identifiers ，通用资源标识符）进行编码，以便发送给浏览器。  URL编码方法： encodeURI () 和 encodeURIComponent () 方法可以对URI进行编码，以便发送给浏览器。解码则是 decodeURI () 和 dencodeURIcomponent () 。

eval () 方法就像是一个完整的 ECMAScript 解析器，它只接受一个参数，即要执行的 ECMAScript 字符串。在严格模式下，在外部访问不到 eval () 中创建的任何变量或函数，但是一般在 eval () 创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；它们只在eval()执行的时候创建。虽然没有指出如何直接访问Global对象，但Web浏览器都是将这个全局对象作为window对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了window对象的属性。

ECMAScript还为保存数学公式和信息提供了一个公共位置，即Math对象。 min () 和 max () 方法用于确定一组数值中的最小值和最大值，这两个方法都可以接收任意多个数值参数。将小数值舍入为整数的几个方法： Math.ceil () 、 Math.floor () 和 Math.round() ，第一个执行向上舍入，第二个向下舍入，第三个四舍五入。 random () 方法返回大于等于0小于1的一个随机数。

## 5.8 小结　

对象在 JavaScript 中被称为引用类型的值，而且有一些内置的引用类型可以用来创建特定的对象，现简要总结如下：
+ 引用类型与传统面向对象程序设计中的类相似，但实现不同；
+ Object 是一个基础类型，其他所有类型都从 Object 继承了基本的行为；
+ Array 类型是一组值的有序列表，同时还提供了操作和转换这些值的功能；
+ Date 类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能；
+ RegExp 类型是 ECMAScript 支持正则表达式的一个接口，提供了最基本的和一些高级的正则表达式功能。

函数实际上是 Function 类型的实例，因此函数也是对象；而这一点正是 JavaScript 最有特色的地方。由于函数是对象，所以函数也拥有方法，可以用来增强其行为。

因为有了基本包装类型，所以 JavaScript 中的基本类型值可以被当作对象来访问。三种基本包装类型分别是： Boolean、 Number 和 String。以下是它们共同的特征：

+ 每个包装类型都映射到同名的基本类型；
+ 在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据操作；
+ 操作基本类型值的语句一经执行完毕，就会立即销毁新创建的包装对象。

在所有代码执行之前，作用域中就已经存在两个内置对象： Global 和 Math。在大多数 ECMAScript 实现中都不能直接访问 Global 对象；不过， Web 浏览器实现了承担该角色的 window 对象。全局变量和函数都是 Global 对象的属性。 Math 对象提供了很多属性和方法，用于辅助完成复杂的数学计算任务

# 第6章 面向对象的程序设计　

面向对象（Object-Oriented， OO）的语言有一个标志，那就是他们都有类的概念，而通过类可以创建任意多个具有相同属性和方法的对象。ECMAScript 中没有类的概念，因此它的对象也与基于类的语言中的对象有所不同。

ECMA-262 把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。正因为这样（以及其他将要讨论的原因），我们可以把 ECMAScript 的对象想象成散列表：无非就是一组名值对，其中值可以是数据或函数。

每个对象都是基于一个引用类型创建的，这个引用类型可以是第 5 章讨论的原生类型，也可以是开发人员定义的类型。

## 6.1 理解对象 

创建自定义对象的最简单方式就是创建一个 Object 的实例，然后再为它添加属性和方法。

```js
var person = new Object();
person.name = "Nicholas";
person.age = 29;
person.job = "Software Engineer";

person.sayName = function(){
  alert(this.name);
};
```

早期的 JavaScript 开发人员经常使用这个模式创建新对象。几年后，对象字面量成为创建这种对象的首选模式。前面的例子用对象字面量语法可以写成这样：

```js
var person = {
  name: "Nicholas",
  age: 29,
  job: "Software Engineer",
  sayName: function(){
    alert(this.name);
}
};
```

这些属性在创建时都带有一些特征值（characteristic）， JavaScript 通过这些特征值来定义它们的行为。

### 6.1.1 属性类型

ECMA-262 第 5 版在定义只有内部才用的特性（attribute）时，描述了属性（property）的各种特征。ECMA-262 定义这些特性是为了实现 JavaScript 引擎用的，因此在 JavaScript 中不能直接访问它们。为了表示特性是内部值，该规范把它们放在了两对儿方括号中，例如`[[Enumerable]]`。

ECMAScript 中有两种属性：数据属性和访问器属性。

**1.数据属性**

数据属性包含一个数据值的位置，在这个位置可以读取和写入值。数据属性有4个描述其行为的特性：

1. `[[Configurable]]`：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。
2. `[[Enumerable]]`：表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。
3. `[[Writable]]`：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为 true。
4. `[[Value]]`：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为 undefined。

对于像前面例子中那样直接在对象上定义的属性，它们的`[[Configurable]]`、 `[[Enumerable]]`和`[[Writable]]`特性都被设置为 true，而`[[Value]]`特性被设置为指定的值。例如：

```js
var person = {
  name: "Nicholas"
};
```

这里创建了一个名为 name 的属性，为它指定的值是"Nicholas"。也就是说， `[[Value]]`特性将被设置为"Nicholas"，而对这个值的任何修改都将反映在这个位置。

要修改属性默认的特性，必须使用 ECMAScript 5 的 `Object.defineProperty ()` 方法，该方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属性必须是： configurable、 enumerable、 writable 和 value。设置其中的一或多个值，可以修改对应的特性值。

```js
var person = {};
Object.defineProperty(person, "name", {
  writable: false,
  value: "Nicholas"
});

alert(person.name); //"Nicholas"
person.name = "Greg";
alert(person.name); //"Nicholas"
```

这个例子创建了一个名为 name 的属性，它的值"Nicholas"是只读的。这个属性的值是不可修改的，如果尝试为它指定新值，则在非严格模式下，赋值操作将被忽略；在严格模式下，赋值操作将会导致抛出错误。

类似的规则也适用于不可配置的属性。例如：

```js
var person = {};
Object.defineProperty(person, "name", {
  configurable: false,
  value: "Nicholas"
});
alert(person.name); //"Nicholas"
delete person.name;
alert(person.name); //"Nicholas"
```

把 configurable 设置为 false，表示不能从对象中删除属性。如果对这个属性调用 delete，则在非严格模式下什么也不会发生，而在严格模式下会导致错误。而且，一旦把属性定义为不可配置的，就不能再把它变回可配置了。此时，再调用 `Object.defineProperty()`方法修改除 writable 之外的特性，都会导致错误：

```js
var person = {};
Object.defineProperty(person, "name", {
  configurable: false,
  value: "Nicholas"
});
//抛出错误
Object.defineProperty(person, "name", {
  configurable: true,
  value: "Nicholas"
});
```

也就是说，可以多次调用 `Object.defineProperty ()` 方法修改同一个属性，但在把 `[[configurable]]` 特性设置为 false 之后就会有限制了。

在调用 `Object.defineProperty()`方法时，如果不指定， `[[configurable]]`、 `[[enumerable]]` 和`[[writable]]` 特性的默认值都是 false。多数情况下，可能都没有必要利用 `Object.defineProperty()`方法提供的这些高级功能。不过，理解这些概念对理解 JavaScript 对象却非常有用。

> IE8 是第一个实现 `Object.defineProperty()`方法的浏览器版本。然而，这个版本的实现存在诸多限制：只能在 DOM 对象上使用这个方法，而且只能创建访问器属性。由于实现不彻底，建议读者不要在 IE8 中使用 `Object.defineProperty()`方法。

**2.访问器属性**

访问器属性不包含数据值：它们包含一对儿 getter 和 setter 函数，不过他们都不是必需的。在读取访问器属性时，会调用 getter 函数，这个函数负责返回有效的值；在写入访问器属性时，会调用 setter 函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下 4 个特性。

1. `[[Configurable]]`：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为 true。
2. `[[Enumerable]]`：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这个特性的默认值为 true。
3. `[[Get]]`：在读取属性时调用的函数。默认值为 undefined。
4. `[[Set]]`：在写入属性时调用的函数。默认值为 undefine

访问器属性不能直接定义，必须使用 `Object.defineProperty()` 来定义。

```js
var book = {
  _year: 2004,
  edition: 1
};
Object.defineProperty(book, "year", {
  get: function(){
    return this._year;
  },
  set: function(newValue){
    if (newValue > 2004) {
      this._year = newValue;
      this.edition += newValue - 2004;
    }
  }
});
book.year = 2005;
alert(book.edition); //2
```

这是使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化。

不一定非要同时指定 getter 和 setter。只指定 getter 意味着属性是不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了 getter 函数的属性会抛出错误。类似地，只指定 setter 函数的属性也不能读，否则在非严格模式下会返回 undefined，而在严格模式下会抛出错误。

支持 ECMAScript 5 的这个方法的浏览器有 IE9+（IE8 只是部分实现）、 Firefox 4+、 Safari 5+、 Opera 12+ 和 Chrome 。在这个方法之前，要创建访问器属性，一般都使用两个非标准的方法 ：`__defineGetter__()`和`__defineSetter__()`。这两个方法最初是由 Firefox 引入的，后来 Safari 3、 Chrome 1 和 Opera 9.5 也给出了相同的实现。使用这两个遗留的方法，可以像下面这样重写前面的例子。

```js
var book = {
  _year: 2004,
  edition: 1
};

//定义访问器的旧有方法
book.__defineGetter__("year", function(){
  return this._year;
});
book.__defineSetter__("year", function(newValue){
  if (newValue > 2004) {
    this._year = newValue;
    this.edition += newValue - 2004;
  }
});

book.year = 2005;
alert(book.edition); //2
```

在不支持`Object.defineProperty()`方法的浏览器中不能修改`[[Configurable]]`和`[[Enumerable]]`。

### 6.1.2 定义多个属性

由于为对象定义多个属性的可能性很大， ECMAScript 5 又定义了一个`Object.defineProperties()`方法。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。

```js
var book = {};
Object.defineProperties(book, {
  _year: {
    value: 2004
  },
  edition: {
    value: 1
  },
  year: {
    get: function(){
      return this._year;
    },
    set: function(newValue){
      if (newValue > 2004) {
        this._year = newValue;
        this.edition += newValue - 2004;
      }
    }
  }
});
```

以上代码在 book 对象上定义了两个数据属性（_year 和 edition）和一个访问器属性（year）。最终的对象与上一节中定义的对象相同。唯一的区别是这里的属性都是在同一时间创建的。

### 6.1.3 读取属性的特性

使用 ECMAScript 5 的 `Object.getOwnPropertyDescriptor()`方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有 configurable、 enumerable、 get 和 set；如果是数据属性，这个对象的属性有 configurable、 enumerable、 writable 和 value。

```js
var book = {};
Object.defineProperties(book, {
  _year: {
    value: 2004
  },
  edition: {
    value: 1
  },
  year: {
    get: function(){
      return this._year;
    },
    set: function(newValue){
      if (newValue > 2004) {
        this._year = newValue;
        this.edition += newValue - 2004;
      }
    }
  }
});
var descriptor = Object.getOwnPropertyDescriptor(book, "_year");
alert(descriptor.value); //2004
alert(descriptor.configurable); //false
alert(typeof descriptor.get); //"undefined"

var descriptor = Object.getOwnPropertyDescriptor(book, "year");
alert(descriptor.value); //undefined
alert(descriptor.enumerable); //false
alert(typeof descriptor.get); //"function"
```

## 6.2 创建对象

虽然 Object 构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，人们开始使用工厂模式的一种变体。

### 6.2.1 工厂模式

工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。考虑到在 ECMAScript 中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节，如下面的例子所示。

```js
function createPerson(name, age, job){
  var o = new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function(){
    alert(this.name);
  };    
  return o;
}

var person1 = createPerson("Nicholas", 29, "Software Engineer");
var person2 = createPerson("Greg", 27, "Doctor");
```

函数`createPerson()`能够根据接受的参数来构建一个包含所有必要信息的 Person 对象。可以无数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。随着 JavaScript 的发展，又一个新模式出现了。

### 6.2.2 构造函数模式

ECMAScript 中的构造函数可用来创建特定类型的对象。像 Object 和 Array 这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。例如，可以使用构造函数模式将前面的例子重写如下。

```js
function Person(name, age, job){
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function(){
    alert(this.name);
  };
}
var person1 = new Person("Nicholas", 29, "Software Engineer");
var person2 = new Person("Greg", 27, "Doctor");
```

在这个例子中，`Person()`函数取代了 `createPerson()`函数。我们注意到，` Person()`中的代码除了与 `createPerson()`中相同的部分外，还存在以下不同之处：

- 没有显式地创建对象；
- 直接将属性和方法赋给了 this 对象；
- 没有 return 语句。

此外，还应该注意到函数名 Person 使用的是大写字母 P。按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其他 OO 语言，主要是为了区别于 ECMAScript 中的其他函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。

要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下 4 个步骤：

1. 创建一个新对象；
2. 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；
3. 执行构造函数中的代码（为这个新对象添加属性）；
4. 返回新对象。

在前面例子的最后， person1 和 person2 分别保存着 Person 的一个不同的实例。这两个对象都有一个 `constructor`（构造函数）属性，该属性指向 Person 。对象的 `constructor` 属性最初是用来标识对象类型的。但是，提到检测对象类型，还是 instanceof 操作符要更可靠一些。

```js
alert(person1.constructor == Person); //true
alert(person2.constructor == Person); //true

alert(person1 instanceof Object); //true
alert(person1 instanceof Person); //true
alert(person2 instanceof Object); //true
alert(person2 instanceof Person); //true
```

创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式胜过工厂模式的地方。

**1. 将构造函数当作函数**。构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数毕竟也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过 new 操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过 new 操作符来调用，那它跟普通函数也不会有什么两样。例如，前面例子中定义的`Person()`函数可以通过下列任何一种方式来调用。

```js
// 当作构造函数使用
var person = new Person("Nicholas", 29, "Software Engineer");
person.sayName(); //"Nicholas"

// 作为普通函数调用
Person("Greg", 27, "Doctor"); // 添加到 window
window.sayName(); //"Greg"

// 在另一个对象的作用域中调用
var o = new Object();
Person.call(o, "Kristen", 25, "Nurse");
o.sayName(); //"Kristen"
```

**2. 构造函数的问题**。使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。在前面的例子中， person1 和 person2 都有一个名为`sayName()`的方法，但那两个方法不是同一个 Function 的实例。不要忘了——ECMAScript 中的函数是对象，因此每定义一个函数，也就是实例化了一个对象。从逻辑角度讲，此时的构造函数也可以这样定义。

```js
function Person(name, age, job){
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = new Function("alert(this.name)"); // 与声明函数在逻辑上是等价的
}
```

从这个角度上来看构造函数，更容易明白每个 Person 实例都包含一个不同的 Function 实例（以显示 name 属性）的本质。说明白些，以这种方式创建函数，会导致不同的作用域链和标识符解析，但创建 Function 新实例的机制仍然是相同的。因此，不同实例上的同名函数是不相等的，以下代码可以证明这一点。

```js
alert(person1.sayName == person2.sayName);  //false      
```

然而，创建两个完成同样任务的 Function 实例的确没有必要；况且有 this 对象在，根本不用在执行代码前就把函数绑定到特定对象上面。因此，大可像下面这样，通过把函数定义转移到构造函数外部来解决这个问题。

```js
function Person(name, age, job){
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = sayName;
}
function sayName(){
  alert(this.name);
}
var person1 = new Person("Nicholas", 29, "Software Engineer");
var person2 = new Person("Greg", 27, "Doctor");
```

在这个例子中，我们把`sayName()`函数的定义转移到了构造函数外部。而在构造函数内部，我们将 sayName 属性设置成等于全局的 sayName 函数。这样一来，由于 sayName 包含的是一个指向函数的指针，因此 person1 和 person2 对象就共享了在全局作用域中定义的同一个`sayName()`函数。这样做确实解决了两个函数做同一件事的问题，可是新问题又来了：在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实。而更让人无法接受的是：如果对象需要定义很多方法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。好在，这些问题可以通过使用原型模式来解决。

### 6.2.3 原型模式

我们创建的每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中，如下面的例子所示。

```js
function Person(){
}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function(){
  alert(this.name);
};

var person1 = new Person();
person1.sayName(); //"Nicholas"

var person2 = new Person();
person2.sayName(); //"Nicholas"

alert(person1.sayName == person2.sayName); //true
```

即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但与构造函数模式不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说，person1 和 person2 访问的都是同一组属性和同一个`sayName()`函数。要理解原型模式的工作原理，必须先理解 ECMAScript 中原型对象的性质。

**1.理解原型对象**

无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个 constructor （构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。就拿前面的例子来说，`Person.prototype.constructor` 指向 Person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。

创建了自定义的构造函数之后，其原型对象默认只会取得 constructor 属性；至于其他方法，则都是从 Object 继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。 ECMA-262 第 5 版中管这个指针叫`[[Prototype]]`。虽然在脚本中没有标准的方式访问`[[Prototype]]`，但 Firefox、 Safari 和 Chrome 在每个对象上都支持一个属性`__proto__`；而在其他实现中，这个属性对脚本则是完全不可见的。不过，要明确的真正重要的一点就是，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。

图 6-1 展示了 Person 构造函数、 Person 的原型属性以及 Person 现有的两个实例之间的关系。在此，`Person.prototype `指向了原型对象，而 `Person.prototype.constructor` 又指回了 Person。原型对象中除了包含 constructor 属性之外，还包括后来添加的其他属性。 Person 的每个实例——person1 和 person2 都包含一个内部属性，该属性仅仅指向了 `Person.prototype`；换句话说，它们与构造函数没有直接的关系。此外，要格外注意的是，虽然这两个实例都不包含属性和方法，但我们却可以调用`person1.sayName()`。这是通过查找对象属性的过程来实现的。

虽然在所有实现中都无法访问到`[[Prototype]]`，但是可以通过 `isPrototypeOf()` 方法来确定对象之间是否存在这种关系，从本质上讲，如果`[[Prototype]]`指向调用`isPrototypeOf()`方法的对象（Person.prototype），那么这个方法就返回 true。

```js
alert(Person.prototype.isPrototypeOf(person1)); //true
alert(Person.prototype.isPrototypeOf(person2)); //true
```

ECMAScript 5 增加了一个新方法，叫 `Object.getPrototypeOf()`，在所有支持的实现中，这个方法返回`[[Prototype]]`的值。返回的对象实际就是这个对象的原型。

```js
alert(Object.getPrototypeOf(person1) == Person.prototype); //true
alert(Object.getPrototypeOf(person1).name); //"Nicholas"
```

每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。也就是说，在我们调用 `person1.sayName()`的时候，会先后执行两次搜索。首先，解析器会问：“实例 person1 有 sayName 属性吗？”答：“没有。”然后，它继续搜索，再问：“person1 的原型有 sayName 属性吗？”答：“有。”于是，它就读取那个保存在原型对象中的函数。当我们调用 `person2.sayName()`时，将会重现相同的搜索过程，得到相同的结果。而这正是多个对象实例共享原型所保存的属性和方法的基本原理。

> 前面提到过，原型最初只包含 constructor 属性，而该属性也是共享的，因此可以通过对象实例访问。

虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性。换句话说，添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。

```js
function Person(){
}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function(){
  alert(this.name);
};
var person1 = new Person();
var person2 = new Person();

person1.name = "Greg";
alert(person1.name); //"Greg"—— 来自实例
alert(person2.name); //"Nicholas"—— 来自原型
```

即使将这个同名属性设置为 null，也只会在实例中设置这个属性，而不会恢复其指向原型的连接。不过，使用 delete 操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性。

```js
function Person(){
}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function(){
  alert(this.name);
};
var person1 = new Person();
var person2 = new Person();

person1.name = "Greg";
alert(person1.name); //"Greg"—— 来自实例
alert(person2.name); //"Nicholas"—— 来自原型

delete person1.name;
alert(person1.name); //"Nicholas"—— 来自原型
```

使用`hasOwnProperty()`方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法（不要忘了它是从 Object 继承来的）只在给定属性存在于对象实例中时，才会返回 true。来看下面这个例子。

```js
function Person(){
}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function(){
  alert(this.name);
};
var person1 = new Person();
var person2 = new Person();

alert(person1.hasOwnProperty("name")); //false

person1.name = "Greg";
alert(person1.name); //"Greg"—— 来自实例
alert(person1.hasOwnProperty("name")); //true

alert(person2.name); //"Nicholas"—— 来自原型
alert(person2.hasOwnProperty("name")); //false

delete person1.name;
alert(person1.name); //"Nicholas"—— 来自原型
alert(person1.hasOwnProperty("name")); //false
```

通过使用`hasOwnProperty()`方法，什么时候访问的是实例属性，什么时候访问的是原型属性就一清二楚了。

> ECMAScript 5 的`Object.getOwnPropertyDescriptor()`方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用`Object.getOwnPropertyDescriptor()`方法。

**2.原型与 in 操作符**

有两种方式使用 in 操作符：单独使用和在 for-in 循环中使用。在单独使用时， in 操作符会在通过对象能够访问给定属性时返回 true，无论该属性存在于实例中还是原型中。

```js
function Person(){
}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function(){
  alert(this.name);
};
var person1 = new Person();
var person2 = new Person();

alert(person1.hasOwnProperty("name")); //false
alert("name" in person1); //true

person1.name = "Greg";
alert(person1.name); //"Greg" —— 来自实例
alert(person1.hasOwnProperty("name")); //true
alert("name" in person1); //true

alert(person2.name); //"Nicholas" —— 来自原型
alert(person2.hasOwnProperty("name")); //false
alert("name" in person2); //true

delete person1.name;
alert(person1.name); //"Nicholas" —— 来自原型
alert(person1.hasOwnProperty("name")); //false
alert("name" in person1); //true
```

以上代码执行的整个过程中， name 属性要么是直接在对象上访问到的，要么是通过原型访问到的。因此，调用"name" in person1 始终都返回 true，无论该属性存在于实例中还是存在于原型中。同时使用 `hasOwnProperty()`方法和 in 操作符，就可以确定该属性到底是存在于对象中，还是存在于原型中，如下所示。

```js
function hasPrototypeProperty(object, name){
  return !object.hasOwnProperty(name) && (name in object);
}
```

由于 in 操作符只要通过对象能够访问到属性就返回 true，`hasOwnProperty()`只在属性存在于实例中时才返回 true，因此只要 in 操作符返回 true 而`hasOwnProperty()`返回 false，就可以确定属性是原型中的属性。下面来看一看上面定义的函数`hasPrototypeProperty()`的用法。

```js
function Person(){
}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function(){
alert(this.name);
};

var person = new Person();
alert(hasPrototypeProperty(person, "name")); //true

person.name = "Greg";
alert(hasPrototypeProperty(person, "name")); //false
```

在使用 for-in 循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（即将`[[Enumerable]]`标记为 false 的属性）的实例属性也会在 for-in 循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的——只有在 IE8 及更早版本中例外。

IE 早期版本的实现中存在一个 bug，即屏蔽不可枚举属性的实例属性不会出现在 for-in 循环中。

要取得对象上所有可枚举的实例属性，可以使用 ECMAScript 5 的 `Object.keys()`方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。

```js
function Person(){
}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function(){
  alert(this.name);
};

var keys = Object.keys(Person.prototype);
alert(keys); //"name,age,job,sayName"

var p1 = new Person();
p1.name = "Rob";
p1.age = 31;
var p1keys = Object.keys(p1);
alert(p1keys); //"name,age"
```

如果你想要得到所有实例属性，无论它是否可枚举，都可以使用 `Object.getOwnPropertyNames()`方法。注意结果中包含了不可枚举的 constructor 属性。` Object.keys()`和 `Object.getOwnPropertyNames()`方法都可以用来替代 for-in 循环。 

```js
var keys = Object.getOwnPropertyNames(Person.prototype);
alert(keys); //"constructor,name,age,job,sayName"
```

**3.更简单的原型语法**

前面例子中每添加一个属性和方法就要敲一遍`Person.prototype`。为减少不必要的输入，也为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象，如下面的例子所示。

```js
function Person(){
}
Person.prototype = {
  name : "Nicholas",
  age : 29,
  job: "Software Engineer",
  sayName : function () {
    alert(this.name);
  }
};
```

在上面的代码中，我们将 `Person.prototype` 设置为等于一个以对象字面量形式创建的新对象。最终结果相同，但有一个例外： constructor 属性不再指向 Person 了。前面曾经介绍过，每创建一个函数，就会同时创建它的 prototype 对象，这个对象也会自动获得 constructor 属性。而我们在这里使用的语法，本质上完全重写了默认的 prototype 对象，因此 constructor 属性也就变成了新对象的 constructor 属性（指向 Object 构造函数），不再指向 Person 函数。此时，尽管 instanceof 操作符还能返回正确的结果，但通过 constructor 已经无法确定对象的类型了。

```js
var friend = new Person();

alert(friend instanceof Object); //true
alert(friend instanceof Person); //true
alert(friend.constructor == Person); //false
alert(friend.constructor == Object); //true
```

在此，用 instanceof 操作符测试 Object 和 Person 仍然返回 true，但 constructor 属性则等于 Object 而不等于 Person 了。如果 constructor 的值真的很重要，可以像下面这样特意将它设置回适当的值。

```js
function Person(){
}
Person.prototype = {
  constructor : Person,
  name : "Nicholas",
  age : 29,
  job: "Software Engineer",
  sayName : function () {
    alert(this.name);
  }
};
```

注意，以这种方式重设 constructor 属性会导致它的`[[Enumerable]]`特性被设置为 true。默认情况下，原生的 constructor 属性是不可枚举的。因此如果你使用兼容 ECMAScript 5 的 JavaScript 引擎，可以试一试 `Object.defineProperty()`。

```js
function Person(){
}
Person.prototype = {
  name : "Nicholas",
  age : 29,
  job : "Software Engineer",
  sayName : function () {
    alert(this.name);
  }
};
//重设构造函数，只适用于 ECMAScript 5 兼容的浏览器
Object.defineProperty(Person.prototype, "constructor", {
  enumerable: false,
  value: Person
});
```

**4.原型的动态性**

由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来——即使是先创建了实例后修改原型也照样如此。请看下面的例子。

```js
var friend = new Person();
Person.prototype.sayHi = function(){
  alert("hi");
};
friend.sayHi(); //"hi"（没有问题！）
```

即使 person 实例是在添加新方法之前创建的，但它仍然可以访问这个新方法。其原因可以归结为实例与原型之间的松散连接关系。当我们调用`person.sayHi()`时，首先会在实例中搜索名为 sayHi 的属性，在没找到的情况下，会继续搜索原型。因为实例与原型之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的 sayHi 属性并返回保存在那里的函数。

尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，那么情况就不一样了。我们知道，调用构造函数时会为实例添加一个指向最初原型的`[[Prototype]]`指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。请记住：实例中的指针仅指向原型，而不指向构造函数。

```js
function Person(){
}
var friend = new Person();
Person.prototype = {
  constructor: Person,
  name : "Nicholas",
  age : 29,
  job : "Software Engineer",
  sayName : function () {
    alert(this.name);
  }
};
friend.sayName(); //error
```

重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系；它们引用的仍然是最初的原型。

**5.原生对象的原型**

原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型（Object、 Array、 String，等等）都在其构造函数的原型上定义了方法。例如，在 Array.prototype 中可以找到`sort()`方法，而在 String.prototype 中可以找到`substring()`方法，如下所示。

```js
alert(typeof Array.prototype.sort); //"function"
alert(typeof String.prototype.substring); //"function"
```

通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。下面的代码就给基本包装类型 String 添加了一个名为`startsWith()`的方法。

```js
String.prototype.startsWith = function (text) {
  return this.indexOf(text) == 0;
};
var msg = "Hello world!";
alert(msg.startsWith("Hello")); //true
```

由于 msg 是字符串，而且后台会调用 String 基本包装函数创建这个字符串，因此通过 msg 就可以调用`startsWith()`方法。

> 尽管可以这样做，但我们不推荐在产品化的程序中修改原生对象的原型。如果因某个实现中缺少某个方法，就在原生对象的原型中添加这个方法，那么当在另一个支持该方法的实现中运行代码时，就可能会导致命名冲突。而且，这样做也可能会意外地重写原生方法。

**6.原型对象的问题**

原型模式也不是没有缺点。首先，它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题。原型模式的最大问题是由其共享的本性所导致的。

原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒也说得过去，毕竟（如前面的例子所示），通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。然而，对于包含引用类型值的属性来说，问题就比较突出了。

```js
function Person(){
}
Person.prototype = {
  constructor: Person,
  name : "Nicholas",
  age : 29,
  job : "Software Engineer",
  friends : ["Shelby", "Court"],
  sayName : function () {
    alert(this.name);
  }
};

var person1 = new Person();
var person2 = new Person();

person1.friends.push("Van");

alert(person1.friends); //"Shelby,Court,Van"
alert(person2.friends); //"Shelby,Court,Van"
alert(person1.friends === person2.friends); //true
```

由于 friends 数组存在于`Person.prototype` 而非 person1 中，所以刚刚提到的修改也会通过`person2.friends`（与 `person1.friends` 指向同一个数组）反映出来。假如我们的初衷就是像这样在所有实例中共享一个数组，那么对这个结果我没有话可说。可是，实例一般都是要有属于自己的全部属性的。而这个问题正是我们很少看到有人单独使用原型模式的原因所在。

### 6.2.4 组合使用构造函数模式和原型模式

创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。

```js
function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.friends = ["Shelby", "Court"];
}

Person.prototype = {
    constructor: Person,
    sayName : function () {
        alert(this.name);
    }
};

var person1 = new Person("Nicholas", 29, "Software Engineer");
var person2 = new Person("Greg", 27, "Doctor");

person1.friends.push("Van");

alert(person1.friends);    //"Shelby,Court,Van"
alert(person2.friends);    //"Shelby,Court"
alert(person1.friends === person2.friends);  //false
alert(person1.sayName === person2.sayName);  //true
```

### 6.2.5 动态原型模式

有其他 OO 语言经验的开发人员在看到独立的构造函数和原型时，很可能会感到非常困惑。动态原型模式正是致力于解决这个问题的一个方案，它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。

```js
function Person(name, age, job){
    //properties
    this.name = name;
    this.age = age;
    this.job = job;
    
    //methods
    if (typeof this.sayName != "function"){
        Person.prototype.sayName = function(){
            alert(this.name);
        };
    }
}

var friend = new Person("Nicholas", 29, "Software Engineer");
friend.sayName();
```

其中， if 语句检查的可以是初始化之后应该存在的任何属性或方法——不必用一大堆 if 语句检查每个属性和每个方法；只要检查其中一个即可。对于采用这种模式创建的对象，还可以使用 instanceof 操作符确定它的类型。

### 6.2.6 寄生构造函数模式

通常，在前述的几种模式都不适用的情况下，可以使用寄生（parasitic）构造函数模式。这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象；但从表面上看，这个函数又很像是典型的构造函数。

```js
function Person(name, age, job){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function(){
        alert(this.name);
    };    
    return o;
}
  
var friend = new Person("Nicholas", 29, "Software Engineer");
friend.sayName();  //"Nicholas"
```

除了使用 new 操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的。构造函数在不返回值的情况下，默认会返回新对象实例。而通过在构造函数的末尾添加一个 return 语句，可以重写调用构造函数时返回的值。

这个模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊数组。由于不能直接修改 Array 构造函数，因此可以使用这个模式。

```js
function SpecialArray(){
  //创建数组
  var values = new Array();
  //添加值
  values.push.apply(values, arguments);
  //添加方法
  values.toPipedString = function(){
    return this.join("|");
  };
  //返回数组
  return values;
}
var colors = new SpecialArray("red", "blue", "green");
alert(colors.toPipedString()); //"red|blue|green"
```

关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖 instanceof 操作符来确定对象类型。由于存在上述问题，我们建议在可以使用其他模式的情况下，不要使用这种模式。

### 6.2.7 稳妥构造函数模式

道格拉斯·克罗克福德（Douglas Crockford）发明了 JavaScript 中的稳妥对象（durable objects）这个概念。所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用 this 和 new），或者在防止数据被其他应用程序（如 Mashup 程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的实例方法不引用 this；二是不使用 new 操作符调用构造函数。

```js
function Person(name, age, job){
  //创建要返回的对象
  var o = new Object();
  //可以在这里定义私有变量和函数
  //添加方法
  o.sayName = function(){
    alert(name);
  };
  //返回对象
  return o;
}

var friend = Person("Nicholas", 29, "Software Engineer");
friend.sayName(); //"Nicholas"
```

## 6.3 继承　

继承是 OO 语言中的一个最为人津津乐道的概念。许多 OO 语言都支持两种继承方式：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。如前所述，由于函数没有签名，在 ECMAScript 中无法实现接口继承。 ECMAScript 只支持实现继承，而且其实现继承主要是依靠原型链来实现的。

### 6.3.1 原型链

ECMAScript 中描述了原型链的概念，并将原型链作为实现继承的主要方法，其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。

每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。如果我们让原型对象等于另一个类型的实例，原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。  

```js
function SuperType(){
    this.property = true;
}

SuperType.prototype.getSuperValue = function(){
    return this.property;
};

function SubType(){
    this.subproperty = false;
}

// 继承了 from SuperType
SubType.prototype = new SuperType();

SubType.prototype.getSubValue = function (){
    return this.subproperty;
};

var instance = new SubType();
alert(instance.getSuperValue());   //true

alert(instance instanceof Object);      //true
alert(instance instanceof SuperType);   //true
alert(instance instanceof SubType);     //true

alert(Object.prototype.isPrototypeOf(instance));    //true
alert(SuperType.prototype.isPrototypeOf(instance)); //true
```

### 6.3.2 借用构造函数

借用构造函数，通过使用 `apply ()` 和 `call ()` 方法在新创建的对象上执行构造函数。

### 6.3.3 组合继承

组合继承，指的是原型链和结构构造函数的技术组合到一起，从而发挥二者之长的一种继承模式。

### 6.3.4 原型式继承

原型式继承，借助原型可以基于已有的对象创建新对象，因此不必因此创建自定义类型。

### 6.3.5 寄生式继承

寄生式继承，与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。

### 6.3.6 寄生组合式继承

寄生组合式继承，通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。

6.4　小结　

# 第7章 函数表达式

定义函数的方式有两种：一种是函数声明，另一种就是函数表达式。

函数声明是使用 function 关键字，再加上函数的名字，这就是指定函数名的方式。函数声明的重要特征就是函数声明提升，执行代码之前先读取函数声明。这意味着可以把函数声明放在调用它的语句后面。

```js
//  不会抛出错误
sayHi();
function sayHi(){
  alert("Hi!");
}
```

第二种创建函数的方式是使用函数表达式。函数表达式有几种不同的语法形式。

下面形式看起来好像是常规的变量赋值语句，即创建一个函数并将它赋值给变量。这种情况下创建的函数叫做匿名函数（anonymous function），因为 function 关键字后面没有标识符（匿名函数有时候也叫拉姆达函数），匿名函数的 name 属性是空字符串。函数表达式与其他表达式一样，在使用前必须先赋值。

```js
sayHi(); //错误：函数还不存在
var sayHi = function(){
  alert("Hi!");
};
```

理解函数提升的关键，就是理解函数声明与函数表达式之间的区别。例如，执行以下代码的结果可能会让人意想不到。

```js
//不要这样做！
if(condition){
  function sayHi(){
      alert("Hi!");
    }
} else {
  function sayHi(){
      alert("Yo!");
    }
}
```

实际上，以上的代码在 ECMAScript 中属于无效语法， JavaScript 引擎会尝试修正错误，将其转换为合理的状态。但问题是浏览器尝试修正错误的做法并不一致。大多数浏览器会返回第二个声明，忽略condition； Firefox 会在 condition 为 true 时返回第一个声明。因此这种使用方式很危险，不应该出现在你的代码中。不过，如果是使用函数表达式，那就没有什么问题了。

```js
//可以这样做
var sayHi;
if(condition){
  sayHi = function(){
    alert("Hi!");
  };
} else {
  sayHi = function(){
    alert("Yo!");
  };
}
```

能够创建函数再赋值给变量，也就能够把函数作为其他函数的值返回。

```js
function createComparisonFunction(propertyName) {
  return function(object1, object2){
    var value1 = object1[propertyName];
    var value2 = object2[propertyName];
    if (value1 < value2){
     return -1;
    } else if (value1 > value2){
     return 1;
    } else {
     return 0;
    }
  };
}
```

返回的函数可能会被赋值给一个变量，或者以其他方式被调用；不过，在函数内部，它是匿名的。在把函数当成值来使用的情况下都可以使用匿名函数。不过，这并不是匿名函数唯一的用途。

## 7.1 递归 

递归函数是在一个函数通过名字调用自身的情况下构成的。

```js
function factorial(num){
  if (num <= 1){
    return 1;
  } else {
    return num * factorial(num-1);
  }
}
```

这是一个经典的递归阶乘函数。虽然这个函数表面看来没什么问题，但下面的代码却可能导致它出错。

```js
var anotherFactorial = factorial;
factorial = null;
alert(anotherFactorial(4)); //出错！
```

`arguments.callee`是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调用。通过使用 `arguments.callee` 代替函数名，可以确保无论怎样调用函数都不会出问题。

```js
function factorial(num){
  if (num <= 1){
    return 1; 
  } else {
    return num * arguments.callee(num-1);
  }
}
```

但在严格模式下，不能通过脚本访问`arguments.callee`，访问这个属性会导致错误。不过，可以使用命名函数表达式来达成相同的结果。

```js
var factorial = (function f(num){
  if (num <= 1){
    return 1;
  } else {
    return num * f(num-1);
  }
});
```

## 7.2 闭包 

闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。下面代码即使这个内部函数被返回了，而且是在其他地方被调用了，但它仍然可
以访问变量 propertyName 。之所以还能够访问这个变量，是因为内部函数的作用域链中包含`createComparisonFunction()`的作用域。要彻底搞清楚其中的细节，必须从理解函数被调用的时候
都会发生什么入手。

```js
function createComparisonFunction(propertyName) {
  return function(object1, object2){
    var value1 = object1[propertyName];
    var value2 = object2[propertyName];
    if (value1 < value2){
      return -1;
    } else if (value1 > value2){
      return 1;
    } else {
      return 0;
    }
  };
}
```

当某个函数被调用时，会创建一个执行环境（execution context）及相应的作用域链。然后，使用 arguments 和其他命名参数的值来初始化函数的活动对象（activation object）。但在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位，……直至作为作用域链终点的全局执行环境。

在函数执行过程中，为读取和写入变量的值，就需要在作用域链中查找变量。无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。

```js
function compare(value1, value2){
  if (value1 < value2){
    return -1;
  } else if (value1 > value2){
    return 1;
  } else {
    return 0;
  }
}
var result = compare(5, 10);
```

以上代码先定义了 `compare()`函数，然后又在全局作用域中调用了它。当调用 `compare()`时，会创建一个包含 arguments、 value1 和 value2 的活动对象。全局执行环境的变量对象（包含 result和 compare）在 `compare()`执行环境的作用域链中则处于第二位。

后台的每个执行环境都有一个表示变量的对象——变量对象。全局环境的变量对象始终存在，而像`compare()`函数这样的局部环境的变量对象，则只在函数执行的过程中存在。在创建 `compare()`函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的`[[Scope]]`属性中。当调用 `compare()`函数时，会为函数创建一个执行环境，然后通过复制函数的`[[Scope]]`属性中的对象构建起执行环境的作用域链。此后，又有一个活动对象（在此作为变量对象使用）被创建并被推入执行环境作用域链的前端。对于这个例子中 `compare()`函数的执行环境而言，其作用域链中包含两个变量对象：本地活动对象和全局变量对象。显然，作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。

无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是，闭包的情况又有所不同。

在另一个函数内部定义的函数会将包含函数（即外部函数）的活动对象添加到它的作用域链中。因此，在 `createComparisonFunction()`函数内部定义的匿名函数的作用域链中，实际上将会包含外部函数 `createComparisonFunction()`的活动对象。当下列代码执行时，包含函数与内部匿名函数的作用域链。

```js
var compare = createComparisonFunction("name");
var result = compare({ name: "Nicholas" }, { name: "Greg" });
```

在匿名函数从 `createComparisonFunction()`中被返回后，它的作用域链被初始化为包含`createComparisonFunction()`函数的活动对象和全局变量对象。这样，匿名函数就可以访问在`createComparisonFunction()`中定义的所有变量。更为重要的是，`createComparisonFunction()`函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。换句话说，当 `createComparisonFunction()`函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中；直到匿名函数被销毁后， `createComparisonFunction()`的活动对象才会被销毁，例如：

```js
//创建函数
var compareNames = createComparisonFunction("name");

//调用函数
var result = compareNames({ name: "Nicholas" }, { name: "Greg" });

//解除对匿名函数的引用（以便释放内存）
compareNames = null;
```

首先，创建的比较函数被保存在变量 compareNames 中。而通过将 compareNames 设置为等于 null 解除该函数的引用，就等于通知垃圾回收例程将其清除。随着匿名函数的作用域链被销毁，其他作用域（除了全局作用域）也都可以安全地销毁了。

> 由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多，建议只在绝对必要时再考虑使用闭包。虽然像 V8 等优化后的 JavaScript 引擎会尝试回收被闭包占用的内存，但请大家还是要慎重使用闭包。

### 7.2.1 闭包与变量

作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。闭包所保存的是整个变量对象，而不是某个特殊的变量。

```js
function createFunctions(){
  var result = new Array();
  for (var i=0; i < 10; i++){
    result[i] = function(){
      return i;
    };
  }
  return result;
}
```

这个函数会返回一个函数数组。表面上看，似乎每个函数都应该返自己的索引值。但实际上，每个函数都返回 10。因为每个函数的作用域链中都保存着`createFunctions()`函数的活动对象，所以它们引用的都是同一个变量i 。 当`createFunctions()`函数返回后，变量 i 的值是 10，此时每个函数都引用着保存变量 i 的同一个变量对象，所以在每个函数内部 i 的值都是 10。

可以通过创建另一个匿名函数强制让闭包的行为符合预期。

```js
function createFunctions(){
  var result = new Array();
  for (var i=0; i < 10; i++){
    result[i] = function(num){
      return function(){
        return num;
      };
    }(i);
  }
  return result;
}
```

在这个版本中，没有直接把闭包赋值给数组，而是定义了一个匿名函数，并将立即执行该匿名函数的结果赋给数组。这里的匿名函数有一个参数 num，也就是最终的函数要返回的值。在调用每个匿名函数时，我们传入了变量 i。由于函数参数是按值传递的，所以就会将变量 i 的当前值复制给参数 num。而在这个匿名函数内部，又创建并返回了一个访问 num 的闭包。这样一来， result 数组中的每个函数都有自己 num 变量的一个副本，因此就可以返回各自不同的数值了。

### 7.2.2 关于this对象

this 对象是在运行时基于函数的执行环境绑定的：在全局函数中，this 等于 window，而当函数被作为某个对象的方法调用时，this 等于那个对象。不过，匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window。但有时候由于编写闭包的方式不同，这一点可能不会那么明显。

```js
var name = "The Window";
var object = {
  name : "My Object",
  getNameFunc : function(){
    return function(){
      return this.name;
    };
  }
};
alert(object.getNameFunc()()); //"The Window"（在非严格模式下）
```

为什么匿名函数没有取得其包含作用域（或外部作用域）的 this 对象呢？前面曾经提到过，每个函数在被调用时都会自动取得两个特殊变量：`this` 和 `arguments`。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。不过，把外部作用域中的 this 对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象了。

```js
var name = "The Window";
var object = {
  name : "My Object",
  getNameFunc : function(){
    var that = this;
    return function(){
      return that.name;
    };
  }
};
alert(object.getNameFunc()()); //"My Object"
```

> this 和 arguments 也存在同样的问题。如果想访问作用域中的 arguments 对象，必须将对该对象的引用保存到另一个闭包能够访问的变量中。

在下面几种特殊情况下， this 的值可能会意外地改变。

```js
var name = "The Window";
var object = {
  name : "My Object",
  getName: function(){
    return this.name;
  }
};

object.getName(); //"My Object"
(object.getName)(); //"My Object"
(object.getName = object.getName)(); //"The Window"，在非严格模式下
```

第三行代码先执行了一条赋值语句，然后再调用赋值后的结果。因为这个赋值表达式的值是函数本身，所以 this 的值不能得到维持，结果就返回了"The Window"。

### 7.2.3 内存泄漏

由于 IE9 之前的版本对 JScript 对象和 COM 对象使用不同的垃圾收集例程，因此闭包在 IE 的这些版本中会导致一些特殊的问题。具体来说，如果闭包的作用域链中保存着一个HTML 元素，那么就意味着该元素将无法被销毁。只要匿名函数存在，变量引用 DOM 的引用数至少也是1，因此它所占用的内存就永远不会被回收。

```js
function assignHandler(){
  var element = document.getElementById("someElement");
  element.onclick = function(){
    alert(element.id);
  };
}
```

闭包会引用包含函数的整个活动对象，而其中包含着 element。通过把 element.id 的一个副本保存在一个变量中，并且在闭包中引用该变量消除了循环引用。但仅仅做到这一步，还是不能解决内存泄漏的问题。即使闭包不直接引用 element，包含函数的活动对象中也仍然会保存一个引用。因此，有必要把 element 变量设置为 null。这样就能够解除对 DOM 对象的引用，顺利地减少其引用数，确保正常回收其占用的内存。

```js
function assignHandler(){
  var element = document.getElementById("someElement");
  var id = element.id;
  element.onclick = function(){
    alert(id);
  };
  element = null;
}
```

## 7.3 模仿块级作用域

JavaScript 没有块级作用域的概念。这意味着在块语句中定义的变量，实际上是在包含函数中而非语句中创建的。

```js
function outputNumbers(count){
  for (var i=0; i < count; i++){
    alert(i);
  }
  alert(i); //计数
}
```

在 Java、 C++等语言中，变量 i 只会在 for 循环的语句块中有定义，循环一旦结束，变量 i 就会被销毁。可是在 JavaScrip 中，变量 i 是定义在 `ouputNumbers()`的活动对象中的，因此从它有定义开始，就可以在函数内部随处访问它。即使像下面这样错误地重新声明同一个变量，也不会改变它的值。

```js
function outputNumbers(count){
  for (var i=0; i < count; i++){
    alert(i);
  }
  var i; //重新声明变量
  alert(i); //计数
}
```

JavaScript 从来不会告诉你是否多次声明了同一个变量，它只会对后续的声明视而不见（不过，它会执行后续声明中的变量初始化）。匿名函数可以用来模仿块级作用域并避免这个问题。

用作块级作用域（通常称为私有作用域）的匿名函数的语法如下所示。

```js
(function(){
  //这里是块级作用域
})();
```

以上代码定义并立即调用了一个匿名函数。将函数声明包含在一对圆括号中，表示它实际上是一个函数表达式。而紧随其后的另一对圆括号会立即调用这个函数。如果有读者感觉这种语法不太好理解，可以再看看下面这个例子。

```js
var count = 5;
outputNumbers(count);
// 也可以这么做
// outputNumbers(5);
```

这样做之所以可行，是因为变量只不过是值的另一种表现形式，因此用实际的值替换变量没有问题。再看下面的例子。

```js
var someFunction = function(){
//这里是块级作用域
};
someFunction();
```

通过前面的例子我们知道，可以使用实际的值来取代变量 count，那在这里是不是也可以用函数的值直接取代函数名呢？ 然而，下面的代码却会导致错误。

```js
function(){
  //这里是块级作用域
}(); //出错！
```

这段代码会导致语法错误，是因为 JavaScript 将 function 关键字当作一个函数声明的开始，而函数声明后面不能跟圆括号。然而，函数表达式的后面可以跟圆括号。要将函数声明转换成函数表达式，只要给它加上一对圆括号即可。

无论在什么地方，只要临时需要一些变量，就可以使用私有作用域：

```js
function outputNumbers(count){
  (function () {
    for (var i=0; i < count; i++){
      alert(i);
    }
  })();
  alert(i); //导致一个错误！
}
```

因此，变量 i 只能在循环中使用，使用后即被销毁。而在私有作用域中能够访问变量 count，是因为这个匿名函数是一个闭包，它能够访问包含作用域中的所有变量。

这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。一般来说，我们都应该尽量少向全局作用域中添加变量和函数。在一个由很多开发人员共同参与的大型应用程序中，过多的全局变量和函数很容易导致命名冲突。而通过创建私有作用域，每个开发人员既可以使用自己的变量，又不必担心搞乱全局作用域。

```js
(function(){
  var now = new Date();
  if (now.getMonth() == 0 && now.getDate() == 1){
    alert("Happy new year!");
  }
})();
```

把上面这段代码放在全局作用域中，可以用来确定哪一天是 1 月 1 日；如果到了这一天，就会向用户显示一条祝贺新年的消息。其中的变量 now 现在是匿名函数中的局部变量，而我们不必在全局作用域中创建它。

> 这种做法可以减少闭包占用的内存问题，因为没有指向匿名函数的引用。只要函数执行完毕，就可以立即销毁其作用域链了。

## 7.4 私有变量

严格来说，JavaScript 中没有私有成员的概念：所有对象属性都是公有的。不过，倒是有一个私有变量的概念。任何函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。私有变量包括函数的参数、局部变量和在函数内部定义的其他函数。

```js
function add(num1, num2){
  var sum = num1 + num2;
  return sum;
}
```

在这个函数内部，有 3 个私有变量： num1、 num2 和 sum。在函数内部可以访问这几个变量，但在函数外部则不能访问它们。如果在这个函数内部创建一个闭包，那么闭包通过自己的作用域链也可以访问这些变量。而利用这一点，就可以创建用于访问私有变量的公有方法。

我们把有权访问私有变量和私有函数的公有方法称为特权方法。有两种在对象上创建特权方法的方式。第一种是在构造函数中定义特权方法。

```js
function MyObject(){
  // 私有变量
  var privateVariable = 10;
  // 私有函数
  function privateFunction(){
    return false;
  }
  // 特权方法
  this.publicMethod = function (){
    privateVariable++;
    return privateFunction();
  };
}
```

能够在构造函数中定义特权方法，是因为特权方法作为闭包有权访问在构造函数中定义的所有变量和函数。

利用私有和特权成员，可以隐藏那些不应该被直接修改的数据。

```js
function Person(name){
  this.getName = function(){
    return name;
  };
  this.setName = function (value) {
    name = value;
  };
}
var person = new Person("Nicholas");
alert(person.getName()); //"Nicholas"
person.setName("Greg");
alert(person.getName()); //"Greg"
```

不过，在构造函数中定义特权方法也有一个缺点，那就是你必须使用构造函数模式来达到这个目的。第 6 章曾经讨论过，构造函数模式的缺点是针对每个实例都会创建同样一组新方法，而使用静态私有变量来实现特权方法就可以避免这个问题。

### 7.4.1 静态私有变量

通过在私有作用域中定义私有变量或函数，同样也可以创建特权方法，其基本模式如下所示。

```js
(function(){
  //私有变量和私有函数
  var privateVariable = 10;
  function privateFunction(){
    return false;
  }
  //构造函数
  MyObject = function(){
  };
  //公有/特权方法
  MyObject.prototype.publicMethod = function(){
    privateVariable++;
    return privateFunction();
  };
})();
```

这个模式创建了一个私有作用域，并在其中封装了一个构造函数及相应的方法。在私有作用域中，首先定义了私有变量和私有函数，然后又定义了构造函数及其公有方法。公有方法是在原型上定义的，这一点体现了典型的原型模式。需要注意的是，这个模式在定义构造函数时并没有使用函数声明，而是使用了函数表达式。函数声明只能创建局部函数，但那并不是我们想要的。出于同样的原因，我们也没有在声明 MyObject 时使用 var 关键字。记住：初始化未经声明的变量，总是会创建一个全局变量。因此， MyObject 就成了一个全局变量，能够在私有作用域之外被访问到。但也要知道，在严格模式下给未经声明的变量赋值会导致错误。

这个模式与在构造函数中定义特权方法的主要区别，就在于私有变量和函数是由实例共享的。由于特权方法是在原型上定义的，因此所有实例都使用同一个函数。而这个特权方法，作为一个闭包，总是保存着对包含作用域的引用。来看一看下面的代码。

```js
(function(){
  var name = "";
  Person = function(value){
    name = value;
  };
  Person.prototype.getName = function(){
    return name;
  };
  Person.prototype.setName = function (value){
    name = value;
  };
})();

var person1 = new Person("Nicholas");
alert(person1.getName()); //"Nicholas"
person1.setName("Greg");
alert(person1.getName()); //"Greg"

var person2 = new Person("Michael");
alert(person1.getName()); //"Michael"
alert(person2.getName()); //"Michael"
```

以这种方式创建静态私有变量会因为使用原型而增进代码复用，但每个实例都没有自己的私有变量。到底是使用实例变量，还是静态私有变量，最终还是要视你的具体需求而定。

### 7.4.2 模块模式

前面的模式是用于为自定义类型创建私有变量和特权方法的。而道格拉斯所说的模块模式（ module pattern）则是为单例创建私有变量和特权方法。所谓单例（ singleton），指的就是只有一个实例的对象。按照惯例， JavaScript 是以对象字面量的方式来创建单例对象的。

```js
var singleton = {
  name : value,
  method : function () {
    //这里是方法的代码
  }
};
```

模块模式通过为单例添加私有变量和特权方法能够使其得到增强，其语法形式如下：

```js
var singleton = function(){
  //私有变量和私有函数
  var privateVariable = 10;
  function privateFunction(){
    return false;
  }
  //特权/公有方法和属性
  return {
    publicProperty: true,
    publicMethod : function(){
      privateVariable++;
      return privateFunction();
    }
  };
}();
```

这个模块模式使用了一个返回对象的匿名函数。在这个匿名函数内部，首先定义了私有变量和函数。然后，将一个对象字面量作为函数的值返回。返回的对象字面量中只包含可以公开的属性和方法。由于这个对象是在匿名函数内部定义的，因此它的公有方法有权访问私有变量和函数。从本质上来讲，这个对象字面量定义的是单例的公共接口。这种模式在需要对单例进行某些初始化，同时又需要维护其私有变量时是非常有用的，例如：

```js
var application = function(){
  //私有变量和函数
  var components = new Array();
  //初始化
  components.push(new BaseComponent());
  //公共
  return {
    getComponentCount : function(){
      return components.length;
    },
    registerComponent : function(component){
      if (typeof component == "object"){
        components.push(component);
      }
    }
  };
}();
```

在 Web 应用程序中，经常需要使用一个单例来管理应用程序级的信息。这个简单的例子创建了一个用于管理组件的 application 对象。在创建这个对象的过程中，首先声明了一个私有的 components 数组，并向数组中添加了一个 BaseComponent 的新实例（在这里不需要关心 BaseComponent 的代码，我们只是用它来展示初始化操作）。而返回对象的` getComponentCount()`和 `registerComponent()`方法，都是有权访问数组 components 的特权方法。前者只是返回已注册的组件数目，后者用于注册新组件。

简言之，如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式。以这种模式创建的每个单例都是 Object 的实例，因为最终要通过一个对象字面量来表示它。事实上，这也没有什么；毕竟，单例通常都是作为全局对象存在的，我们不会将它传递给一个函数。因此，也就没有什么必要使用 instanceof 操作符来检查其对象类型了。

### 7.4.3 增强的模块模式

增强的模块模式，即在返回对象之前加入对其增强的代码，这个模式适合那些单例必须是某种类型的实例，同时还必须添加某些属性和（或）方法对其加以增强的情况。

```js
var singleton = function(){
  //私有变量和私有函数
  var privateVariable = 10;
  function privateFunction(){
    return false;
  }
  //创建对象
  var object = new CustomType();
  //添加特权/公有属性和方法
  object.publicProperty = true;
  object.publicMethod = function(){
    privateVariable++;
    return privateFunction();
  };
  //返回这个对象
  return object;
}();
```

如果前面演示模块模式的例子中的 application 对象必须是 BaseComponent 的实例，那么就可以使用以下代码。

```js
var application = function(){
  //私有变量和函数
  var components = new Array();
  //初始化
  components.push(new BaseComponent());
  //创建 application 的一个局部副本
  var app = new BaseComponent();
  //公共接口
  app.getComponentCount = function(){
    return components.length;
  };
  app.registerComponent = function(component){
    if (typeof component == "object"){
    components.push(component);
    }
  };
  //返回这个副本
  return app;
}();
```

在这个重写后的应用程序（ application）单例中，首先也是像前面例子中一样定义了私有变量。主要的不同之处在于命名变量 app 的创建过程，因为它必须是 BaseComponent 的实例。这个实例实际上是 application 对象的局部变量版。此后，我们又为 app 对象添加了能够访问私有变量的公有方法。最后一步是返回 app 对象，结果仍然是将它赋值给全局变量 application。

## 7.5 小结

在 JavaScript 编程中，函数表达式是一种非常有用的技术。使用函数表达式可以无须对函数命名，从而实现动态编程。匿名函数，也称为拉姆达函数，是一种使用 JavaScript 函数的强大方式。以下总结了函数表达式的特点。

+ 函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表达式也叫做匿名函数。
+ 在无法确定如何引用函数的情况下，递归函数就会变得比较复杂；
+ 递归函数应该始终使用 arguments.callee 来递归地调用自身，不要使用函数名——函数名可能会发生变化。

当在函数内部定义了其他函数时，就创建了闭包。闭包有权访问包含函数内部的所有变量，原理如下。

+ 在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域。
+ 通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。
+ 但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。

使用闭包可以在 JavaScript 中模仿块级作用域（ JavaScript 本身没有块级作用域的概念），要点如下。

+ 创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用。
+ 结果就是函数内部的所有变量都会被立即销毁——除非将某些变量赋值给了包含作用域（即外部作用域）中的变量。

闭包还可以用于在对象中创建私有变量，相关概念和要点如下。

+ 即使 JavaScript 中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公有方法可以访问在包含作用域中定义的变量。
+ 有权访问私有变量的公有方法叫做特权方法。
+ 可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强的模块模式来实现单例的特权方法。

JavaScript 中的函数表达式和闭包都是极其有用的特性，利用它们可以实现很多功能。不过，因为创建闭包必须维护额外的作用域，所以过度使用它们可能会占用大量内存。

# 第8章 BOM　

BOM 浏览器对象模型是 Web 中使用 JavaScript 最重要的内容，BOM 提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关。

## 8.1 window对象 

BOM 的核心对象是 window，它表示浏览器的一个实例。在浏览器中， window 对象有双重角色，它既是通过 JavaScript 访问浏览器窗口的一个接口，又是 ECMAScript 规定的 Global 对象。这意味着在网页中定义的任何一个对象、变量和函数，都以 window 作为其 Global 对象，因此有权访问`parseInt()`等方法。

### 8.1.1 全局作用域

由于 window 对象同时扮演着 ECMAScript 中 Global 对象的角色，因此所有在全局作用域中声明的变量、函数都会变成 window 对象的属性和方法。

```js
var age = 29;
function sayAge(){
  alert(this.age);
}
alert(window.age); //29
sayAge(); //29
window.sayAge(); //29
```

定义全局变量与在 window 对象上直接定义属性还是有一点差别：全局变量不能通过 delete 操作符删除，而直接在 window 对象上的定义的属性可以。使用 var 语句添加的 window 属性有一个名为`[[Configurable]]`的特性，这个特性的值被设置为false，因此这样定义的属性不可以通过delete 操作符删除。

```js
var age = 29;
window.color = "red";
//在 IE < 9 时抛出错误，在其他所有浏览器中都返回 false
delete window.age;
//在 IE < 9 时抛出错误，在其他所有浏览器中都返回 true
delete window.color; //returns true
alert(window.age); //29
alert(window.color); //undefined
```

尝试访问未声明的变量会抛出错误，但是通过查询 window 对象，可以知道某个可能未声明的变量是否存在。

```js
//这里会抛出错误，因为 oldValue 未定义
var newValue = oldValue;
//这里不会抛出错误，因为这是一次属性查询
//newValue 的值是 undefined
var newValue = window.oldValue;
```

### 8.1.2 窗口关系及框架

如果页面中包含框架，则每个框架都拥有自己的 window 对象，并且保存在 frames 集合中。在 frames 集合中，可以通过数值索引（从 0 开始，从左至右，从上到下）或者框架名称来访问相应的 window 对象。每个 window 对象都有一个 name 属性，其中包含框架的名称。

```html
<html>
  <head>
    <title>Frameset Example</title>
  </head>
  <frameset rows="160,*">
    <frame src="frame.htm" name="topFrame">
    <frameset cols="50%,50%">
      <frame src="anotherframe.htm" name="leftFrame">
      <frame src="yetanotherframe.htm" name="rightFrame">
    </frameset>
  </frameset>
</html>
```

### 8.1.3 窗口位置

用来确定和修改 window 对象位置的属性和方法有很多。 IE、 Safari、 Opera 和 Chrome 都提供了screenLeft 和 screenTop 属性，分别用于表示窗口相对于屏幕左边和上边的位置。 Firefox 则在screenX 和 screenY 属性中提供相同的窗口位置信息， Safari 和 Chrome 也同时支持这两个属性。

```js
var leftPos = (typeof window.screenLeft == "number") ?
  window.screenLeft : window.screenX;
var topPos = (typeof window.screenTop == "number") ?
  window.screenTop : window.screenY;
```

使用 `moveTo ()` 和 `moveBy ()` 方法可能将窗口精确地移动到一个新位置，这两个方法都接收两个参数，其中 `moveTo ()` 接收的新新位置的 x 和 y 坐标值，而 `moveBy ()` 接收的是在水平和垂直方向上移动的像素数。

### 8.1.4 窗口大小

跨浏览器确定一个窗口的大小不是一件简单的事。 IE9+、 Firefox、 Safari、 Opera 和 Chrome 均为此提供了 4 个属性： innerWidth、 innerHeight、 outerWidth 和 outerHeight。

使用 `resizeTo ()` 和 `resizeBy ()` 方法可以调整浏览器窗口的大小，这两个方法都接收两个参数，前者接收浏览器窗口的新宽度和新高度，而后者接收新窗口与原窗口的宽度和高度之差。需要注意的是，这两个方法与移动窗口位置的方法类似，也有可能被浏览器禁用。

```js
//调整到 100× 100
window.resizeTo(100, 100);
//调整到 200× 150
window.resizeBy(100, 50);
//调整到 300× 300
window.resizeTo(300, 300);
```

### 8.1.5 导航和打开窗口

使用 `window.open()`方法既可以导航到一个特定的 URL，也可以打开一个新的浏览器窗口。这个方法可以接收 4 个参数：要加载的 URL、窗口目标、一个特性字符串以及一个表示新页面是否取代浏览器历史记录中当前加载页面的布尔值。通常只须传递第一个参数，最后一个参数只在不打开新窗口的情况下使用。

```js
//等同于< a href="http://www.wrox.com" target="topFrame"></a>
window.open("http://www.wrox.com/", "topFrame");
```

### 8.1.6 间歇调用和超时调用

JavaScript 是单线程语言，但它允许通过设置超时值和间歇时间值来调度代码在特定的时刻执行。前者是在指定的时间过后执行代码，而后者则是每隔指定的时间就执行一次代码。

超时调用需要使用 window 对象的 `setTimeout()`方法，它接受两个参数：要执行的代码和以毫秒表示的时间（即在执行代码前需要等待多少毫秒）。其中，第一个参数可以是一个包含 JavaScript 代码的字符串（就和在 `eval()`函数中使用的字符串一样），也可以是一个函数。例如，下面对 `setTimeout()`的两次调用都会在一秒钟后显示一个警告框。

```js
//不建议传递字符串！
setTimeout("alert('Hello world!') ", 1000);

//推荐的调用方式
setTimeout(function() {
  alert("Hello world!");
}, 1000);
```

第二个参数是一个表示等待多长时间的毫秒数，但经过该时间后指定的代码不一定会执行。JavaScript 是一个单线程序的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个 JavaScript 任务队列。这些任务会按照将它们添加到队列的顺序执行。 `setTimeout()`的第二个参数告诉 JavaScript 再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。

调用 `setTimeout()`之后，该方法会返回一个数值 ID，表示超时调用。这个超时调用 ID 是计划执行代码的唯一标识符，可以通过它来取消超时调用。要取消尚未执行的超时调用计划，可以调用`clearTimeout()`方法并将相应的超时调用 ID 作为参数传递给它

```js
//设置超时调用
var timeoutId = setTimeout(function() {
  alert("Hello world!");
}, 1000);

//注意：把它取消
clearTimeout(timeoutId);
```

间歇调用与超时调用类似，只不过它会按照指定的时间间隔重复执行代码，直至间歇调用被取消或者页面被卸载。设置间歇调用的方法是 `setInterval()`，它接受的参数与 `setTimeout()`相同：要执行的代码（字符串或函数）和每次执行之前需要等待的毫秒数。

```js
//不建议传递字符串！
setInterval ("alert('Hello world!') ", 10000);
//推荐的调用方式
setInterval (function() {
  alert("Hello world!");
}, 10000);
```

调用 setInterval()方法同样也会返回一个间歇调用 ID，该 ID 可用于在将来某个时刻取消间歇调用。要取消尚未执行的间歇调用，可以使用 clearInterval()方法并传入相应的间歇调用 ID。取消间歇调用的重要性要远远高于取消超时调用，因为在不加干涉的情况下，间歇调用将会一直执行到页面卸载。

```js
var num = 0;
var max = 10;
var intervalId = null;
function incrementNumber() {
  num++;
  //如果执行次数达到了 max 设定的值，则取消后续尚未执行的调用
  if (num == max) {
    clearInterval(intervalId);
    alert("Done");
  }
}
intervalId = setInterval(incrementNumber, 500);
```

在使用超时调用时，没有必要跟踪超时调用 ID，因为每次执行代码之后，如果不再设置另一次超时调用，调用就会自行停止。一般认为，使用超时调用来模拟间歇调用的是一种最佳模式。在开发环境下，很少使用真正的间歇调用，原因是后一个间歇调用可能会在前一个间歇调用结束之前启动。而像前面示例中那样使用超时调用，则完全可以避免这一点。所以，最好不要使用间歇调用。

```js
var num = 0;
var max = 10;
function incrementNumber() {
  num++;
  //如果执行次数未达到 max 设定的值，则设置另一次超时调用
  if (num < max) {
    setTimeout(incrementNumber, 500);
  } else {
    alert("Done");
  }
}
  setTimeout(incrementNumber, 500);
```

### 8.1.7 系统对话框

浏览器通过 `alert()`、 `confirm()`和 `prompt()`方法可以调用系统对话框向用户显示消息。系统对话框与在浏览器中显示的网页没有关系，也不包含 HTML。它们的外观由操作系统及（或）浏览器设置决定，而不是由 CSS 决定。此外，通过这几个方法打开的对话框都是同步和模态的。也就是说，显示这些对话框的时候代码会停止执行，而关掉这些对话框后代码又会恢复执行。

```js
if (confirm("Are you sure?")) {
  alert("I'm so glad you're sure! ");
} else {
  alert("I'm sorry to hear you're not sure. ");
}
```

最后一种对话框是通过调用 `prompt()`方法生成的，这是一个“提示”框，用于提示用户输入一些文本。提示框中除了显示 OK 和 Cancel 按钮之外，还会显示一个文本输入域，以供用户在其中输入内容。`prompt()`方法接受两个参数：要显示给用户的文本提示和文本输入域的默认值（可以是一个空字符串）。

```js
var result = prompt("What is your name? ", "");
if (result !== null) {
  alert("Welcome, " + result);
}
```

综上所述，这些系统对话框很适合向用户显示消息并请用户作出决定。由于不涉及 HTML、 CSS 或JavaScript，因此它们是增强 Web 应用程序的一种便捷方式。

还有两个可以通过 JavaScript 打开的对话框，即“查找”和“打印”。这两个对话框都是异步显示的，能够将控制权立即交还给脚本。这两个对话框与用户通过浏览器菜单的“查找”和“打印”命令打开的对话框相同。而在 JavaScript 中则可以像下面这样通过 window 对象的 `find()`和 `print()`方法打开它们。

```js
//显示“打印”对话框
window.print();
//显示“查找”对话框
window.find();
```

## 8.2 location对象 

location 是最有用的 BOM 对象之一，它提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能。事实上， location 对象是很特别的一个对象，因为它既是 window 对象的属性，也是document 对象的属性；换句话说， `window.location` 和 `document.location` 引用的是同一个对象。location 对象的用处不只表现在它保存着当前文档的信息，还表现在它将 URL 解析为独立的片段，让开发人员可以通过不同的属性访问这些片段。

下表列出了 location 对象的所有属性（注：省略了每个属性前面的 location 前缀）。

|  属性名  |         例子         |                                    说明                                     |
| -------- | -------------------- | --------------------------------------------------------------------------- |
| hash     | "#contents"          | 返回URL中的hash（#号后跟零或多个字符），如果URL中不包含散列，则返回空字符串 |
| host     | "www.wrox.com:80"    | 返回服务器名称和端口号（如果有）                                            |
| hostname | "www.wrox.com"       | 返回不带端口号的服务器名称                                                  |
| href     | "http:/www.wrox.com" | 返回当前加载页面的完整URL。而location对象的`toString()`方法也返回这个值     |
| pathname | "/WileyCDA/"         | 返回URL中的目录和（或）文件名                                               |
| port     | "8080"               | 返回URL中指定的端口号。如果URL中不包含端口号，则这个属性返回空字符串        |
| protocol | "http:"              | 返回页面使用的协议。通常是http:或https:                                     |
| search   | "?q=javascript"      | 返回URL的查询字符串。这个字符串以问号开头                                   |

### 8.2.1 查询字符串参数

尽管 `location.search` 返回从问号到 URL 末尾的所有内容，但却没有办法逐个访问其中的每个查询字符串参数。为此，可以像下面这样创建一个函数，用以解析查询字符串，然后返回包含所有参数的一个对象。

```js
function getQueryStringArgs(){
  //取得查询字符串并去掉开头的问号
  var qs = (location.search.length > 0 ? location.search.substring(1) : ""),
  //保存数据的对象
  args = {},
  //取得每一项
  items = qs.length ? qs.split("&") : [],
  item = null,
  name = null,
  value = null,
  //在 for 循环中使用
  i = 0,
  len = items.length;
  //逐个将每一项添加到 args 对象中
  for (i=0; i < len; i++){
  item = items[i].split("=");
  name = decodeURIComponent(item[0]);
  value = decodeURIComponent(item[1]);
  if (name.length) {
  args[name] = value;
  }
  }
  return args;
}
```

### 8.2.2 位置操作

使用 location 对象可以通过很多方式来改变浏览器的位置。首先，也是最常用的方式，就是使用`assign()`方法并为其传递一个 URL。这样，就可以立即打开新 URL 并在浏览器的历史记录中生成一条记录。如果是将 `location.href` 或 `window.location` 设置为一个 URL 值，也会以该值调用 `assign()`方法。

```js
location.assign("http://www.wrox.com");
// 等价于
window.location = "http://www.wrox.com";
location.href = "http://www.wrox.com";
```

另外，修改location 对象的其他属性也可以改变当前加载的页面。每次修改 location 的属性（hash 除外），页面都会以新 URL 重新加载。

```js
//假设初始 URL 为 http://www.wrox.com/WileyCDA/
//将 URL 修改为"http://www.wrox.com/WileyCDA/#section1"
location.hash = "#section1";
//将 URL 修改为"http://www.wrox.com/WileyCDA/?q=javascript"
location.search = "?q=javascript";
//将 URL 修改为"http://www.yahoo.com/WileyCDA/"
location.hostname = "www.yahoo.com";
//将 URL 修改为"http://www.yahoo.com/mydir/"
location.pathname = "mydir";
//将 URL 修改为"http://www.yahoo.com:8080/WileyCDA/"
location.port = 8080;
```

当通过上述任何一种方式修改 URL 之后，浏览器的历史记录中就会生成一条新记录，因此用户通过单击“后退”按钮都会导航到前一个页面。要禁用这种行为，可以使用 `replace()`方法。这个方法只接受一个参数，即要导航到的 URL；结果虽然会导致浏览器位置改变，但不会在历史记录中生成新记录。在调用 `replace()`方法之后，用户不能回到前一个页面。

```js
<!DOCTYPE html>
<html>
  <head>
    <title>You won't be able to get back here</title>
  </head>
  <body>
    <p>Enjoy this page for a second, because you won't be coming back here.</p>
    <script type="text/javascript">
      setTimeout(function () {
        location.replace("http://www.wrox.com/");
      }, 1000);
    </script>
  </body>
</html>
```

与位置有关的最后一个方法是 `reload()`，作用是重新加载当前显示的页面。如果调用 `reload()`时不传递任何参数，页面就会以最有效的方式重新加载。也就是说，如果页面自上次请求以来并没有改变过，页面就会从浏览器缓存中重新加载。如果要强制从服务器重新加载，则需要像下面这样为该方法传递参数 true。

```js
location.reload(); //重新加载（有可能从缓存中加载）
location.reload(true); //重新加载（从服务器重新加载）
```

## 8.3 navigator对象

检测浏览器中是否安装了特定的插件是一种最常见的检测例程。可以使用 plugins 数组来达到目标，一般来说 name 属性会包含检测插件所需的信息，但有时候需要循环迭代并比较。典型的做法是针对每个插件分别创建检测函数，而不是使用前面通用的检测方法。

两个方法，可以让一个站点指明它可以处理特定类型的信息，它们是 registerContentHandler () 和 registerProtoolHandel ()。

## 8.4 screen对象 

screen 对象基本上只用来表明客户端的能力，其中包括浏览器窗口外部的显示器的信息，如像素宽度和高度等。

## 8.5 history对象

History 对象保存着用户上网的历史记录，从窗口被打开的那一刻算起，每个特定的 window 对象都与自己的 History 对象关联，开发人员无法得知用户浏览过的 URL 但是可以实现后退前进功能。使用 go () 方法可以在用户的历史记录中任意跳转，可以向后也可以向前，这个方法接受一个参数，表示向后或向前跳转的页面数的一个整数值。也可以使用 go () 方法传递一个字符串参数，此时浏览器会跳转到历史记录中包含该字符串的第一个位置——可能后退，也可能前进，具体要看哪个位置最近。还可以使用两个简写方法 back () 和 forward () 来代替 go () 代替后退和前进。除了上述几个方法外，history 对象还有一个l ength 属性，保存着历史记录的数量。如果等于 0，那么就是加载到窗口、标签页或框架中的第一个页面。

8.6　小结

# 第9章 客户端检测

每一种浏览器都有着各自的缺点，开发人员要么采取迁就各方的“最小公分母”策略，要么就得利用各种客户端检测方法，来突破或者规避种种局限性。

## 9.1 能力检测 

最常用也是最为人们广泛接受的客户端检测形式是能力检测，又称特性检测。先检测达成目的的最常用的特性，然后测试实际要用到的特性。

## 9.2 怪癖检测

怪癖检测的目标是识别浏览器的特殊行为，想要知道浏览器存在什么缺陷（bug）。

## 9.3 用户代理检测

用户代理检测通过检测用户代理字符串来确定实际使用的浏览器，在服务端通过用户代理字符串来确定用户使用的浏览器是常见并且广为接受的做法，但是在客户端它的优先级在能力检测和（或）怪癖检测之后。识别呈现引擎、识别JavaScript 引擎、识别平台、识别 windows 操作系统、识别移动设备，构成了用户代理字符串检测脚本的内容。这种方法对用户代理字符串具有很强的依赖性，是客户端检测的最后一种方案。

9.4 小结

# 第10章 DOM　

DOM是文档对象模型，是针对HTML和XML文档的一个API应用程序编程接口，描述了一个层次化的节点树，允许开发人员添加、移除和修改页面的某一部分。现在它已经成为表现和操作页面标记的真正的跨平台、语言中立的方式。

## 10.1 节点层次 

节点分为几种不同的类型，每种类型分别表示文档中不同的信息以（或）标记。每个节点都拥有各自的特点、数据和方法，另外也与其他节点存在某种关系。节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构。

```html
<html>
  <head>
    <title>Sample Page</title>
  </head>
  <body>
    <p>Hello World!</p>
  </body>
</html>
```

文档节点是每个文档的根节点。在这个例子中，文档节点只有一个子节点，即`<html>`元素，我们称之为文档元素。文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。在 HTML 页面中，文档元素始终都是`<html>`元素。在 XML 中，没有预定义的元素，因此任何元素都可能成为文档元素。

每一段标记都可以通过树中的一个节点来表示： HTML 元素通过元素节点表示，特性（attribute）通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。总共有 12 种节点类型，这些类型都继承自一个基类型。

Node类型。DOM1级定义的一个Node接口，该接口将由DOM衷的所有节点类型实现，这个接口在JavaScript中是作为Node类型实现的。JavaScript中的所有节点类型都继承自Node类型，因此所有节点类型都共享者相同的基本属性和方法。

每个节点都有一个nodeType，用于表明节点的类型，节点类型由定义的12个数值常量表示。由于IE没有公开Node类型的构造函数，为了确保跨浏览器兼容，最好将nodeType属性与数字值进行比较。

- Node.ELEMENT_NODE(1)；
- Node.ATTRIBUTE_NODE(2)；
- Node.TEXT_NODE(3)；
- Node.CDATA_SECTION_NODE(4)；
- Node.ENTITY_REFERENCE_NODE(5)；
- Node.ENTITY_NODE(6)；
- Node.PROCESSING_INSTRUCTION_NODE(7)；
- Node.COMMENT_NODE(8)；
- Node.DOCUMENT_NODE(9)；
- Node.DOCUMENT_TYPE_NODE(10)；
- Node.DOCUMENT_FRAGMENT_NODE(11)；
- Node.NOTATION_NODE(12)。

nodeName 和 nodeValue 属性。

要了解节点的具体信息，可以使用 nodeName 和 nodeValue 两个属性。对于元素节点， nodeName 中保存的始终都是元素的标签名，而 nodeValue 的值则始终为 null。

```js
if (someNode.nodeType == 1){
  value = someNode.nodeName; //nodeName 的值是元素的标签名
}
```

节点关系。

文档中所有的节点之间都存在这样或那样的关系。每个节点都有一个 childNodes 属性，其中保存着一个 NOdeList 数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点。但是它不是 Array 的实例，它实际上是基于 DOM 结构动态执行查询的结果，DOM 结构的变化能够自动反应在 NodeList 对象中，因此 NodeList 是有生命、有呼吸的对象，而不是一张快照。如果要访问保存在 NodeList 中的节点，可以通过方括号，也可以使用`item()`方法。

每个节点都有一个 parentNode 属性，该属性指向文档数中的父结点。而`hasChildrenNodes()`在节点包含一或多个子节点的情况下返回 true，这是比查询 childNodes 列表的length属性更简单的方法。所有节点都有的最后一个属性是 ownerDocument，该属性指向表示整个文档的文档节点。通过这个属性，可以不必在节点层次中通过层层回溯到达顶端，而是可以直接访问文档节点。

操作节点，最常用的方法是appendChildren()，用于向childNodes列表的末尾添加一个节点，更新完成后该方法返回新增的节点，如果已经存在，那么就会转移到新位置。另外inserBefore()方法，是把节点放在childNodes列表中的某个特定的位置上，接受两个参数：要插入的节点和作为参照的节点。如果参照节点是null，则插入最后。replaceChild()方法替换节点，并返回移除的节点。removeChild()方法只是移除而非替换节点，只接受一个参数。这两个方法移除的节点仍然为文档所有，只不过在文档中已经没有了自己的位置。

其它方法，cloneNode()用于创建调用这个方法的节点的一个完全相同的副本，只接受一个是否执行深复制的布尔值参数，深复制也就是复制节点以及整个子节点树，浅复制也就只复制节点本身。复制后的副本属于文档所有，但是还没有自己的位置。最后一个方法是normalize()方法，这个方法唯一的作用Iushi处理文档树中的文本节点。

Document类型。JavaScript通过Document表示文档，即document为文档对象。在浏览器中document对象是HTMLDocument的一个实例，表示整个HTML页面；同时也是window对象的一个属性，可以作为全局对象来访问。规定的Document节点的子节点可以是DocumentType、Element、ProcessingInstruction或Comment，但还有两个内置的访问其子节点的快捷方式：documentElement属性（指向HTML页面的`<html>`元素）、childNode。作为HTMLDocument的实例，document对象还有一个body属性，直接指向`<body>`元素。

作为HTMLDocument的一个实例，document对象还有一些标准的Document对象所没有的属性，title属性包含着`<title>`元素中的文本，显示在浏览器窗口的标题栏或标签页上。还有三个对网页的请求有关的属性：URL、domain和referrer，第一个属性中包含页面完整的URL、第二个属性只包含页面的域名，而最后一个属性则保存着链接到当前页面的那个页面的URL，没有来源页面则包含空字符串。所有这些信息都存在于请求的HTTP头部，只不过是通过这些属性让我们能够在JavaScript中访问它们。

查找元素。Document类型为取得元素的操作提供了两个方法：getElementById()和getElementByTagName()，前者接收元素的ID的参数，后者接收要取得元素的标签名，返回的是包含零或多个元素的NodeList。在HTML文档中，这个方法会返回一个HTMLCollection对象，作为一个“动态”集合，该对象与NodeList非常类似。另外HTMLCollection对象还有个namedItem()，使用这个方法可以通过元素的name特性取得集合中的项。第三个方法，也是只有HTMLDocument类型才有的方法，是getElementByName()，这个方法会返回带有给定name特性的所有元素。

document对象还有一些特殊的集合，这些集合都是HTMLCollection对象，为访问文档常用的部分提供了快捷方式，包括anchors、applets、forms、images、links，集合中的项也会随着当前文档内容的更新而更新。

由于DOM分为多个级别，也包含多个部分，因此检测浏览器实现了DOM的那些部分就十分必要了。document.implementation属性就是为此提供相应信息和功能的对象，与浏览器对DOM的实现直接对应。DOM1级只为它规定了一个方法，即hasFeature()，这个方法接受两个参数：要检测的DOM功能的名称及版本号。

文档写入。将输出流写入网页中的能力体现在下列4个方法：write().writenln()、open()和close()。前两个方法接受一个字符串参数，即要写入到输入流中的文本，第一个原样写入，第二个会在字符串的末尾添加一个换行符。还可以使用这两个方法动态地包含外部资源。

Element类型。Element类型用于表现XML或HTML元素，提供了对元素标签名、子节点及特性的访问。要访问元素的标签名，可以使用nodeName属性，也可以使用tagName属性，在HTML中标签名始终都以全部大写表示。所有HTML元素都由HTMLElement类型标识，不是直接通过这个类型，也是通过它的子类型来表示。HTMLElement类型直接继承Element并添加了一些属性，例如id、title、lang、dir、classname等，但这些属性的修改不是一定会在页面中直观地表现出来。

取得特性。每个元素都有一或多个特性，这些特性的用途是给出相应元素或其内容的附加信息，操作特性的DOM方法主要有三个，分别是getAttribute()、setAttribute()和removeAttribute()，通过第一个方法可以取得存在或自定义特性的值，但是注意特性的名称是不区分大小写的。有两类特殊的特性，它们虽然有对应的属性名，但属性的值与通过getAttribute()返回的值并不相同，第一类就是style，用于通过CSS为元素指定样式，前者是对象，后者是返回CSS文本；第二类是onclick这样的事件处理程序，前者是JavaScript函数，而后者返回的是相应代码的字符串。

attributes属性。Element类型是使用attributes属性的唯一一个DOM节点类型。这个属性包含一个NamedNodeMap，与NodeList类似，也是一个“动态”的集合。一般attributes属性可以用来遍历元素的特性。

创建元素。使用document.creatElement()方法可以创建新元素。这个方法只接受一个参数，即要创建元素的标签名。它同时也为新元素设置了ownerDocument属性，此时可以操作元素的特性，为它添加更多子节点。

元素可以有任意数目的子节点和后代节点，元素的childNodes属性中包含了它的所有子节点，这些子节点有可能是元素、文本节点、注释或处理指令。如果元素之间有空白符，也算做文本节点，因此执行某项操作以前，通常都要先检查一下nodeType属性。

Text类型。文本节点由Text类型标识，包含的是可以按照自勉解释得纯文本内容。纯文本中可以包含转义后的HTML字符，但不能包含HTML代码。可以使用Document.createTextNode()创建新文本节点，这个方法接受一个参数，即要插入节点的文本，与设置已有文本节点的值一样（使用nodeValue属性），作为参数的文本也将按照HTML或XML的格式进行编码。一个能够将相邻文本节点合并的方法normalize()，结果节点的nodeValue等于将合并前每个文本节点的nodeValue值拼接起来的值。浏览器在解析文档时永远不会创建相邻的文本节点，合并的情况只会作为执行DOM操作的结果出现。Text类型提供了一个作用与合并节点相反的方法：splitText()，这个方法会将一个文本节点分成两个文本节点。

Comment类型。注释在DOM中是通过Comment类型来表示的。这个类型和Text类型继承自相同的基类，因此它拥有除splitText()之外的所有字符串操作方法。

CDATASection类型。只针对基于XML的文档，表示的是CDATA区域。

DocumentType类型，包含着与文档的doctype有关的所有信息。在DOM1级中，DocumentType对象不能动态创建，只能通过解析文档代码的方式来创建。DocumentFragment类型，在文档中没有对应的标记，是一种“轻量级”的文档，可以包含和控制节点，但不会像完整的文档那样占用额外的资源，执会作为一个“仓库”使用。

Attr类型。元素的特性在DOM中以Attr类型来表示，在所有浏览器中都可以访问Attr类型的构造函数和原型。从技术角度讲，特性就是存在于元素的attributes属性中的节点。尽管它们也是节点，但特性从来不被认为是DOM文档树的一部分，开发人员最常使用的是getAttribute()、setAttribute()和removeAttribute()方法，很少直接引用特性节点。

## 10.2 DOM操作技术 

动态脚本。使用`<script>`元素可以向页面中插入JavaScript代码，一种方式是通过其src特性包含外部文件，另一种方式就是用这个元素本身来包含代码。动态脚本，指的是在页面加载时不存在，但将来的某一时刻通过修改DOM动态添加的脚本，一般有两种方式，插入外部文件和直接插入JavaScript代码。

动态样式。动态样式是指在页面刚加载时不存在的样式，动态样式是在页面加载完成后动态添加到页面中的，能够把CSS样式包含到HTML页面中的元素有两个。其中`<link>`元素用于包含来自外部的文件，而`<style>`元素用于指定嵌入的样式。

动态表格。为了方便构建表格，HTML DOM还为`<table>`、`<tbody>`和`<tr>`元素添加了一些属性和方法。例如caption、tBodies、tFoot、tHead、rows、`creatTHead()`、`creatTFoot()`等。

使用NodeList时应该尽量避免访问的次数，因为每次访问，都会运行一次基于文档的查询。其中NodeList、NamedNodeMap、HTMLCollection三个集合都是“动态”的，每次文档结构发生变化时，它们都会得到更新。

10.3　小结　

# 第11章 DOM扩展

对DOM的两个主要的扩展是SelectorsAPI和HTML5，这两个扩展都来源自开发社区。还有一个Element Traversal规范，主要用于元素遍历，另外还有一些专有扩展。

## 11.1 选择符API 

Selectors API Level 1的核心就是两个方法：`querySelector()`和`querySelectorAll()`，通过CSS选择符查询DOM文档取得元素的引用。如果接受一个CSS选择符，第一个方法会返回与该模式匹配的第一个元素，没有找到则返回null；第二个方法返回的是一个NOdeList的实例，没有找到则NodeList为空。要取得返回的NOdeList中的每一个元素，可以使用item方法，也可以使用方括号语法。Selectors API Level 2规范为Element类型新增了一个方法`matchSelector()`方法，其接收一个参数CSS选择符，吐过调用元素与该选择符匹配，返回true，否则返回false。

## 11.2 元素遍历 

为了弥补IE9及之前版本对于元素间的空格不会返回文本节点，新定义了一组属性，只用于返回相应的子元素但不包括文本节点和注释，因此是元素办。例如firstElementChild指向第一个元素，是firstChild的元素版。因此遍历元素更加简洁，不用测试元素的nodeType值。

## 11.3 HTML5 

与类相关的扩充。可以通过document对象以及所有HTML元素调用getElementByClassName()方法，该方法接收一个参数，即一个包含一或多个类名的字符串，返回带有指定类的所有元素的NOdeList，传入多个类名时，类名的先后顺序不重要。HTML5新增了一种操作类名的方式，可以让操作更简单也更安全，那就是为所有元素添加classList属性。这个classList属性是新集合类型DOMTokenList的实例，这个新类型还定义如下方法：add()、contains()、remove()、toggle()。有了classList属性，不用完全重写元素的class属性。

焦点管理。HTML5也添加了辅助管理DOM焦点的功能，首先是document.activeElement属性，这个属性始终会引用DOM中当前获得了焦点的元素，默认情况下文档刚刚加载完成时保存的是document.body元素的引用。另外就是新增了Document.hasFocus()方法，用于确定文档是否获得了焦点，从而用到用户是不是正在与页面交互。

HTMLDocument的变化。readyState属性有loading和complete两个可能的值，通过它来实现指示文档已经加载完成的指示器。cinpatMOde属性就是为了告诉开发人员浏览器采用了哪种渲染模式。head属性，引用文档的`<head>`元素。

字符集属性。其中charset属性表示文档中实际使用的字符集，也可以用来指定新字符集。默认情况下，这个属性的值是“UTF-16”，但可以通过`<meta>`元素，响应头部或直接设置charset属性修改这个值。另一个属性是defaultCharset，表示根据默认浏览器以及操作系统的设置，当前文档默认的字符集应该是什么。

自定义数据属性。HTML5规定可以为元素添加非标准的属性，但要添加前缀data-，目的是为元素提供与渲染无关的信息，或者提供语义信息，并且可以通过元素dataset属性来访问自定义属性的值。

插入标记的技术，直接插入HTML字符串不仅简单，速度也更快。在读模式下，innerHTML属性返回与调用元素的所有子节点，包括元素、注释和文本节点对应的HTML标记。在写模式下，它会根据指定的值创建新的DOM树，然后用这个DOM树完全替换调用元素原先的所有子节点。但是，不同浏览器返回的文本格式会有所不同。为innerHTML设置的包含HTML的字符串值与解析后innerHTML的值大不相同。在大多数浏览器中，通过innerHTML插入`<script>`元素并不会执行其中的脚本。

outerHTML属性。在读模式下，返回调用它的元素以及所有子节点的HTML标签，在写模式下，outerHTML会根据指定的HTML字符串创建新的DOM子树，然后用这个DOM子树完全替换调用元素。

方法。它接收两个参数，插入位置和要插入的HTML文本。第一个参数必须是下列值之一：beforebegin、afterbegin、beforeend、afterend，这些值必须是小写形式。

scrollIntoView()方法，可以在所有HTML元素上调用，通过滚动浏览器窗口或某个容器元素，调用元素就可以出现在窗口中。

## 11.4 专有扩展 

浏览器开发商如果发现某项功能有缺失，会一如既往地向DOM中添加专有扩展，以弥补功能上的不足。

11.5　小结　

# 第12章 DOM2和DOM3　

DOM1级主要定义的是HTML和XML文档的底层结构，DOM2和DOM3级则在这个结构级分为许多的模块，模块之间具有具有某种关联，分别描述了DOM的某个非常具体的子集。这些模块如下，DOM2级核心、DOM2级视图、DOM2级事件、DOM2级样式、DOM2级遍历和范围、DOM2级HTML这些模块。

## 12.1 DOM变化 

针对XML命名空间的变化。其它方面的变化，DocumentType类型的变化，Document类型的变化、NOde类型的变化、框架的变化。

## 12.2 样式 

任何支持style特性的HTML元素在JavaScript中都有一个对应的style属性。这个style对象是CSSStyleDeclaration的实例，包含着通过HTML的style特性指定的所有样式信息，但不包含与外部样式表或嵌入样式表经层叠而来的样式。对于使用短划线的CSS属性名，必须将其转换成驼峰大小写的形式，才能通过JavaScript来访问。由于在JavaScript中float是保留字，因此不能作为属性名，所以改成cssFloat。同时还定义了一些属性和方法，可以修改样式，例如cssText属性可以访问style特性中的CSS代码，这是为元素应用多项变化最快捷的方式，因为可以一次性地应用所有变化。设置length属性的木笔，就是将其与item()方法配套使用，以便迭代在元素中定义的CSS属性，同时可以使用`getPropertyValue()`和`getPropertyCSSValue()`方法获得属性值。前者获得字符串，后者获得包含两个属性的CSSValue对象。计算的样可以使用getComputedStyle()方法，这个方法接受两个参数：要取得计算样式的元素和一个伪元素字符串。如果不需要伪元素信息，第二个参数可以是null，返回的是一个CSSStyleDeclaration对象（与style属性的类型相同），其中包含当前元素的所有计算的样式，所有计算的样式都是只读的。

操作样式表。CSSStyleSheet类型表示的是样式表，包括通过`<link>`元素包含的样式表和在`<style>`元素中定义的样式表。应用文档的所有样式表是通过document.styleSheets集合来表示，通过这个集合的length属性可以获知文档中样式表的数量，而通过方括号语法或item()方法可以访问每个样式表。不同浏览器的document.styleSheets返回的样式表也不同。也可以直接通过`<link>`或`<style>`元素来取得CSSStyleSheet对象。

CSS规则。CSSRule对象表示样式表中的每一条规则，是一个供其他类型继承的基类型，最常见的就是表示样式信息的CSSStyleRule类型。注意的是，以这种方式修改规则会影响页面中适用于该规则的所有元素。创建规则，要向现有样式表添加新规则，需要使用insertRule()方法，这个方法接受两个参数：规则文本和表示在哪里插入规则的索引。删除规则，从样式表中删除规则的方法是deleteRule()，这个方法接受一个参数：要删除的规则的位置。

元素大小。不属于DOM2级样式规范，但却与HTML元素的样式息息相关。偏移量，包括元素在屏幕上占用的所有可见空间，元素的可见大小由其高度、宽度决定，包括所有内边距、滚动条和边框大小，不包括外边距。其中，offsetLeft和offsetTop属性与包含元素有关，包含元素的引用在offsetParent属性中。要想知道某个元素在页面上的偏移量，将这个元素的offsetLeft和offsetTop与其offsetParent的相同属性相加，如何循环直至根元素，就可以得到一个基本准确的值。客户区大小，指的是元素内容以及其内边距所占据的空间大小。属性有clientWidth和ClientHeight表示左右宽度和上下高度。偏移量和客户区大小都是只读的，每次访问后都要重新计算。滚动大小，指的是包含滚动内容的元素的大小，有些元素即使没有执行任何代码也能自动地添加滚动条，但有些元素需要通过CSS的overflow属性进行设置才能滚动。scrollWidth和scrollHeight主要用于确定元素内容的实际大小。通过scrollLeft和scrollTop属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置。当元素被垂直滚动时scrollTop的值会大于0并且等于元素上方不可见内容的像素高度。确定元素大小，getBoundingClientRect()方法会返回一个矩形对象，包含Left、top、right和bottom这些属性给出了元素在页面中相对于视口的位置，浏览器的实现稍有不同。

## 12.3 遍历 

“DOM2级遍历和范围”模块定义了两个用于辅助完成顺序遍历DOM结构的类型：NodeIterator和TreeWalker，这两个类型能够基于给定的起点对DOM结构执行深度优先的遍历操作。NodeIterator类型是两者中比较简单的一个，可以使用document.creatNodeIterator()方法创建它的新实例，这个方法接收4个参数，通过filter参数来指定自定义的NodeFilter对象，或者指定一个功能类似节点过滤器的函数。每个NodeFilter对象只有一个方法，即acceptNode()方法。NodeIterator类型的两个主要方法是nextNode()和previousNode()，在深度优先的DOM子树遍历中，前者表示向前前进一步，后者用于向后后退一步。TreeWalker是NOdeIterator的一个更高级的版本，除了包括nextNode()和previousNode()在内的相同的功能之外，这个类型还提供了下列用于在不同方向上遍历DOM结构的方法：parentNode()、firstChild()、lastChild()、nextSibling()、previousSibling()，创建TreeWalker对象要使用document.createTreeWalker()方法，这个方法也是接受和上面一个方法相同的四个参数。TreeWalker类型还有一个属性，名为currentNode，表示任何遍历方法在上一次遍历中返回的节点。

## 12.4 范围

“DOM2级遍历和范围”模块定义了“范围”接口，通过范围可以选择文档中的一个区域，而不必考虑节点的界限。与节点类似，新创建的范围也直接与创建它的文档关联在一起，不能用于其他文档。每个范围由一个Range类型的实例表示，这个实例拥有很多属性和方法。

使用DOM范围实现简单选择。要使用范围来选择文档中的一部分，最简的方式就是使用selectNode()或selectNodeContents()方法，这两个方法都接受一个参数，即一个DOM节点，然后使用该节点中的信息来填充范围。第一个方法选择整个节点，包括子节点；第二个方法则只选择节点的子节点。

用DOM范围实现复杂选择。要创建复杂的范围就得使用setStart()和setEnd()方法，这两个方法都接受两个参数：一个参照点和一个偏移量值。

操作DOM范围中的内容。在创建范围时，内部会为这个范围创建一个文档片段，范围所属的全部节点都被添加到了这个文档片段中，这个片段的所有节点都只是指向文档中相应节点的指针，对范围的内容进行操作的方法有，第一个是deleteContents()方法，能够从文档中删除范围所包含的内容。第二个是extractContents()也会从文档中移除范围选取，并且返回范围的文档片段。第三种方法是cloneContents()创建范围对象的一个副本，然后再文档的其他地方插入该副本。

插入DOM范围中的内容。利用范围，可以删除或复制内容，使用insertNode()方法可以向范围选取的开始处插入一个节点。使用surroundContents()方法可以环绕范围插入内容。

折叠DOM范围。所谓折叠范围，就是指范围中为选择文档的任何部分，可以用文本框来描述折叠范围的过程。使用collapse()方法来折叠范围，这个方法接受一个参数，一个布尔值，表示要折叠到范围的哪一段。

比较DOM范围。在有多个范围的情况下，可以使用compareBoundaryPoints()方法来确定这些范围是否有公共的边界。这个方法接受两个参数：表示比较方式的常量值和要比较的范围。如果第一个范围中的点位于第二个范围中的点之前，返回-1；相等返回0；位于之后则返回1。

复制DOM范围。可以使用cloneRange()方法复制范围，这个方法会创建调用它的范围的一个副本。清理DOM范围。在使用完范围之后，最好是调用detach()方法，以便从创建范围的文档中分离出该范围。调用detach()之后，就可以放心地接触对范围的引用，从而让垃圾回收机制回收其内存了。

12.5　小结　

# 第13章 事件　

JavaScript与HTML之间的交互式通过事件实现的。事件，就是文档或浏览器窗口中发生的一些特定的交互瞬间。可以使用侦听器或者处理程序来预订事件，以便事件发生时执行相应的代码。这种在传统软件工程中被称为观察员模式的模型。

## 13.1 事件流 

事件流描述的是从页面中接收事件的顺序。IE的事件流叫做事件冒泡，即事件开始时由最具体的元素接收没然后逐级向上传播到较为不具体的节点。所有现代浏览器都支持时间冒泡，但在具体实现上还是有一些差别。Netscape Communicator团队提出的另一种事件流叫做事件捕获。事件捕获的思想是不太具体的节点应该更早接到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件达到预定目标之前捕获它。

“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。在DOM事件流中，实际的目标在捕获阶段不会接收到事件，事件在处于目标阶段中发生，然后再事件处理中被看成冒泡阶段的一部分。

## 13.2 事件处理程序

事件就是用户或浏览器自身执行的某种动作，而响应某个事件的函数就叫做事件程序程序或者时间侦听器，事件处理程序的名字以“on”开头，为事件指定处理程序的方式有好几种。

HTML事件处理程序。某个元素支持的每种事件，都可以使用一个与相应事件处理程序同名的HTML特性来指定。例如通过指定onclick特性并将一些JavaScript代码作为它的值，JavaScript代码不能使用未经转义的HTML语法字串。在HTML中定义的事件处理程序可以包含要执行的具体动作，也可以调用在页面其它地方定义的脚本，后者会创建一个封装元素属性值的函数，有一个局部变量event表示事件对象。在函数内部，this值等于事件的目标元素，可以向访问局部变量一样访问document以及该元素本身的成员，还可以使用with来扩展作用域。在HTML中指定事件处理程序有三个缺点，一是在HTML元素出现时就立刻触发相应的事件，但当时的环境程序程序有可能尚不具备执行条件，为此很多GTML事件处理程序都会被封装在一个try-catch块中，以便错误不会浮出水面。二是，这样的扩展事件处理程序的作用域链在不同浏览器中会导致不同结果。三是，HTML和JavaScript代码紧密耦合，不利于中途更换事件处理程序。

DOM0级时间处理程序。通过JavaScript指定事件处理程序的传统方式，就是将一个函数赋值给一个事件处理程序属性。要使用JavaScript指定事件处理程序，首先必须取得一个要操作的对象的引用，而每个元素都有自己的事件处理属性，这些属性通常全部小写，最后将这种属性的值设置为一个函数，就可以指定事件处理程序。使用DOM0级方法指定的事件处理程序被认为是元素的方法，这时候的事件处理程序是在元素的作用域中运行的。以this可以访问元素的任何属性和方法，这样的方式添加的事件处理程序会在事件流的冒泡阶段被处理。也可以通过将事件处理程序属性的值设置为null来删除通过DOM0级方法指定的事件处理程序。

DOM2级事件处理程序。用于处理指定和删除事件处理程序的操作：addEventListener()和removeEventListener()，所有的DOM节点中都包含这两个方法，并且接受三个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值，如果布尔值为true表示在捕获阶段调用事件处理程序，否则在冒泡阶段调用事件处理程序，一般默认在冒泡阶段调用，这样可以最大限度地兼容各种浏览器。使用DOM2级方法添加事件处理程序的主要好处是可以添加多个事件处理程序。通过addEventListener()添加的事件处理程序只能使用removeEventListener()来移除，移除时传入的参数与添加处理程序时使用的参数相同，这也意味着通过addEventListener()添加匿名函数的事件将无法移除。IE实现了与DOM众类似的两个方法：attachEvent()和detachEvent()方法。

## 13.3 事件对象 

在触发DOM上的某个事件时，会产生一个事件对象event，这个对象中包含着所有与事件有关的信息，包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。event对象包含与创建它的特定事件有关的属性和方法，触发的事件类型不一样，可用的属性和方法也不一样。在事件处理程序内部，对象this始终等于currentTarget的值，而target则只包含事件的实际目标。在需要通过一个函数处理多个事件时，可以使用type属性，从而检测事件的类型并且执行相应的操作。要阻止特定事件的默认行为，可以使用preventDefault()方法。另外，stopPropagation()方法用于立即停止事件在DOM层次中的传播，即取消进一步的事件捕获或冒泡。事件对象的eventPhase属性，可以用来确定事件当前正位于事件流的哪个阶段，捕获阶段为1，处于目标对象上为2，冒泡阶段等于3。IE中的事件对象event有几种不同的方式，取决于指定事件处理程序的方法。在使用DOM0级方法添加事件处理程序时，event对象作为window对象的一个属性存在。如果是通过HTML特性指定的事件处理程序，那么可以通过名为event的变量来访问event对象。如果事件处理程序是使用attachEvent()添加的，那么也会有一个event对象作为参数被传入事件处理程序函数中。其中在event对象的属性和方法中，srcElement相当于target，表示事件的目标，因为事件处理程序的作用域是根据指定它的方式来确定的，所以不能认为this会始终等于事件目标，所以srcElement比较保险。当returnValue属性为false取消给定事件的默认行为。通过在onclick事件处理程序中将canceBubble设置为true，就可阻止事件通过冒泡向上触发。

## 13.4 事件类型

“DOM3级事件”规定了以下几类事件：UI事件、焦点事件、鼠标事件、滚轮事件、文本事件、键盘事件、合成事件、变动事件、变动名称事件。

### 13.4.1 UI事件。

UI事件指的是那些不一定与用户操作有关的事件。除了DOMActivate之外，其他事件在DOM2级事件中都归为HTML事件。

- load事件：当页面完全加载后，就会触发window上面的load事件，第一种使用方式是通过JavaScript来指定事件处理程序，作用于window，第二种方式是在`<body>`元素添加一个onload特性。图像上面也可以触发load事件。
- unload事件：这个事件在文档被完全卸载后触发，只要用户从一个页面切换到另一个页面。
- resize事件：当浏览器窗口被调整到一个新的高度或宽度时触发。scroll事件：虽然是在window对象上发生，但它实际表示的则是页面中相应元素的变化。

### 13.4.2 焦点事件。

焦点事件会在页面元素获得或失去焦点时触发。利用这些事件并与`document.hasFocus()`方法及`document.activeElement`属性配合，可以知晓用户在页面上的行踪。

- blur表示失去焦点时触发
- focus表示获得焦点时触发。

### 13.4.3 鼠标与滚轮事件。

鼠标事件是Web开发中最常用的一类事件，主要定义了9个鼠标事件：点击`click`、双击`dbclick`、按下任意鼠标按钮`mousedown`、光标首次进入范围`mouseenter`、光标首次移出范围`mouseleave`、光标在内部移动`mousemove`、鼠标离开元素`mouseout`、鼠标进入元素`mouseover`、释放鼠标按钮`mouseup`。

除了`mouseenter`和`mouseleave`，所有鼠标事件都会冒泡，也可以被取消，而取消鼠标事件将会影响浏览器的默认行为。

鼠标事件中还有一类滚轮事件，一个mousewheel事件跟踪鼠标滚轮，类似于Mac的触控板。客户区坐标位置。

鼠标事件都是在浏览器视口中的特定位置上发生的，这个位置信息保存在事件对象的clientX和clientY属性中。

页面坐标位置。通过客户区坐标能够知道鼠标是在视口中什么位置发生的，而页面坐标通过事件对象的pageX和pageY属性，能告诉你事件时在页面中的什么位置发生的。

屏幕坐标位置。鼠标事件发生时，不仅会有相对于浏览器窗口的位置，还有一个相对于整个电脑屏幕的位置，而通过screenX和screenY属性就可以确定鼠标事件发生时鼠标指针相对于整个屏幕的坐标信息。

修改键。在按下鼠标时键盘上的某些键也可以影响到所要采取的操作，这些修改建就是Shift、Ctrl、Alt和Meta（windows系统是windows，苹果电脑是Cmd），并且规定4个属性来表示这些修改建的形态：shiftKey、ctrlKey、altKey、metaKey，如果按下则表示为true，否则为false。

相关元素。在发生mouseover和mouseout事件时，事件的主目标分别是获得光标的元素、失去光标的元素，相关元素则相反。DOM通过event对象的relatedTarget属性提供了相关元素的信息。这个属性只对于mouseover和mouseout事件才包含值，对于其他事件，这个属性的值是null。mousedown和mouseup时间的event对象存在一个button的属性，表示按下或释放的按钮，属性值有三个，0表示主鼠标按钮、1表示中间的鼠标按钮、2表示次鼠标按钮。常规的设置中，主鼠标按钮就是鼠标左键。

更多的事件信息，“DOM2级事件”规范在event对象中还提供了detail属性，用于给出有关事件的更多信息。鼠标滚轮事件。在垂直方向上滚动页面时，就会触发mousewheel时间，可以在任何元素上面触发，最终冒泡到document或window，对应的event对象包含鼠标事件的所有标准信息外，还包含一个特殊的wheelDelta属性，当向前滚动时它是120的倍数，向后滚动时它是-120的倍数。触摸设备。不支持dbclick事件，轻击可点击元素会触发mousemove事件。mousemove事件也会触发mouseover和mouseout事件。两个手指放在屏幕上且页面随手移动而滚动时会触发mousewheel事件和scroll事件。无障碍性问题。可以通过键盘上的回车键来触发click时间，但其他鼠标事件却无法通过键盘来触发。

### 13.4.4 键盘与文本事件。

有三个键盘事件
- keydown：当用户按下键盘上的任意键时触发，而且如果按住不放，会重复触发此事件
- keypress：当用户按下键盘上的字符键时触发，而且如果按住不放，会重复触发此事件。按下Esc键也会触发这个事件
- keyup：当用户释放键盘上的键时触发。

只有一个文本事件：textInput，这个事件时对keypress的补充，用意是在将文本显示给用户之前更容易拦截文本。键盘事件与鼠标事件一样，都支持相同的修改键。在发生keydown和keyup事件时，event对象的keyCode属性中会包含一个代码，与键盘上一个特定的键对应，对数字字母字符键，keyCode属性的值与ASCII码中对应小写字母或数字的编码相同。发生keypress事件意味着按下的键会影响到屏幕中文本的显示。多数浏览器的event对象都支持一个charCode属性，这个属性只有在发生keypress事件时才包含值，而且这个值是按下那个键所代表字符的ASCII码。

DOM3级事件中的键盘事件，不再包含charCode属性，而是包含两个新属性：key和char。DOM3级事件还添加了一个名为location的属性，这是一个数值，表示按下了什么位置上的键。最后是给event对象添加了getModifierState()方法，接收一个参数，是等于Shift、Control、AltGraph或Meta的字符串，表示要检测的修改键。如果处于被按下状态则返回true布尔值。“DOM3级事件”规范中引入了一个新事件，名叫textInput，当用户在编辑区域中输入字符时，就会触发这个事件，它的event对象中还包含一个data属性，这个属性的值就是用户输入的字符，event对象上还有一个inputMethod属性，表示把文本输入到文本框中的方式。

### 13.4.5 复合事件。

复合事件时DOM3级事件中新添加的一类事件，用于处理IME的输入序列。IME输入法编辑器，可以让用户输入在物理键盘上找不到的字符。复合事件就是针对检测和处理这种输入而设计。

### 13.4.6 变动事件。

DOM2级的变动事件能在DOM中的某一部分发生变化时给出提示。变动事件是为XML或HTML DOM设计的，并不特定于某种语言。删除节点。使用removeChild()或replaceChild()从DOM中删除节点时，首先会触发DOMNodeRemoved事件，这个事件的目标是被删除的节点，而event.relatedNode属性中包含着对目标节点父结点的引用。如果被移除的节点包含子节点，那么在其所有子节点以及这个被移除的节点上会相继触发DOMNodeRemoverFromDocument事件事件。紧随其后触发的是DOMSubtreeModified事件，这个事件的目标是被移除节点的父结点，此时的event对象也不会提供与事件相关的信息。插入节点，在使用appendChild()、replaceChild()或insertBefore()向DOM中插入节点时，首先会触发DOMNodeInserted事件。这个事件的目标是被插入的节点，而event.relatedNode属性中包含一个对父节点的引用。紧接着，会在新插入的节点上面触发DOMNodeINsertedIntoDocument事件。最后一个触发的事件时DOMSubtreeModified，触发于新插入节点的父结点。

### 13.4.7 HTML5事件。

- contextmenu事件，用以表示何时应该显示上下文菜单，以便开发人员取消默认的上下文菜单而提供自定义的菜单。
- beforeunloaded事件，显示页面被卸载信息，通过弹出对话框询问用户是否真要要关闭页面，其中event.returnValue的值设置为要显示给用户的字符串。IE和Firefox都支持beforeunload事件，也都会弹出这个对话框询问用户是否真想离开。Safari和Chrome支持beforeunload事件，但不会妨碍事件继续，因而不会弹出对话框。Opera9.5之前的版本不支持beforeunload事件。DOMContentloaded事件。在形成完整的DOM树之后就会触发，不理会图像、JavaScript文件、CSS文件或其它资源是否已经下载完毕。readystatechange事件。提供与文档或元素的加载状态有关的信息，事件的每个对象都有一个readyState属性。
- pageshow事件。在页面显示时触发，无论该页面是否来自往返缓存bfcache。在重新加载的页面中，pageshow会在load事件触发后触发，同时事件的event对象还包含一个名为perisisted的布尔值属性，如果页面被保存在了bfcache中，则这个属性的值为true，否则为false。
- 与pageshow事件对应的是pagehide事件，该事件会在浏览器卸载页面的时候触发，而且是在unload事件之前触发。
- hashchange事件。在URL的参数列表发生变化时通知开发人员，此时的event对象应该额外包含两个属性：oldURL和newURL。

### 13.4.8 设备事件。

- orientationchange事件，让开发人员能够确定用户何时将设备由横向查看模式切换为纵向查看模式。移动Safari的window.arientation属性可能包含三个值：0表示肖像模式，90表示向左旋转的横向模式，-90表示向右旋转的横向模式。可能还有180表示iPhone头朝下。
- MozOrientation事件。当设备的加速计检测到设备方向改变时，就会触发这个事件，event对象包含x、y和z三个属性，属性值介于1到-1之间，表示不同坐标轴上的方向。
- deviceorientation事件。与MozOrientation事件类似，但是是告诉开发人员设备在空间中朝向哪儿，而不是如何移动。
- devicemotion事件。告诉开发人员设备什么时候移动，而不仅仅是设备方向如何改变。

### 13.4.9 触摸与手势事件。

触摸事件会在用户手指放在屏幕上面时、在屏幕上滑动时或从屏幕上移开时触发。具体来说，有以下触摸事件：

- 手指触摸或已经触摸屏幕时触发touchstart、
- 手指在屏幕上滑动时连续地触发touchmove、
- 手指从屏幕上移开时触发touchend、
- 系统停止跟踪触摸时chufatouchcancel。

手势事件在两个手指触摸屏幕时就会产生手势，手势通常会改变显示项的大小，或者旋转显示项。有三个手势事件：

- 一个手指已经按在屏幕上面另一个手指叉触摸屏幕时触发gesturestart、
- 触摸屏幕的任何一个手指的位置发生变化时触发gesturechange、
- 任何一个手指从屏幕上面移开时触发gestureend。

只有两个手指都触摸到事件的接收容器时才会触发这些事件。

## 13.5 内存和性能 

事件委托。添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能。解决方案就是事件委托，利用事件冒泡指定一个事件处理程序就可以管理某一类型的所有事件。使用事件委托，只需在DOM树种尽量最高的层次上添加一个事件处理程序。

移除事件处理程序。在不需要的时候移除事件处理程序，也是解决问题的一种方案。导致“空事件处理程序”的另一种情况，就是卸载页面的时候。一般最好的做法是在页面卸载之前通过onunload事件处理程序移除所有事件处理程序。

## 13.6 模拟事件

通过使用JavaScript在任意时刻来触发特定的事件，而此时的事件就如同浏览器创建的事件一样，这些事件还会冒泡，照样能够导致浏览器执行已经指定的处理它们的事件处理程序。

在document对象上使用createEvent()方法创建event对象，这个方法接收一个参数，即表示要创建的事件类型的字符串。然后需要使用与事件有关的信息对其进行初始化。最后一步就是使用dispatchEvent()方法，所有支持事件的DOM节点都支持这个方法，传入的参数是要触发事件的event对象。如果是定义“自定义事件”，那么可以调用createEvent("CustomEvent")，然后利用initCustomEvent()方法，接收四个参数。IE中的事件模拟，调用document.createEventObject()方法创建event对象，手工为这个对象添加所有必要信息，最后在目标上调用fireEvent()方法，接受两个参数：事件处理程序的名称和event对象。

13.7　小结

# 第14章 表单脚本　

## 14.1 表单的基础知识

在HTML中，表单是由`<form>`元素来表示的，而在JavaScript中，表单对应的则是HTMLFormElement类型，继承了HTMLElement，有相同的默认属性，也有独特的属性和方法。取得`<form>`元素引用的方式有好几种。通过getElementById()方法获取，通过document.forms获取所有表单然后以数值索引或者name值来取得特定的表单。在较早的浏览器或者支持向后兼容的浏览器中，也会把每个设置了name特性的表单作为属性保存在document对象中。

提交表单。使用`<input>`或`<button>`都可以定义提交按钮，只要将其type特性的值设置为"submit"即可，而图像按钮则是通过将`<input>`的type特性值设置为"image"来定义，src表示图像位置。拥有焦点的表单控件，按下回车键触发提交，除了textarea，同时在浏览器发送请求给服务器之前触发submit，这样就有机会验证表单数据。在JavaScript中，还可以以编程的方式调用submit()方法提交表单，这种方式无需表单包含提交按钮。提交表单时可能出现的最大问题，就是重复提交表单，解决这个问题的办法有两个：在第一次提交表单后旧禁用表单按钮，或者利用onsubmit事件处理程序取消后续的表单提交操作。

重置表单。使用type特性值为"reset"的`<input>`或`<button>`都可以创建重置按钮。在重置表单时，所有表单字段都会恢复到页面刚加载完毕时的初始值。用户单击重置按钮重置表单时，会触发reset事件，因此可以取消重置操作，同时也能调用reset()方法触发reset事件。

表单字段。每个表单都有elements属性，该属性时表单中所有表单元素（字段）的集合，这个集合是一个有序列表，可以按照位置和name特性来访问，如果多个表单控件都在使用一个name，就会返回以该name命名的一个NodeList。公有的表单字段属性。除了form属性之外，可以通过JavaScript动态去修改其他任何属性，包括disable、name、readOnly、tabIndex、type、value。公有的表单字段方法。每个表单字段都有两个方法：focus()和blur()，HTML5为表单字段新增了一个autofocus属性，只要设置这个属性，不用JavaScript就能自动把焦点移动到相应的字段。共有的表单字段事件。基本上表单字段都支持blur、change和focus事件。change事件在不同表单控件中触发的次数会有所不同。

## 14.2 文本框脚本 

在HTML中，有两种方式表现文本框，`<input>`单行文本框和`<textarea>`多行文本框。选择文本。无论这两种文本框在标记中有什么区别，但它们都会把用户输入的内容保存在value属性中，通过使用value属性或设置文本框的值修改，不建议使用标准的DOM方法。

选择文本。调用select()方法，大多数浏览器都会将焦点设置到文本框中，这个方法不接受参数。在选择了文本框的文本或者调用slect()方法时，就会触发select事件。有两个属性：selectStionart和selectionEnd，这两个属性保存的是基于0的数值，表示所选择文本的范围（即文本选取开头和结尾的偏移量）。IE8及更早的版本不支持，可以通过document.selection对象，对象保存着用户在整个文档范围内选择的文本信息，即可通过document.selection。createRange().text取得焦点所在文本。选择部分文本。除了select()方法，所有文本框还有setSelectionRange()方法，这个方法接收两个参数：要选择的第一个字符的索引和要选择的最后一个字符之后的字符的索引。如果IE是老版本，则需要先用createRange()方法创建一个范围，然后使用collapse()将范围折叠到文本框的开始位置，接着调用那个moveStart()和moveEnd()这两个方法，最后使用范围的select()方法选择文本。

过滤输入。屏蔽字符，响应向文本框中插入字符操作的是keypress事件，先取得字符编码，然后将字符编码转换成字符串，再使用正则表达式来测试该字符串，从而确定用户输入的是不是数值，如果测试失败，可以通过阻止这个事件的默认行为来屏蔽此类字符。

操作剪贴板，剪贴板事件有六个：beforecopy、copy、beforecut、cut、beforepaste、paste，在实际的事件发生之前before+事件可以向剪贴板发送数据，或者从剪贴板取得数据之前修改数据，但是取消操作只能用事件copy、cut和paste。要访问剪贴板中的数据，可以使用clipboardData对象，一般在了确保跨浏览器兼容性，最好只在发生剪贴板事件期间使用这个对象，这个对象有三个方法：getData()、setData()和clearData()，第一个方法接受一个参数，即要取得的数据的格式，第二个方法第一个参数也是数据类型，第二个参数是要放在剪贴板中的文本。自动切换焦点。通过函数比较用户输入的值与文本框的maxlength特性，如果值相等，则需要查找表单字段集合，直至找到下一个文本框，找到之后将焦点奇幻到该文本框。然后，我们把这个函数指定为每个文本框的onkeyup事件处理程序。

HTML5约束验证API。第一种情况是在表单字段中指定了required属性。HTML5为`<input>`元素的type属性又增加了几个值，这些新的类型不仅能反映数据类型的信息，而且还能提供一些默认的验证功能。例如"email"类型要求输入的文本必须符合电子邮件地址的模式，而"url"类型要求输入的文本必须符合URL的模式，这些设置特定的输入类型不能阻止用户输入无效的值，只能应用某些默认的验证。HTML5还定义了另外几种输入元素，这几个元素都要求填写某种基于数字的值："number"、"range"、"datetime"、"datetime-local"、"date""mouth"、"week""tiem"。对于这些数值类型的输入元素，可以指定min属性、max属性和step属性。以上属性在JavaScript中都能通过对应的元素访问或修改，此外还有两个方法：stepUp()和stepDown()，都接收一个可选的参数，要在当前值基础上加上或减去的数值。输入模式。HTML5为文本字段新增了pattern属性，这个属性的值是一个正则表达式，用于匹配文本框中的值，模式的开头和末尾不用加^和$符号表示输入的值必须从头到尾都与模式匹配。检测有效性。使用checkValidity()方法可以检测表单中的某个字段是否有效，使用validity属性则显示字段为什么有效或无效。这个对象中包含一系列属性，每个属性会返回一个布尔值，如果判断不匹配，则返回true。禁用验证。通过设置novalidate属性，可以告诉表单不进行验证。在JavaScript中使用noValidate属性可以取得或设置这个值，如果这个属性存在，值为true，否则为false。

## 14.3 选择框脚本 

选择框是通过`<select>`和`<option>`元素创建的，为了方便与这个控件交互，除了所有表单字段公有的属性和方法外，HTMLSelectElement类型还提供了下列属性和方法，add、multiple、options、remove(index)、selectedIndex、size，选择框的type属性不是"select-one"，就是"select-multiple"，这取决于HTML代码中有没有multiple特性。选择框的value属性由当前选中项决定，如果没有选中项，则value属性保存空字符串，如果如果有选中项但value值未指定，则value属性等于该项的文本。在DOM中，每个`<option>`元素都有一个HTMLOptionElement对象表示，对象有着indx、label、selected、text、value属性。同时，选择框的change事件与其他表单字段的change事件触发的条件不一样，选择框的change事件只要选中了选项就会触发，其它表单字段则是在值被修改且焦点离开当前字段时触发。

选择选项。对于只允许选择某一项的选择框，访问选中项的最简单方式，就是使用选择框的selectedIndex属性。对于可以选择多项的选择框，selectedIndex属性就好像只允许选择一项一样。设置selectedIndex会导致取消以前的所有选项并选择指定的那一项，而读取selectedIndex则只会返回选中项中第一项的索引。另一种选择选项的方式，就是取得对某一项的引用，然后将其selected属性设置为true，要取得所有选中的项，可以循环遍历选项集合，然后测试每个选项的selected属性，从而确定选中的数组。

添加选项。可以使用JavaScript动态创建选项，并将它们添加到选择框中。第一种方法是使先创建元素，再添加文本节点和value特性，最后使用appendChild()方法将元素对象添加到选择框中。第二种方法是使用Option构造函数来创建新选项，这个构造函数接收两个参数：文本和值，第二参数可选。第三种添加新选项的方式是使用选择框的add()方法。这个方法接收两个参数：要添加的新选项和将位于新选项之后的选项。如果想在列表的最后添加一个选项，应该将第二个参数设置为null值。

移除选项。移除选项可以使用DOM的removeChild()方法，为其传入要移除的选项。其次，可以使用选择框的remove()方法。最后一种方法，就是将相应选项设置为null值，移除选项后，所有后续选项都会自动向上移动一个位置。

移动和重排选项。使用DOM的appendChild()方法，就可以将第一个选择框中的选项直接移动到第二个选择框汇总。如果该方法传入一个文档中已有的元素，那么就会先从该元素的父节点中移除它，再把它添加到指定的位置，移动选项与移除选项有一个共通之处，就是会重置每一个选项的index属性。

## 14.4 表单序列化 

在JavaScript中，可以利用表单字段的type属性，连同name和value属性一起实现对表单的序列化。

表单提交期间，浏览器通过发送给服务器的数据是有

- 对表单字段的名称和值进行 URL 编码，使用和号（&）分隔。
- 不发送禁用的表单字段。
- 只发送勾选的复选框和单选按钮。
- 不发送 type 为"reset"和"button"的按钮。
- 多选选择框中的每个选中的值单独一个条目。
- 在单击提交按钮提交表单的情况下，也会发送提交按钮；否则，不发送提交按钮。也包括 type
为"image"的`<input>`元素。
- `<select>`元素的值，就是选中的`<option>`元素的 value 特性的值。如果`<option>`元素没有 value 特性，则是`<option>`元素的文本值。

在表单序列化过程中，一般不包含任何按钮字段，因为结果字符串很可能是通过其他方式提交的。

```JavaScript
function serialize(form) {
  var parts = [],
    field = null,
    i,
    len,
    j,
    optLen,
    option,
    optValue;
  for (i = 0, len = form.elements.length; i < len; i++) {
    field = form.elements[i];
    switch (field.type) {
      case "select-one":
      case "select-multiple":
        if (field.name.length) {
          for (j = 0, optLen = field.options.length; j < optLen; j++) {
            option = field.options[j];
            if (option.selected) {
              optValue = "";
              if (option.hasAttribute) {
                optValue = option.hasAttribute("value")
                  ? option.value
                  : option.text;
              } else {
                optValue = option.attributes["value"].specified
                  ? option.value
                  : option.text;
              }
              parts.push(
                encodeURIComponent(field.name) +
                  "=" +
                  encodeURIComponent(optValue)
              );
            }
          }
        }
        break;
      case undefined: //字段集
      case "file": //文件输入
      case "submit": //提交按钮
      case "reset": //重置按钮
      case "button": //自定义按钮
        break;
      case "radio": //单选按钮
      case "checkbox": //复选框
        if (!field.checked) {
          break;
        }
      /* 执行默认操作 */
      default:
        //不包含没有名字的表单字段
        if (field.name.length) {
          parts.push(
            encodeURIComponent(field.name) +
              "=" +
              encodeURIComponent(field.value)
          );
        }
    }
  }
  return parts.join("&");
}
```

## 14.5 富文本编辑 

富文本编辑器，又称为WYSIWYG，所见即多得。这一技术的本质，就是在页面中嵌入一个包含空HTML页面的iframe，通过设置designMode属性，这个空白的HTML页面可以被编辑，而编辑对象则是该页面`<body>`元素的HTML代码。designMode属性有两个可能的值："off"和"on"。在包含页面中，必须使用onload事件处理程序来在适当的时刻设置designMode。

另一种编辑富文本内容的方式是使用名为contentedditable的特殊属性。通过设置该属性，这个元素好像变成了`<textarea>`元素一样，这个属性有三个可能的值："true"表示打开、"false"表示关闭、"inherit"表示从父元素那里继承。

操作富文本。使用document.execCommand()方法可以对文档执行预定义的命令，而且可以应用大多数格式，这个方法有三个参数：要执行的命令名称、表示浏览器是否应该为当前命令提供用户界面的一个布尔值和执行命令必须的一个值（如果不需要值，则传递null）。除了命令外，还有一些与命令相关的方法，第一个方法就是queryCommandEnabled()，可以用它来检测是否可以针对当前选择的文本，或者当前插入字符所在位置执行命令，这个方式接收一个表示检测的命令的参数。如果当前编辑区域允许执行传入的命令，这个方法返回true，否则返回false。最后一个方法是queryCommandValue()，用于取得执行命令时传入的值。

富文本选取。使用iframe的getSelection()方法，可以确定实际选择的文本，这个方法是window对象和document对象的属性，调用它会返回一个表示当前选择文本的Selection对象，每个Selection对象都有多个属性和方法，同时也可以访问DOM范围对富文本编辑器进行更加细化的控制。

表单与富文本。由于富文本编辑是使用iframe而非表单控件实现的，因此从技术上说富文本编辑器并不属于表单，需要我们手动来提取并提交HTML给服务器。可以通过文档主体的innerHTML属性取得了iframe中的HTML，然后将其插入到了表单字段中。

14.6　小结　

# 第15章 使用Canvas绘图　

## 15.1 基本用法 

使用`<canvas>`元素，必须先设置其width和Height属性，指定可以绘图的区域大小，出现在开始和结束中的内容是后备信息，如果浏览器不支持该元素，就会显示这些信息。调用getContext()方法并传入上下文的名字，可以取得绘图上下文对象的引用。传入"2D"，就可以取得2D上下文对象。使用toDataURL()方法，可以导出在`<canvas>`元素上绘制的图像，这个方法接受一个参数，即图像的MIME类型格式，而且适合用于创建图像的任何上下文。

## 15.2 2D上下文 

2D上下文的坐标开始于`<canvas>`元素的左上角。2D上下文的两种基本绘图操作是填充和描边。填充，就是用指定的样式填充图形；描边，就是在图形的边缘划线，操作的结果取决于两个属性：fillStyle和strokeStyle，这两个属性的值可以是字符串、渐变对象或模式对象。

矩形是唯一一种可以直接在2D上下文中绘制的形状，与矩形有关的方法包括fillRect()、strokeRect()和clearRect()。这三个方法都能接收4个参数：矩形的x坐标、矩形的y坐标、矩形宽度和矩形高度，这些参数的单位都是像素。fillRect()方法在画布上绘制使用指定的颜色填充，填充颜色通过fillStyle属性指定；strokeRect()在画布上绘制使用指定的颜色描边，描边颜色通过strokeStyle属性指定，描边线条的宽度由lineWidth属性控制。

绘制路径首先必须调用beginPath()方法，表示要开始绘制新路径。然后，arc()创建弧/曲线（用于创建圆形或部分圆），arcTo()创建两切线之间的弧/曲线，lineTo()添加一个新点，然后在画布中创建从该点到最后指定点的线条，moveTo()把路径移动到画布中的指定点，不创建线条，quadraticCurveTo()创建二次贝塞尔曲线，bezierCurveTo()创建三次方贝塞尔曲线，rect()创建矩形路径。创建了路径后，调用closePath()方法可以绘制一条连接到路径起点的线条，使用fill()方法可以填充该路径，使用stroke()方法可以对路径描边，使用slip()放可以在路径上创建一个剪切区域。使用isPointInPath()方法，可以在路径被关闭之前确定画布上的某一点是否位于路径上，这个方法接收需要确定的点的x和y坐标作为参数。

绘制文本主要有两个方法：fillText()和strokeText()。这两个方法都可以接收4个参数：要绘制的文本字符串、x坐标、y坐标和可选的最大像素宽度。这两个方法都以font、textAlign和textBaseline属性为基础。2D上下文提供了服务确定文本大小的方法measureText()方法，这个方法接收一个参数，即要绘制的文本，返回一个TextMetrics对象。

通过上下文的变换，可以把处理后的图像绘制到画布上。方法有rotate()旋转，scale()缩放，translate()重新映射画布上的(0,0)位置，transform()替换绘图的当前转换矩阵，setTransform()将当前转换重置为单位矩阵。然后运行transform()。使用save()方法可以保存某组属性与变换的组合，通过restore()方法可以在设置的栈结构中向前返回一级，回复之前的状态。

2D绘图上下文内置了对图像的支持，可以使用drawImage()方法将一幅图像绘制到画布上。总共可以传入9个参数：要绘制的图像、源图像的x坐标、源图像的y坐标、源图像的宽度、源图像的高度、目标图像的x坐标、目标图像的y坐标、目标图像的宽度、目标图像的高度。除了给drawImage()方法传入HTML`<img>`元素外，还可以传入另一个`<canvas>`元素作为其第一个参数。

2D上下文会根据以下几个属性的值，自动为形状或路径绘制出阴影。shadowColor用CSS颜色格式表示的阴影颜色，shadowOffsetX和shadowOffsetY表示阴影偏移量，shadowBlur模糊的像素数。

渐变由CanvasGradient实例表示，createLineGradient()方法可以创建一个新的线性渐变，接收的四个参数是起点的坐标和终点的坐标，这样就可以有一个指定大小的渐变并返回CanvasGradient对象的实例。使用addColorStop()方法来指定色标，接收的两个参数是色标位置和CSS颜色值，为了让渐变覆盖整个矩形，而不是仅应用到矩形的一部分，矩形和渐变对象的坐标必须匹配才行。课使用createRadialGradient()方法，这个方法接收5个参数，对应两个圆的圆心和半径。
模式。调用createPattern()方法并传入两个参数：一个HTML`<img>`元素和一个表示如何重复图像的字符串，就可以用来填充或描边图形。

使用图像数据。通过使用getImageData()方法取得原始图像数据，这个方法接收4个参数：要取得其数据的画面区域的x和y坐标以及该区域的像素宽度和高度。返回的对象是ImageData的实例，每个ImageData对象都有三个属性：width、height和data，其中data属性是一个数组，保存着图像中每个像素的数据。在打他数组中，每个像素用四个元素来保存，分别表示红绿蓝和透明度值。调用putImageData()方法把图像数据绘制到画布上。

合成。属性globalAlpha是一个介于0和1之间的值（包括0和1），用于指定所有绘制的透明度，默认值为0。globalCompositionOperate属性表示后绘制的图形怎么样与先绘制的图形结合，属性值是特定的字符串。

## 15.3 WebGL 

WebGL是针对Canvas的3D上下文，WebGL并不是W3C制订的标准。类型化数组的元素被设置为特定类型的值，核心是名为ArrayBuffer的类型，表示内存中指定的字节数。使用ArrayBuffer的一种特别的方式就是用它来创建数组缓冲器视图，最常见的视图是DataView，通过它可以选择ArrayBuffer中一小段字节。类型化视图一般也被陈伟类型化数组，因为他们除了元素必须是某种特定的数据类型外，与常会的数组无异，类型化视图也分几种，而且它们都继承了DataView，类型化视图的目的在于简化对二进制数据的操作。WebGL上下文，一般都把WebGL上下文对象命名为gl，通过给getContext()传递第二个参数，可以为WebGL上下文设置一些选项。在WebGL中，保存在上下文对象中的这些常量都没有GL_前缀，方法都试图通过名字传递有关数据类型的信息。在实际操作WebGL上下文之前，一般都要使用某种实色清除`<canvas>`，为绘图做好准备。默认情况下，WebGL视口可以使用整个`<canvas>`区域，吐过要改变大小可以调用viewport()方法并传入4个参数。顶点信息保存在JavaScript的类型化数组中，使用之前必须转换到WebGL的缓冲区，要创建缓冲区，可以调用gl.createBuffer()，然后使用gl.bindBuffer()绑定到WebGL上下文。JavaScript与WebGL之间的最大的区别在于，WebGL操作一般不会抛出错误，为了知道是否有错误发生，必须在调用某个可能出错的方法后，手工调用gl.getError()方法，这个方法返回一个表示错误类型的常量。WebGL中有两种着色器：顶点着色器和片段着色器，顶点着色器用于将3D顶点转换为需要渲染的2D点，片段着色器用于准确计算要绘制的每个像素的颜色。着色器是使用GLSL编写的类C语言，每个着色器都有一个main()方法，该方法在绘图期间会重复执行，为着色器传递数据的方式有两种：Attribute和Uniform。浏览器不能理解GLSL程序，因此必须准备好字符串形式的GLSL程序，以便编译并链接到着色器程序。取得了GLSL字符串之后，接下来就是创建着色器对象。为着色器传值，Uniform变量可以使用gl.getUniformcation()方法，该方法返回一个对象，表示Uniform变量在内存中的位置，然后可以基于变量的位置来赋值。着色器操作也可能会失败，而且是静默失败，如果想知道着色器或程序执行中是否发生了错误，必须亲自询问WebGL上下文。WebGL只能绘制三种形状：点、线和三角，其它所有形状都是由这三种基本形状合成之后，再绘制到三维空间中的，执行绘图操作要调用gl.drawArrays()或gl.drawElements()方法，前者用于数组缓冲区，后者用于元素数组缓冲区。WebGL的纹理可以使用DOM中的图像，要创建一个新纹理，可以调用gl.createTexture()，然后再将一幅图像绑定到该纹理。与2D上下文类似，通过WebGL上下文也能读取像素值。读取像素值的方法readPixels()与OpenGL中的同名方法只有一点不同，即最后一个参数必须是类型化数组。

15.4 小结　

# 第16章 HTML5脚本编程　

## 16.1 跨文档消息传递 

跨文档消息传达，有时候简称为XDM，指的是在来自不同域的页面间传递消息。XDM的核心是postMessage()方法，接收两个参数：一条消息和一个表示消息接收方来自哪个域的字符串。第二个参数对保障安全通信非常重要，可以防止浏览器把小心发送到不安全的地方。接收到XDM消息时，会触发window对象的message事件，事件触发是异步的，触发后传递给onmessage处理程序的事件对象包含以下三方面的重要信息：data字符串数据、origin文档所在域和source对象的代理。event.source大多数情况下只是window对象的代理，并非实际的window对象，一般只通过调用postMessage()方法发送回执。

## 16.2 原生拖放 

按下鼠标键并开始移动鼠标时，会在被拖放的元素上出发dragstart事件，此时光标变成“不能放”符号，表示不能把元素放到自己上面。触发dragstart事件后，随即会触发drag事件，而且在元素被拖动期间会持续触发该事件，与鼠标过程中mousemove事件类似。当拖动停止时，会触发dragend事件。同理，当某个元素被拖动到一个有效的放置目标上时，下列事件会在放置目标的元素依次发生，dragenter、dragover（在放置目标内移动）、dragleave或drop。其中dragleave是元素被拖出了放置目标才触发，类似mouseout事件，而drop事件时元素被放到了放置目标中才会触发。

自定义放置目标。在拖动元素经过某些无效放置目标时，可以看到一种特殊的光标（圆环中有一条反斜线），表示不能放置。可以把任何元素变成有效的放置目标，方法是重写dragenter和dragover事件的默认行为。

dataTransfer对象，它是事件对象的一个属性，用于从被拖动元素向放置目标传递字符串格式的数据。该对象有两个主要方法：getData()和setData()。前者只有一个参数，即用来表示保存的数据类型的一个字符串，取值为"text"或"URL"。后者的第二个参数是字符串数据。实际上，dataTransfer对象可以为每种MIME类型都保存一个值。将数据保存为文本和保存为URL是由区别的，后者会跳转到另一个浏览器窗口。

dropEffect与effectAllowed。在dataTransfer对象中，dropEffect属性可以知道被拖动的元素能够执行哪种放置行为，属性值有none、move、copy和link，在把元素拖动到放置目标上时，以上每个值都会导致光标显示为不同的符号。dropEffect属性只有搭配effectAllowed属性才有用，effectAllowed属性表示允许拖动元素的哪种dropEffect。

HTML5为所有HTML元素规定了一个draggable属性，表示元素是否可以拖动。图像和链接的draggable属性自动被设置成了true，而其它元素这个属性的默认值都是false。

## 16.3 媒体元素 

使用`<audio>`和`<video>`标签元素，至少要在标签中包含src属性，指向要加载的媒体文件，还可以设置width和height属性以指定视频播放器的大小，而为poster属性指定图像的URI可以在加载视频内容期间显示一幅图像。另外，如果标签中有controls属性，则意味着浏览器应该显示UI控件，以便用户直接操作媒体。位于开始和结束标签之间的任何内容都将作为后备内容，在浏览器不支持这两个媒体元素的情况下显示。通过使用一个或多个`<source>`元素，可以指定多个不同的媒体俩元。这两个媒体元素有大量属性和可以触发很多事件，这些事件监控者不同的属性的变化，这些变化是媒体播放的结果，也可能是用户操作播放器的结果。

检测编解码器的支持情况。这两个媒体元素都有一个canPlayType()方法，该方法接收一种格式/编解码器字符串，返回"probably"、"maybe"或""，空字符串是假值。

`<audio>`元素还有一个原生的JavaScript构造函数Audio，可以在任何时候播放音频。创建新的的Audio实例即可开始下载指定的文件。下载完成后，调用play()就可以播放音频。

## 16.4 历史状态管理 

HTML5通过更新history对象为管理历史状态提供了方便。通过hashchange事件，可以知道URL的参数什么时候发生了变化，即什么时候有所反应。通过状态管理API，能够在不加载新页面的情况下改变浏览器的URL。为此，需要使用history.pushState()方法，该方法接收三个参数：状态对象、新状态的标签和可选的相对URL。执行pushState()方法后，新的状态信息就会被加入历史状态栈，而浏览器地址栏也会变成新的相对URL。按下“后退”按钮，会触发window对象的popstate事件，它有一个包含当初以第一个参数传递给pushState()的状态对象的state属性。得到这个状态对象后，必须把页面重置为状态对象中的数据表示的状态。需要更新当前状态，可以调用replaceState()，传入的参数与pushState()的前两个参数相同。调用这个方法不会再历史状态栈中创建新状态，只会重写当前状态。

16.5　小结　

# 第17章 错误处理与调试　

## 17.1 浏览器报告的错误 

IE是唯一一个在浏览器的界面窗体中显示JavaScript错误信息的浏览器。

## 17.2 错误处理 

ECMA-262第3版引入了try-catch语句，作为JavaScript中处理异常的一种标准方式。只要代码中还包含finally子句，则无论try或catch语句块中包含什么代码，甚至return语句，都不会阻止finally子句的执行。

错误类型Error是基类型，其它错误类型都继承自该类型。EvalError类型的错误会在使用eval()函数而发生异常时被抛出。RangeError类型的错误会在数值超出相应范围时触发。ReferenceError类型在找不到对象的情况下触发，这种情况下会直接导致人所共知的"object expected"浏览器错误，通常，在访问不存在的变量时，就会发生这种错误。SyntaxError类型是在把语法错误的JavaScript字符串传入eval()函数时触发。TypeError类型在JavaScript中经常用到，在变量中保存着意外的类型时，或者在访问不存在的方法时，都会导致这种错误。在使用encodeURI()或decodeURI()，而URI格式不正确时，就会导致URIError错误。

当try-catch语句中发生错误时，浏览器会认为错误已经被处理了，而不会出现机制记录或报告错误。使用try-catch最适合处理那些我们无法控制的错误。与这个语句相配的还有一个throw操作符，用于随时抛出自定义错误。抛出错误时，必须哟啊给throw操作符指定一个值，值的类型没要求。在遇到throw操作符时，代码会立刻停止执行，仅当有try-catch语句捕获到被抛出的值时，代码才会继续执行。通过使用某种内置错误类型，可以更真实地模拟浏览器错误，每种错误类型的构造函数接收一个参数，即实际的错误消息。另外，利用原型链还可以通过继承Error来创建自定义错误类型。要针对函数为什么会执行失败给出更多信息，抛出自定义错误是一种很方便的方式。

任何没有通过try-catch处理的错误都会触发window对象的error事件。在任何Web浏览器中，onerror事件处理程序都不会创建event对象，但它可以接收三个参数：错误消息、错误所在的URL和行号。要指定onerrror事件处理程序，必须使用DOM0级技术，它没有遵循“DOM2级事件”的标准格式。如果触发error事件并执行事件处理程序时，通过返回false，这个函数实际上就充当了整个文档中的try-catch语句，可以捕获所有无代码处理的运行时错误。

常见的错误类型。类型转换错误发生在使用某个操作符，或者使用其他可能会自动转换值的数据类型的语言结构时。数据类型错误，JavaScript是松散类型的，也就是说，在使用变量和函数参数之前，不会对它们进行比较以确保它们的数据类型正确。大体上来说，基本类型的值应该使用typeof来检测，而对象的值则应该使用instanceof来检测。通信错误，第一种通讯错误与格式不正确的URL或发送的数据有关，最常见的问题是在将数据发送给服务器之前没有使用encodeURIComponent()对数据进行编码，另外在服务器响应的数据不正确时也会发生通信错误。

区分志明错误和非致命错误。区分两者的依据，就是看它们对用户的影响。开发Web应用程序过程中的一种常见的做法，就是集中保存错误日记，一边查找重要错误的原因。要建立这样一种JavaScript错误记录系统，首先需要在服务器上创建一个页面（或者一个服务器入口点），用于处理错误数据。

## 17.3 调试技术 

将消息记录到控制台。一般都可以通过console对象向JavaScript控制台中写入消息，这个对象具有下列方法：将错误小心记录到控制台error()、将信息性消息记录到控制台info()、将一般消息记录到控制台log()、将警告信息记录到控制台warn()。将消息记录到当前页面。就是在页面中开辟一小块区域，在这个区域通常是一个元素，而该元素可以总是出现在页面中，但仅用于调试目的。抛出错误。对于大型应用程序来说，自定义的错误通常都是用assert()函数抛出。

## 17.4 常见的IE错误

操作终止。在修改尚未加载完成的页面时，就会发生操作终止错误，此时出现一个模态对话框，提示“操作终止”。无效字符。在JavaScript文件中存在无效字符时，IE会抛出无效字符错误，即JavaScript语法中未定义的字符。为找到成员。具体来说，如果在对象被销毁之后，又给对象赋值，就会导致未找到成员错误。未知运行时错误。当使用innerHTML或outerHTML以下列方式指定HTML时，就会发生未知运行时错误：一是把块元素插入到行内元素时，二是访问表格任意部分的任意属性时。语法错误。原因可能是代码中少了一个分号，或者花括号前后不对应，或者引用的外部JavaScript文件没有返回代码。系统无法找到指定资源。IE有对URL最长不能超过2083个字符的限制。

17.5　小结　

第18章　JavaScript与XML　
18.1　浏览器对XML DOM的支持　
18.2　浏览器对XPath的支持　
18.3　浏览器对XSLT的支持  
18.4　小结　

# 第19章 E4X　

E4X是以ECMA-357标准的形式发布的对ECMAScript的一个扩展，目的是为了操作XML数据提供与标准ECMAScript更相近的语法。

19.2 一般用法 

19.3 其他变化 

19.4 全面启用E4X

19.5 小结

# 第20章 JSON　

JSON 是 JavaScript 的一个严格的子集，利用了 JavaScript 中的一些模式来表示结构化数据。

## 20.1 语法 

JSON 的语法可以表示以下三种类型的值。  

- 简单值。最简单的 JSON 数据形式就是简单值。可以在 JSON 中表示字符串、数值、布尔值和 null 。与 JavaScript 不同的是，JSON 字符串必须使用双引号。在实际应用中， JSON 更多地用来表示更复杂的数据结构，而简单值只是整个数据结构中的一部分。

- 对象。对象作为一种复杂数据类型，表示的是一组无序的键值对儿。而每个键值对儿中的值可以是简单值，也可以是复杂数据类型的值。JSON 中的对象要求给属性加引号。JSON 对象有两个地方不一样。首先，没有声明变量（ JSON 中没有变量的概念）。其次，没有末尾的分号（因为这不是 JavaScript 语句，所以不需要分号）。  

- 数组。数组也是一种复杂数据类型，表示一组有序的值的列表。可以通过索引来访问其中的值。数组的值也可以是任意类型——简单值、对象或数组。JSON数组也没有变量和分号。把数组和对象结合起来，可以构成更复杂的数据集合。

JSON 不支持变量、函数或对象实例，它就是一种表示结构化数据的格式，虽然与 JavaScript 中表示数据的某些语法相同，但它并不局限于 JavaScript 的范畴。  

## 20.2 解析与序列化

JSON 之所以流行，除了拥有与JavaScript类似的语法，更重要的原因是，可以把 JSON 数据结构解析为有用的 Javascript 对象，而 XML 数据结构要解析成 DOM 文档而且从中提取数据。

`eval()`函数。早期的 JSON 解析器基本上就是使用 JavaScript 的`eval()`函数。由于 JSON 是 JavaScript 语法的子集，因此`eval()`函数可以解析、解释并返回 JavaScript 对象和数组。ES5 对解析 JSON 的行为进行规范，定义了全局对象 JSON。

JSON对象有两个方法：`stringify()`和`parse()`，在最简单的情况下，`stringify()`方法把 JavaScript 对象序列化为 JSON 字符串；`parse()`方法把 JSON 字符串解析为原生 JavaScript 值。

在序列化 JavaScript 对象时，所有函数及原型成员都会被有意忽略，不体现在结果中，值为 undefined 的任何属性也都会被跳过，结果中最终都是值为有效 JSON 数据类型的实例属性。

`JSON.stringify()`序列化选项。除了要序列化的 JavaScript 对象外，还可以接收另外两个参数，这两个参数用于指定以不同的方式序列化 JavaScript 对象。第一个参数是个过滤器（数组或函数），第二个参数是一个选项，表示是否在 JSON 字符串中保留缩进。

- 过滤结果，如果过滤器是数组，那么`JSON.Stringify()`的结果中将只包含数组中列出的属性。
- 如果过滤器是函数，那么传入的函数接收两个参数：属性名和属性值。为了改变序列化对象的结果，函数返回的值就是相应键的值。

```JavaScript
var book={
	title:"Professional JavaScript",
	authors:[
		"Nicholas C. Zakas"
	],
	edition:3,
	year:2011
};
var jsonText=JSON.stringify(book,function(key,value){
	switch(key){
		case "authors":
			return value.join(",");
		case "year":
			return 5000;
		case "edition":
			return undefined;
		default:
			return value;
	}
});

/*序列化后的JSON字符串如下所示*/
{"title":"Professional JavaScript","authors":"Nicholas C.Zakas","year":5000}
```

- 字符串缩进，如果这个参数是一个数值，那它表示的是每个级别缩进的空格数，同时插入换行符以提高可读性。
- 如果缩进参数是一个字符串而非数值，则这个字符串将在JSON字符串中被用作缩进字符。

```JavaScript
var book={
	title:"Professional JavaScript",
	authors:[
		"Nicholas C. Zakas"
	],
	edition:3,
	year:2011
};
var jsonText=JSON.stringify(book,null,4);

//保存在jsonText中的字符串如下所示：
{
	"title":"Professional JavaScript",
	"authors":[
		"Nicholas C. Zakas"
	],
	"edition":3,
	"year":2011
}
```

`toJSON()`方法。有时候，`JSON.Stringify()`还是不能满足对某些对象进行自定义序列化的需求，在这个情况下，可以给对象定义`toJSON()`方法。该返回其自身的 JSON 数据格式。对象将被序列化为一个简单的字符串而非对象，可以让`toJSON()`方法返回任何值，它都能正常工作。`toJSON()`可以作为函数过滤器的补充。

```JavaScript
var book={
	title:"Professional JavaScript",
	authors:[
		"Nicholas C. Zakas"
	],
	edition:3,
	year:2011，
	toJSON:function(){
		return this.title;
	}
};
var jsonText=JSON.stringify(book);  // "Professional JavaScript" 
```

`JSON.parse()`解析方法也可以接收另一个参数，该参数是一个函数，将在每个键值对儿上调用，这个函数被称为还原函数，与序列化方法中的过滤函数的签名相同，都接收两个参数，一个键和一个值，而且都需要返回一个值。如果还原函数返回 undefined，则表示要从结果中删除相应的键；如果返回其他值，则将该值插入到结果中。  

```JavaScript
var book = {
  "title": "Professional JavaScript",
  "authors": [
    "Nicholas C. Zakas"
  ],
  edition: 3,
  year: 2011,
  releaseDate: new Date(2011, 11, 1)
};
var jsonText = JSON.stringify(book);
var bookCopy = JSON.parse(jsonText, function(key, value){
  if (key == "releaseDate"){
    return new Date(value);
  } else {
    return value;
  }
});
alert(bookCopy.releaseDate.getFullYear());
```

20.3　小结　

# 第21章 Ajax与Comet

Ajax，是对 Asynchronous Javascript+XML 的简写，这个技术能够向服务器请求额外的数据而无需卸载页面，会带来更好的用户体验。

Ajax 技术的核心是 XMLHttpRequest 对象，简称 XHR ，它为向服务器发送请求和解析服务器响应提供了流畅的接口，能够以异步方式从服务器取得更多信息。但 Ajax 通信与数据格式无关，这种技术就是无需刷新页面即可从服务器取得数据，但不一定是 XML 数据。

## 21.1 XMLHttpRequest对象　

在一般的浏览器中创建 XHR 对象，直接使用 XMLHttpRequest 构造函数，这便是原生的XHR实现。如果还要支持 IE 的早期版本，那么则可以在这个`createXHR()`函数中加入对原生 XHR 对象的支持。

```JavaScript
function createXHR() {
  if (typeof XMLHttpRequest != "undefined") {
    return new XMLHttpRequest();
  } else if (typeof ActiveXObject != "undefined") {
    if (typeof arguments.callee.activeXString != "string") {
      var versions = [
          "MSXML2.XMLHttp.6.0",
          "MSXML2.XMLHttp.3.0",
          "MSXML2.XMLHttp"
        ],
        i,
        len;

      for (i = 0, len = versions.length; i < len; i++) {
        try {
          new ActiveXObject(versions[i]);
          arguments.callee.activeXString = versions[i];
          break;
        } catch (ex) {
          //跳过
        }
      }
    }

    return new ActiveXObject(arguments.callee.activeXString);
  } else {
    throw new Error("No XHR object available.");
  }
}
var xhr = createXHR();
```

XHR 的用法。在使用 XHR 对象时，要调用的第一个方法是`open ()`，它接受3个参数：要发送的请求类型（ "get"、"post" 等）、请求的URL和表示是否异步发送请求的布尔值。其中 URL 相对于执行代码的当前页面（当然也可以使用绝对路径），调用`open ()`方法并不会真正发送请求，而只是启动一个请求以备发送。

```javascript
xhr.open("get", "example.php", false);
```

调用XHR对象的`send()`方法，该方法接收一个参数，即要作为请求主题发送的数据。如果不需要通过请求主题发送数据，则必须传入 null，因为这个参数对有些浏览器来说是必须的，通过调用，请求就会被分派到服务器。

```javascript
xhr.send(null);
```

收到响应后，响应的数据会自动填充XHR对象的属性，相关的属性简介如下。 

- responseText：作为响应主体被返回的文本。 
- responseXML：如果响应的内容类型是 "text/xml" 或 "application/xml" ，这个属性中将保存包含着响应数据的 XML DOM 文档。 
- status：响应的 HTTP 状态。 
- statusText： HTTP 状态的说明。  

在收到响应后，第一步是检查 status 属性（HTTP状态代码200为成功的标志），以确定响应已经成功返回。状态代码为304表示请求的资源并没有被修改，可以直接使用浏览器中缓存的版本。如果 responseText 属性的内容已经就绪，而且在内容类型正确的情况下，responseXML 也应该能够访问了。

```javascript
xhr.open("get", "example.txt", false);
xhr.send(null);
if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304){
  alert(xhr.responseText);
} else {
  alert("Request was unsuccessful: " + xhr.status);
}
```

发送异步请求，可以检测 XHR 对象的 readyState 属性，该属性表示请求/响应过程的当前活动阶段，属性值0代表未初始化，1代表启动，2代表发送，3代表接收，4代表完成。只要该属性值变化，都会触发一次 readyStatechange 事件。

另外，在接收到响应之前还可以调用`abort ()`方法取消异步请求。调用这个方法后， XHR 对象会停止触发事件，而且也不再允许访问任何与响应有关的对象属性。  

```javascript
var xhr = createXHR();	// createXHR () 是兼容性创建 XMLHttpRequest 的方法
xhr.onreadystatechange = function(){
	if (xhr.readyState == 4){
		if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304){
			alert(xhr.responseText);
		} else {
		alert("Request was unsuccessful: " + xhr.status);
		}
	}
};
xhr.open("get", "example.txt", true);
xhr.send(null);

xhr.abort();
```

HTTP 头部信息。每个 HTTP 请求和响应都会带有相应的头部信息，XHR 对象也提供了操作这两种头部（即请求头部和响应头部）信息的方法。默认情况下，在发送 XHR 请求的同时，还会发送下列头部信息。

- Accept：浏览器能够处理的内容类型。
- Accept-Charset：浏览器能够显示的字符集。
- Accept-Encoding：浏览器能够处理的压缩编码。
- Accept-Language：浏览器当前设置的语言。
- Connection：浏览器与服务器之间连接的类型。
- Cookie：当前页面设置的任何 Cookie。
- Host：发出请求的页面所在的域 。
- Referer：发出请求的页面的 URI。注意， HTTP 规范将这个头部字段拼写错了，而为保证与规范一致，也只能将错就错了。（这个英文单词的正确拼法应该是 referrer。）
- User-Agent：浏览器的用户代理字符串。

XHR 对象提供了操作每个 HTTP 请求和响应的这两种头部信息的方法。使用`setRequestHeader()` 方法可以设置自定义的请求头部，这个方法接收两个参数：头部字段的名称和头部字段的值。要成功发送请求头部信息，必须在调用`open()`方法和`send()`方法之间调用`setRequestHeader()`方法。调用 XHR 对象的`getResponseHeader()`方法并传入头部字段名称，可以取得相应的响应头部信息，而调用`getAllResponseHeaders()`方法可以取得一个包含所有头部信息的长字符串。在服务器端，也可以利用头部信息向浏览器发送额外的、结构化的数据。

GET 是最常见的请求类型，最常用于向服务器查询某些信息。必要时，可以将查询字符串参数追加到URL的末尾，以便将信息发送给服务器。对 XHR 而言，位于传入`open()`方法的 URL 末尾的查询字符串必须经过正确的编码才行。使用`encodeURIComponent()`进行编码，而且所有名-值对儿都必须由和号`（&）`分隔。

POST 请求。使用频率仅次于 GET 的是 POST 请求，通常用于向服务器发送应该被保存的数据。POST请求应该把数据作为请求的主题提交，而 GET 请求请求传统上不是这样。POST请求的主体可以包含非常多的数据，而且格式不限。在`open()`方法第一个参数的位置传入 "post" ，就可以初始化一个 POST 请求 。发送 POST 请求的第二步就是向`send()`方法中传入某些数据，数据可以是 XML DOM 文档，也可以是字符串，经序列化之后将作为请求主体被提交到服务器。如果需要像 HTML 表单那样 POST 数据，需要使用`setRequestHeader()`来添加 HTTP 头。然后在`send()`方法中规定发送的数据： 

```javascript
function submitData() {
  var xhr = createXHR();
  xhr.onreadystatechange = function() {
    if (xhr.readyState == 4) {
      if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
        alert(xhr.responseText);
      } else {
        alert("Request was unsuccessful: " + xhr.status);
      }
    }
  };
  xhr.open("post", "postexample.php", true);
  xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
  var form = document.getElementById("user-info");
  xhr.send(serialize(form));  // serialize() 为定义表单序列化方法
}
```

如果不设置 Content-Type 头部信息，那么发送给服务器的数据就不会出现在`$_POST`超级全局变量中。这时候，要访问同样的数据，就必须借助`$HTTP_RAW-POST-DATA`。

## 21.2 XMLHttpRequest 2级

FormData实例。FormData 类型为序列化表单以及创建与表单格式相同的数据（用于通过 XHR 传输）提供了便利。其中 FormData 的实例对象有 append () 方法，接收两个参数：键和值，分别对应表单字段的名字和字段中包含的值。

```JavaScript
var data = new FormData();
data.append("name", "Nicholas");
```

而通过向 FormData 构造函数中传入表单元素，也可以用表单元素的数据预先向其中填入键值对儿。因此，创建了 FormDate 的实例后，可以将它直接传给 XHR 的`send()`方法。使用 FormData 的方便之处体现在不必明确地在 XHR 对象上设置请求头部。XHR 对象能够识别传入的数据类型是 FormData 的实例，并配置适当的头部信息。

```javascript
var xhr = createXHR();
xhr.onreadystatechange = function(event) {
    if (xhr.readyState == 4) {
        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
            alert(xhr.responseText);
        } else {
            alert("Request was unsuccessful: " + xhr.status);
        }
    }
};

xhr.open("post", "postexample.php", true);
var form = document.getElementById("user-info");
xhr.send(new FormData(form));
```

超时设置。timeout 属性表示请求在等待响应多少毫秒之后就停止，如果在规定时间内浏览器没有接收到响应，那么就会触发 timeout 时间，进而调用 ontimeout 时间处理程序。`overrideMimeType()`方法用于重写 XHR 响应的 MIME 类型。

```javascript
// timeout
xhr.open("get", "timeout.php", true);
xhr.timeout = 1000; //将超时设置为 1 秒钟（仅适用于 IE8+）
xhr.ontimeout = function(){
	alert("Request did not return in a second.");
};
xhr.send(null);	
```

请求终止时，会调用 ontimeout 事件处理程序。但此时 redyState 可能已经变成4了，这意味着会调用 onreadystatechange 事件处理程序。可是，如果在超时终止请求之后再访问 status 属性，就会导致错误。为了避免浏览器报告错误，可以将检查 status 属性的语句封装在一个 try-catch 语句当中。

`overrideMimeType()`方法。该方法用于重写 XHR 响应的 MIME 类型。因为返回响应的 MIME 类型决定了 XHR 对象如何处理它，所以提供一种方法能够重写服务器返回的 MIME 类型是很有用的。

比如，服务器返回的 MIME 类型是 text/plain，但数据中实际包含的是 XML。根据 MIME 类型，即使数据是 XML，responseXML 属性中仍然是 null，通过调用`overrideMimeType()`方法就可以保证把响应头当做 XML 而非纯文本来处理。调用该方法必须在`send()`方法之前，才能保证重写相应的 MIME 类型。

```JavaScript
var xhr = createXHR();
xhr.open("get", "text.php", true);
xhr.overrideMimeType("text/xml");
xhr.send(null);
```

## 21.3 进度事件　

Progress Events 规范定义了与客户端服务器通信有关的事件。有以下 6 个进度事件。 

- loadstart：在接收到响应数据的第一个字节时触发。 
- progress：在接收响应期间持续不断地触发。 
- error：在请求发生错误时触发。 
- abort：在因为调用`abort()`方法而终止连接时触发。 
- load：在接收到完整的响应数据时触发。 
- loadend：在通信完成或者触发 error、 abort 或 load 事件后触发。  

每个请求都从触发 loadstart 事件开始，接下来是一或多个 progress 事件，然后触发 error 、 abort 或 load 事件中的一个，最后以触发 loadend 事件结束。

load 事件。Firefox 实现中引入了 load 事件，用以替代 readystatechange 事件。响应接收完毕后将触发 load 事件，因此也就没有必要去检查 readyState 属性了。而 onload 事件处理程序会接收到一个 event 对象，其 target 属性就指向 XHR 对象实例，因而可以访问到 XHR 对象的所有方法和属性。如果遇到不支持的浏览器，还是要使用 XHR 对象变量。

只要浏览器接收到服务器的响应，不管其状态如何，都会触发 load 事件。而这意味着你必须要检查 status 属性，才能确定数据是否真的已经可用了。

progress 事件。progress 事件会在浏览器接收新数据期间周期性地触发，而 onprogress 事件处理程序会接收到一个 event 对象，其 target 属性时 XHR 对象，但包含着三个额外的属性：表示进度信息是否可用的布尔值 lengthComputable 、表示已经接收的字节数 position 和表示根据 content-Length 响应头部确定的预期字节数的 totalSize 。

```JavaScript
// 进度指示器
var xhr = createXHR();
xhr.onload = function(event) {
  if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
    alert(xhr.responseText);
  } else {
    alert("Request was unsuccessful: " + xhr.status);
  }
};
xhr.onprogress = function(event) {
  var divStatus = document.getElementById("status");
  if (event.lengthComputable) {
    divStatus.innerHTML =
      "Received " + event.position + " of " + event.totalSize + " bytes";
  }
};
xhr.open("get", "altevents.php", true);
xhr.send(null);

```

为确保正常执行，必须在调用 open() 方法之前添加 onprogress 事件处理程序。在上面代码中，每次触发 progress 事件，都会以新的状态信息更新 HTML 元素的内容。如果响应头部中包含 Content-Length 字段，那么也可以利用此信息来计算从响应中已经接收到的数据的百分比。

## 21.4 跨源资源共享　

通过 XHR 实现 Ajax 通信的一个主要限制，来源于跨域安全策略。默认情况下，XHR 对象只能访问与包含它的页面位于同一个域中的资源。这种安全策略可以预防某些恶意 行为。但是，实现合理的跨域请求对开发某些浏览器应用程序也是至关重要的。

CORS 跨资源共享定义了在必须访问跨资源时，浏览器与服务器应该如何沟通。CORS 背后的基本思想，就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。  

比如一个简单的使用 GET 或 POST 发送的请求，它没有自定义的头部，而主体内容是 text/plain。在发送该请求时，需要给它附加一个额外的 Origin 头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。下面是 Origin 头部的一个示例： 

```javascript
Origin: http://www.nczonline.net
```

如果服务器认为这个请求可以接受，就在 Access-Control-Allow-Origin 头部中回发相同的源信息（如果是公共资源，可以回发"*"）。例如： 

```javascript
 Access-Control-Allow-Origin: http://www.nczonline.net 
```

如果没有这个头部，或者有这个头部但源信息不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。注意，请求和响应都不包含 cookie 信息。  

IE 对 CORS 的实现。IE8 引入了XDR 类型，这个对象与 XHR 类似，但能实现安全可靠的跨域通信。XDR 对象的使用方法与 XHR 对象非常相似，也是创建一个 XDomainRequest 的实例，调用`open()`，再调用`send()`方法进行异步请求。

其他浏览器对 CORS 的实现。它们可以**通过 XMLHttpRequest 对象实现了对 CORS 的原生支持**。在尝试打开不同来源的资源时，无需额外编写代码就可以触发这个行为。要请求位于另一个域中的资源，使用标准的 XHR 对象并在`open()`方法中传入绝对 URL 即可。

```JavaScript
var xhr = createXHR();
xhr.onreadystatechange = function() {
  if (xhr.readyState == 4) {
    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {
      alert(xhr.responseText);
    } else {
      alert("Request was unsuccessful: " + xhr.status);
    }
  }
};
xhr.open("get", "http://www.somewhere-else.com/page/", true);
xhr.send(null);
```

与 IE 中的 XDR 对象不同，通过跨域 XHR 对象可以访问 status 和 statusText 属性，而且还支持同步请求。但是跨域 XHR 对象也有一些限制，但为了安全这些限制是必须的

- 不能使用 setRequestHeader()设置自定义头部。
- 不能发送和接收 cookie。
- 调用 getAllResponseHeaders()方法总会返回空字符串。

由于无论同源请求还是跨源请求都使用相同的接口，因此对于本地资源，最好使用相对 URL，在访问远程资源时再使用绝对 URL。这样做能消除歧义，避免出现限制访问头部或本地 cookie 信息等问题。

Preflighted Requests。CORS 通过一种叫做 Preflighted Requests 透明服务器验证机制**支持开发人员使用自定义的头部、GET或POST之外的方法**，以及不同类型的主题内容。在使用高级选项来发送请求时，就会向服务器发送一个 Preflight 请求，这种请求使用 OPTIONS 方法，发送下列头部。

- Origin：与简单的请求相同。
- Access-Control-Request-Method：请求自身使用的方法。
- Access-Control-Request-Headers：（可选）自定义的头部信息，多个头部以逗号分隔。

以下是一个带有自定义头部 NCZ 的使用 POST 方法发送的请求。

```JavaScript
Origin: http://www.nczonline.net
Access-Control-Request-Method: POST
Access-Control-Request-Headers: NCZ
```

发送这个请求后，服务器可以决定是否允许这种类型的请求。服务器通过在相应中发送如下头部与浏览器进行沟通。

- Access-Control-Allow-Origin：与简单的请求相同。
- Access-Control-Allow-Methods：允许的方法，多个方法以逗号分隔。
- Access-Control-Allow-Headers：允许的头部，多个头部以逗号分隔。
- Access-Control-Max-Age：应该将这个 Preflight 请求缓存多长时间（以秒表示）。

Preflight 请求结束后，结果将按照响应中指定的时间缓存起来。而为此付出的代码知识第一次发送这种请求时会多一次 HTTP 请求。

带凭借的请求。默认情况下，跨域请求不提供凭据，包括 cookie 、 HTTP 认证及客户端 SSL 证明等，但通过将 withCredentials 属性设置为 true ，可以指定某个请求应该发送凭据。如果服务器接受带凭据的请求，会用下面的 HTTP 头部来响应。

```JavaScript
Access-Control-Allow-Credentials: true
```

如果发送的是带凭据的请求，但服务器的响应中没有包含这个头部，那么浏览器就不会把响应交给 JavaScript。另外，服务器还可以在 Preflight 响应中发送这个 HTTP 头部，表示允许源发哦送带凭据的请求。

跨浏览器的 CORS。即使浏览器对 CORS 的支持程度并不都一样，但所有浏览器都支持简单的（非 Preflight 和不带凭据的）请求。但有必要实现一个跨浏览器的方案，检测 XHR 是否支持 CORS 的最简单方式，就是检查是否存在 withCredentials 属性，再结合检测 XDomainRequest 对象是否存在，就可以兼顾所有浏览器了。

## 21.5 其他跨域技术　

在 CORS 出现以前，开发人员想出一些办法，利用 DOM 中能够执行跨域请求的功能，在不依赖 XHR 对象的情况下也能发送某种请求。虽然 CORS 技术已经无处不在，但这些办法仍然被广泛使用，毕竟这样不要修改服务器端代码。

图像 Ping。这种跨域请求技术是使用`<img>`标签。动态创建图像经常用于图像Ping，它是与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或 204 响应。通过图像Ping，浏览器得不到任何具体的数据，但通过侦听 load 和 error 事件，它能知道响应是什么时候接收到的。图像 Ping 最常用于跟踪用户点击页面或动态广告曝光次数。图像 Ping 有两个主要的缺点，一是只能发送 GET 请求，二是无法访问服务器的响应文本。  

```javascript
var img = new Image();
img.onload = img.onerror = function(){
	alert("Done!");
};
img.src = "http://www.example.com/test?name=Nicholas";
```

JSONP 是 JSON with padding 的简写，是应用 JSON 的一种新方法。JSONP 由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，回调函数的名字一般都是在请求中指定的，而数据就是传入回调函数中的 JSON 数据。JSONP 是通过动态`<script>`元素来使用的，使用时可以为 src 属性指定一个跨域 URL。这里的`<script>`元素与`<img>`元素类似，都有能力不受限制地从其他域加载资源。因为 JSONP 是有效的 JavaScript 代码，所以在请求完成后，即在 JSONP 响应加载到页面中以后，就会立即执行。

```javascript
function handleResponse(response){
	alert("You’ re at IP address " + response.ip + ", which is in " +
		response.city + ", " + response.region_name);
}
var script = document.createElement("script");
script.src = "http://freegeoip.net/json/?callback=handleResponse";
document.body.insertBefore(script, document.body.firstChild);	
```

JSONP 之所以在开发人员中极为流行。主要原因是它非常简单易用。与图像 Ping 相比，它的优点在于能够直接访问响应文本，支持在浏览器与服务器之间双向通信。不过，JSONP 也有两点不足。

- JSONP 从其他域中加载代码执行，如果其他域不安全，很可能会在响应中带一些恶意代码。
- 要确定 JSONP 请求是否失败并不容易，虽然 HTML5 给`<script>`元素新增了一个 onerror 事件处理程序。但 HTML5 得到浏览器支持是缓慢的。

Comet 指的是一种更高级的 Ajax 技术，经常也有人称为服务器推送。Ajax 是一种从页面向服务器请求数据的技术，而 Comet 则是一种服务器向页面推送数据的技术。有两种实现 Comet 的方式：长轮询和流。长轮询是传统轮询（短轮询）的一个翻版，浏览器都要在接收数据之前，先发起对服务器的连接，短轮询是服务器立刻发送响应，而长轮询是等待发送响应。HTTP 流在页面的整个生命周期内只使用一个 HTTP 连接，服务器保持连接打开，周期性地向浏览器发送数据。

SSE 服务器发送事件是围绕只读 Comet 交互退出的 API 或者模式。SSE API 用于创建到服务器的单向链接，服务器通过这个连接可以发送任意数量的数据。要预订新的事件流，首先要创建一个新的 EventSource 对象，并传进一个入口点。EventSource 的实例有一个 readyStatus 属性，值为0表示正连接到服务器，值为1表示打开了连接，值为2表示关闭了连接。另外还有三个事件，在建立连接时触发的 open 事件、在从服务器接收到新事件时触发的 message 事件、在无法建立连接时触发的 error 事件。服务器发回的数据以字符串形式保存在 event.data 中。默认情况下， EventSource 对象会保持与服务器的活动连接。事件流。所谓的服务器事件会通过一个持久的 HTTP 响应发送，这个响应的 MIME 类型是 text/eventstream。响应的格式是纯文本。

Web Sockets 的目标是在一个单独的持久连接上提供全双工、双向通信。Web Sockets 使用了自定义的协议，好处是在客户端和服务器之间发送非常少量的数据，而不必担心 HTTP 那样字节级的开销。要创建 Web Socket ，先实例一个WebSocket 对象并传入要连接的 URL ，如果要关闭连接，可以在任意时候调用`close()`方法。如果要向服务器发送数据，使用`send()`方法并传入任意字符串，因为只能通过连接发送纯文本数据，所以对于复杂的数据结构，在通过连接发送之前必须进行序列化。当服务器向客户端发来小心时，WebSocket 对象就会触发 message 事件，返回的数据保存在 event.data 属性中。

## 21.6 安全

首先，可以通过 XHR 访问的任何 URL 也可以通过浏览器或服务器访问。对于未被授权系统有权访问某个资源的情况，我们称之为 XSRF 跨站点请求伪造。为确保通过XHR访问的URL安全，通行的做法就是验证发送请求者是否有权限访问相应的资源。

XHR 对象也提供了一些安全机制，虽然表面上看可以保证安全，但实际上却相当不可靠。实际上，前面介绍的 open() 还能再接收两个参数：要随请求一起发送的用户名和密码。带有这两个参数的请求可以通过 SSL 发送给服务器上的页面。

21.7　小结　

第22章 高级技巧　

22.1　高级函数　

22.2　防篡改对象　

22.3　高级定时器　

22.4　自定义事件　

22.5　拖放　

22.6　小结　

# 第23章 离线应用与客户端存储　

## 23.1 离线检测 

HTML5定义了一个navigator.onLine属性来确定设备是在线还是离线，属性值为true则表示设备能够上网。为了更好地确定网络是否可用，还定义了两个事件：online和offline，当网络从离线变为在线或者从在线变为离线时，分别触发这两个事件，这两个事件在window对象上触发。

## 23.2 应用缓存 

HTML5的应用缓存，简称为appcache，是专门为开发离线Web应用而设计的。要向在浏览器的缓存中分出一块缓存区，然后保存数据，可以使用一个描述文件，列出要下载和缓存的资源。要将描述文件与页面关联起来，可以在`<html>`中的mainfest属性中指定这个文件的路径。虽然应用缓存的意图是确保离线时资源可用，但也有相应的JavaScript API让你知道它都在做什么，这个API的核心是applicationCache对象，这个对象有一个status属性、属性的值是常量，表示应用缓存的如下状态：无缓存0、闲置1、检查中2、下载中3、更新完成4、废弃5。应用缓存还有很多相关的事件，表示其状态的改变。一般来说，这些事件会随着页面加载按上述顺序触发，不过调用update()方法也可以手工干预，让应用缓存为检查更新而出发上述事件。如果触发了updateready事件，则说明新版本的应用缓存已经可用，而此时你需要调用swapCache()来启用新应用缓存。

## 23.3 数据存储 

HTTP Cookie，通常直接叫做cookie，最初是在客户端用于存储会话信息的。cookie在性质上是绑定在特定的域名下的。每个域的cookie总数是有限的，不过浏览器之间各不同。当超过单个域名限制之后还要再设置cookie，浏览器就会清除以前设置的cookie。浏览器中对于cookie的尺寸也有限制。最好将整个cookie长度限制不超过4095。cookie由浏览器保存的名称、值、域、路径、失效时间和安全标志这几块信息构成。BOM的document.cookie属性的独特之处在于它会因为使用它的方式不同而变现出不同的行为。当用来获取属性值时，它返回当前页面可用的所有cookie的字符串，一系列由分号隔开的名值对儿。当用于设置值的时候，它可以设置为一个新的cookie字符串，并被解释和添加到现有的cookie集合中。设置cookie的格式与Set-Cookie头中使用的格式一样，多个参数中只有cookie的名字和值是必须的。字cookie是存在在单个cookie中的更小段的数据，使用cookie值来存储多个名称值对儿。获取子cookie的方法有两个：get()和getAll()，get()方法获取单个子cookie的值，接收两个参数：cookie的名字和子cookie的名字。而SubCookieUtil.getAll()方法和COokieUtil.get()在解析cookie值的方式上非常相似，区别在于cookie的值并非立即解码。删除子cookie的方法是获取包含在某个cookie中的所有子cookie，然后仅删除需要删除的那个子cookie，然后再将余下的子cookie的值保存在cookie的值。

IE用户数据。微软通过一个自定义行为引入了持久化用户数据的概念，用户数据允许每个文档最多128KB数据，每个域名最多1MB数据。具体操作，使用CSS在某个元素上指定userData行为，接着使用setAttributes()方法在上面保存数据，还可以调用save()方法指定数据空间的名称，在下一次页面载入之后就可以使用load()方法指定同样的数据空间名称来获取数据。

Web Storage主要目的有两个：提供一种在cookie之外存储会话数据的途径，提供一种存储大量可以跨会话存在的数据的机制。Storage类型提供最大的存储空间（因浏览器而异）来存储明值对儿。sessionStorage对象来存储特定于某个会话的数据。globalStorage对象的目的是跨越会话存储数据，但也有特定的访问限制，要使用这个对象，首先要指定哪个域中可以访问该数据，然后通过方括号标记使用属性来实现。localStorage对象在HTML5规范中取代了globalStorage，但是不能给localhostStorage指定任何访问规则，规则事先就要设定好。对Storage对象进行任何修改，都会在文档上出发Storage事件。这个事件的event对象有domain、key、newValue和oldValue属性。

IndexedDB全称是Indexed Database API，是在浏览器中保存结构化数据的一种数据库。IndexedDB设计的操作完全是异步进行的。在得到完整支持的情况下，IndexedDB将是一个uzoweiAPI宿主的全局对象。它的最大特色是使用对象保存数据，而不是使用表来保存数据。调用IndexedDB.open()会返回一个IDBRequest对象，在这个对象上可以添加到onerror和onsuccess事件处理程序。默认情况下，IndexedDB数据库是没有版本号的，可以调用setVersion()方法传入以字符串形式表示的版本号进行指定，同样这个方法也会返回一个请求对象，需要你再指定事件处理程序。使用createObjectStore()方法来构建对象存储空间，第一个参数是全局唯一的键，第二个参数中中的keyPath属性时对象的一个属性，即存储空间的键，另外还有属性值。可以使用add()或put()方法来向其中添加数据。如果添加已经包含键值相同的对象时，add()会返回错误，put()则会重写原有对象。操作数据都是通过事务来完成的，在数据库对象上调用transaction()方法可以创建事务。如果没有参数，就只能通过事务来读取数据库中保存的对象。第一个参数表示访问的一个或多个对象，第二个参数表示访问方式。取得了事务的索引后，使用objectStore()方法并传入存储空间的名称，就可以访问特定的存储空间。使用事务可以直接通过以至的键检索单个对象，而需要检索多个对象则需要在事务内部创建游标。游标就是一指向结果集的指针。与传统数据库查询不同，游标并不提前收集结果。游标指针会先指向结果中的第一项，在接到查找下一项的指令时，才会指向下一项。调用openCursor()方法可以创建游标。使用游标也可以更新个别的记录，调用update()可以用指定的对象更新当前游标的value。对于某些数据，可能需要为一个对象存储空间指定多个键。可以考虑创建索引，首先引用对象存储空间，然后调用createIndex()方法。并发问题。只有当浏览器中仅有一个标签页使用数据库的情况下，调用setVersion()才能完成操作。每次成功打开数据库，都应该指定onversionchange事件处理程序。IndexedDB数据库只能由同源页面操作，占用的磁盘空间也有限制。

23.4 小结 

第24章 最佳实践 

24.1 可维护性

24.2 性能

24.3 部署

24.4 小结

第25章 新兴的API

25.1 requestAnimationFrame() 

25.2 Page Visibility API 

25.3 Geolocation API 

25.4 File API 

25.5 Web计时 

25.6 Web Workers 

25.7 小结

附录A ECMAScript Harmony 

附录B 严格模式

附录C JavaScript库

附录D JavaScript工具
​	
​	
​	

