> CSS选择器世界  
> 张鑫旭   
> 2019年10月第一版  

# 第 1 章 概述 

CSS 选择器本身很简单，就是一些特定的选择符号。实际上， CSS 选择器非常强大，它不仅涉及视觉表现，而且与用户安全、用户体验有非常密切的联系。

## 1.1 为什么CSS选择器很强 

不少开发人员习惯把 CSS 属性或者 CSS 选择器看成一个个独立的个体，就好像传统编程语言中一个个 API 一样。传统编程语言讲求逻辑清晰，层次分明，主要为功能服务，因此这种不脱泥带水的 API 是非常有必要的。但 CSS 确实为样式服务的，它重表现，轻逻辑，如同人的思想一样，相互碰撞才能产生火花。

## 1.2 CSS选择器世界的一些基本概念 
### 1.2.1 选择器、选择符、伪类和伪元素 

CSS 选择器可以分为 4 类，即选择器、选择符、伪类和伪元素。

### 1.2.2 CSS选择器的作用域 

以前 CSS 选择器只有一个全局作用域，也就是在网页任意地方的 CSS 都共用一个文档上下文。

如今 CSS 选择器是有局部作用域的概念的。

### 1.2.3 CSS选择器的命名空间 

命名空间可以让来自多个 XML 词汇表的元素的属性或样式彼此之间没有冲突，它的使用非常常见，例如 XHTML 文档。

## 1.3 无效CSS选择器特性与实际应用 

很多 CSS 伪类选择器是最近几年才出现的，浏览器并不支持，浏览器会把这些选择器当作无效选择器，这是没有任何问题的。但是当这些无效的 CSS 选择器和浏览器支持的 CSS 选择器写在一起的时候，会导致整个选择器无效，举个例子，有如下 CSS 代码。

# 第 2 章 CSS选择器的优先级 

几乎所有的 CSS 样式冲突、样式覆盖等问题都与 CSS 声明的优先级错位有关。因此，在详细阐述 CSS 选择器的优先级规则之前，先快速了解一下 CSS 全部的优先级规则。

## 2.1 CSS优先级规则概览 

CSS 优先级有着明显的不可逾越的等级规则，将其划分为 0 ~ 5 这六个等级，其中前四个等级由 CSS 选择器决定，后两个等级由书写形式和特定语法决定。

## 2.2 深入CSS选择器优先级 
### 2.2.1 CSS选择器优先级的计算规则 

对于 CSS 选择器优先级的计算，业界流传甚广的是数值计数法。

### 2.2.2 256个选择器的越级现象 

同样，256个标签选择器的优先级大于类名选择器的优先级的现象也是存在的。

## 2.3 为什么按钮：hover变色了 
# 第 3 章 CSS选择器的命名 

CSS 选择器的命名问题是最常困扰开发者的事情之一。究竟是面向 CSS 属性命名，还是面向 HTML 语义命名？是使用长命名，还是使用短命名？

## 3.1 CSS选择器是否区分大小写 
## 3.2 CSS选择器命名的合法性 
## 3.3 CSS选择器的命名是一个哲学问题 
### 3.3.1 长命名还是短命名 
### 3.3.2 单命名还是组合命名 
### 3.3.3 面向属性的命名和面向语义的命名 
### 3.3.4 我是如何取名的 
## 3.4 CSS选择器设计的最佳实践 
### 3.4.1 不要使用ID选择器 
### 3.4.2 不要嵌套选择器 
### 3.4.3 不要歧视面向属性的命名 
### 3.4.4 正确使用状态类名 
### 3.4.5 最佳实践汇总 
# 第 4 章 精通CSS选择符 
4.1 后代选择符空格（ ） 
4.1.1 对CSS后代选择符可能错误的认识 
4.1.2 对JavaScript中后代选择符可能错误的认识 
4.2 子选择符箭头（>） 
4.2.1 子选择符和后代选择符的区别 
4.2.2 适合使用子选择符的场景 
4.3 相邻兄弟选择符加号（+） 
4.3.1 相邻兄弟选择符的相关细节 
4.3.2 实现类似：first-child的效果 
4.3.3 众多高级选择器技术的核心 
4.4 随后兄弟选择符弯弯（~） 
4.4.1 和相邻兄弟选择符区别 
4.4.2 为什么没有前面兄弟选择符 
4.4.3 如何实现前面兄弟选择符的效果 
4.5 快速了解列选择符双管道（||） 
# 第 5 章 元素选择器 
5.1 元素选择器的级联语法 
5.2 标签选择器二三事 
5.2.1 标签选择器混合其他选择器的优化 
5.2.2 标签选择器与自定义元素 
5.3 特殊的标签选择器：通配选择器 
# 第 6 章 属性选择器 
6.1 ID选择器和类选择器 
6.2 属性值直接匹配选择器 
6.2.1 详细了解4种选择器 
6.2.2 AMCSS开发模式简介 
6.3 属性值正则匹配选择器 
6.3.1 详细了解3种选择器 
6.3.2 CSS属性选择器搜索过滤技术 
6.4 忽略属性值大小写的正则匹配运算符 
# 第 7 章 用户行为伪类 
7.1 手型经过伪类：hover 
7.1.1 体验优化与：hover延时 
7.1.2 非子元素的：hover显示 
7.1.3 纯：hover显示浮层的体验问题 
7.2 激活状态伪类：active 
7.2.1 ：active伪类概述 
7.2.2 按钮的通用：active样式技巧 
7.2.3 ：active伪类与CSS数据上报 
7.3 焦点伪类：focus 
7.3.1 ：focus伪类匹配机制 
7.3.2 ：focus伪类与outline 
7.3.3 CSS ：focus伪类与键盘无障碍访问 
7.4 整体焦点伪类：focus-within 
7.4.1 ：focus-within和：focus伪类的区别 
7.4.2 ：focus-within实现无障碍访问的下拉列表 
7.5 键盘焦点伪类：focus-visible 
# 第 8 章 URL定位伪类 
8.1 链接历史伪类：link和：visited 
8.1.1 深入理解：link 
8.1.2 怪癖最多的CSS伪类：visited 
8.2 超链接伪类：any-link 
8.3 目标伪类：target 
8.3.1 ：target与锚点 
8.3.2 ：target交互布局技术简介 
8.4 目标容器伪类：target-within 
第9章 输入伪类 
9.1 输入控件状态 
9.1.1 可用状态与禁用状态伪类：enabled和：disabled 
9.1.2 读写特性伪类：read-only和：read-write 
9.1.3 占位符显示伪类：placeholder-shown 
9.1.4 默认选项伪类：default 
9.2 输入值状态 
9.2.1 选中选项伪类：checked 
9.2.2 不确定值伪类：indeterminate 
9.3 输入值验证 
9.3.1 有效性验证伪类：valid和：invalid 
9.3.2 范围验证伪类：in-range和：out-of-range 
9.3.3 可选性伪类：required和：optional 
9.3.4 用户交互伪类：user-invalid和空值伪类：blank 
# 第 10 章 树结构伪类 
10.1 ：root伪类 
10.1.1 ：root伪类和元素 
10.1.2 ：root伪类的应用场景 
10.2 ：empty伪类 
10.2.1 对：empty伪类可能的误解 
10.2.2 超实用超高频使用的：empty伪类 
10.3 子索引伪类 
10.3.1 ：first-child伪类和：last-child伪类 
10.3.2 ：only-child伪类 
10.3.3 ：nth-child()伪类和：nth-last-child()伪类 
10.4 匹配类型的子索引伪类 
10.4.1 ：first-of-type伪类和：last-of-type伪类 
10.4.2 ：only-of-type伪类 
10.4.3 ：nth-of-type()伪类和：nth-last-of-type()伪类 
# 第 11 章 逻辑组合伪类 
11.1 否定伪类：not() 
11.2 了解任意匹配伪类：is() 
11.2.1 ：is()伪类与：matches()伪类及：any()伪类之间的关系 
11.2.2 ：is()伪类的语法与作用 
11.3 了解任意匹配伪类：where() 
11.4 了解关联伪类：has() 
# 第 12 章 其他伪类选择器 
12.1 与作用域相关的伪类 
12.1.1 参考元素伪类：scope 
12.1.2 Shadow树根元素伪类：host 
12.1.3 Shadow树根元素匹配伪类：host() 
12.1.4 Shadow树根元素上下文匹配伪类：host-context() 
12.2 与全屏相关的伪类：fullscreen 
12.3 了解语言相关伪类 
12.3.1 方向伪类：dir() 
12.3.2 语言伪类：lang() 
12.4 了解资源状态伪类 