# 指南

## 小程序框架

小程序开发框架的目标是通过尽可能简单、高效的方式让开发者可以在微信中开发具有原生 APP 体验的服务。

整个小程序框架系统分为两部分：逻辑层（App Service）和 视图层（View）。小程序提供了自己的视图层描述语言 WXML 和 WXSS，以及基于 JavaScript 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，让开发者能够专注于数据与逻辑。

**响应的数据绑定**

框架的核心是一个响应的数据绑定系统，可以让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。

通过这个简单的例子来看：

```js
<!-- This is our View -->
<view> Hello {{name}}! </view>
<button bindtap="changeName"> Click me! </button>
// This is our App Service.
// This is our data.
var helloData = {
  name: 'Weixin'
}

// Register a Page.
Page({
  data: helloData,
  changeName: function(e) {
    // sent data change to view
    this.setData({
      name: 'MINA'
    })
  }
})
```

- 开发者通过框架将逻辑层数据中的 name 与视图层的 name 进行了绑定，所以在页面一打开的时候会显示 Hello Weixin!；
- 当点击按钮的时候，视图层会发送 changeName 的事件给逻辑层，逻辑层找到并执行对应的事件处理函数；
- 回调函数触发后，逻辑层执行 setData 的操作，将 data 中的 name 从 Weixin 变为 MINA，因为该数据和视图层已经绑定了，从而视图层会自动改变为 Hello MINA!。

**页面管理**

框架管理了整个小程序的页面路由，可以做到页面间的无缝切换，并给以页面完整的生命周期。开发者需要做的只是将页面的数据、方法、生命周期函数注册到框架中，其他的一切复杂的操作都交由框架处理。

**基础组件**

框架提供了一套基础的组件，这些组件自带微信风格的样式以及特殊的逻辑，开发者可以通过组合基础组件，创建出强大的微信小程序。

**丰富的API**

框架提供丰富的微信原生 API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。

### 场景值

场景值用来描述用户进入小程序的路径。完整场景值的含义请查看场景值列表。

由于Android系统限制，目前还无法获取到按 Home 键退出到桌面，然后从桌面再次进小程序的场景值，对于这种情况，会保留上一次的场景值。

开发者可以通过下列方式获取场景值：

- 对于小程序，可以在 App 的 onLaunch 和 onShow，或`wx.getLaunchOptionsSync` 中获取上述场景值。
- 对于小游戏，可以在 wx.getLaunchOptionsSync 和 wx.onShow 中获取上述场景值

返回来源信息的场景

部分场景值下还可以获取来源应用、公众号或小程序的appId。获取方式请参考对应API的参考文档。

### 逻辑层 App Service

小程序开发框架的逻辑层使用 JavaScript 引擎为小程序提供开发者 JavaScript 代码的运行环境以及微信小程序的特有功能。

逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。

开发者写的所有代码最终将会打包成一份 JavaScript 文件，并在小程序启动的时候运行，直到小程序销毁。这一行为类似 ServiceWorker，所以逻辑层也称之为 App Service。

在 JavaScript 的基础上，我们增加了一些功能，以方便小程序的开发：

- 增加 App 和 Page 方法，进行程序注册和页面注册。
- 增加 getApp 和 getCurrentPages 方法，分别用来获取 App 实例和当前页面栈。
- 提供丰富的 API，如微信用户数据，扫一扫，支付等微信特有能力。
- 提供模块化能力，每个页面有独立的作用域。

注意：小程序框架的逻辑层并非运行在浏览器中，因此 JavaScript 在 web 中一些能力都无法使用，如 window，document 等。

#### 注册小程序

每个小程序都需要在 app.js 中调用 App 方法注册小程序实例，绑定生命周期回调函数、错误监听和页面不存在监听函数等。

```js
// app.js
App({
  onLaunch (options) {
    // Do something initial when launch.
  },
  onShow (options) {
    // Do something when show.
  },
  onHide () {
    // Do something when hide.
  },
  onError (msg) {
    console.log(msg)
  },
  globalData: 'I am global data'
})
```

整个小程序只有一个 App 实例，是全部页面共享的。开发者可以通过 getApp 方法获取到全局唯一的 App 实例，获取App上的数据或调用开发者注册在 App 上的函数。

```js
// xxx.js
const appInstance = getApp()
console.log(appInstance.globalData) // I am global data
```

#### 注册页面

对于小程序中的每个页面，都需要在页面对应的 js 文件中进行注册，指定页面的初始数据、生命周期回调、事件处理函数等。

**使用 Page 构造器注册页面**
简单的页面可以使用 Page() 进行构造。

代码示例：
```js
//index.js
Page({
  data: {
    text: "This is page data."
  },
  onLoad: function(options) {
    // 页面创建时执行
  },
  onShow: function() {
    // 页面出现在前台时执行
  },
  onReady: function() {
    // 页面首次渲染完毕时执行
  },
  onHide: function() {
    // 页面从前台变为后台时执行
  },
  onUnload: function() {
    // 页面销毁时执行
  },
  onPullDownRefresh: function() {
    // 触发下拉刷新时执行
  },
  onReachBottom: function() {
    // 页面触底时执行
  },
  onShareAppMessage: function () {
    // 页面被用户分享时执行
  },
  onPageScroll: function() {
    // 页面滚动时执行
  },
  onResize: function() {
    // 页面尺寸变化时执行
  },
  onTabItemTap(item) {
    // tab 点击时执行
    console.log(item.index)
    console.log(item.pagePath)
    console.log(item.text)
  },
  // 事件响应函数
  viewTap: function() {
    this.setData({
      text: 'Set some data for updating view.'
    }, function() {
      // this is setData callback
    })
  },
  // 自由数据
  customData: {
    hi: 'MINA'
  }
})
```

**在页面中使用 behaviors**

页面可以引用 behaviors 。 behaviors 可以用来让多个页面有相同的数据字段和方法。

```js
// my-behavior.js
module.exports = Behavior({
  data: {
    sharedText: 'This is a piece of data shared between pages.'
  },
  methods: {
    sharedMethod: function() {
      this.data.sharedText === 'This is a piece of data shared between pages.'
    }
  }
})
// page-a.js
var myBehavior = require('./my-behavior.js')
Page({
  behaviors: [myBehavior],
  onLoad: function() {
    this.data.sharedText === 'This is a piece of data shared between pages.'
  }
})
```

**使用 Component 构造器构造页面**

Page 构造器适用于简单的页面。但对于复杂的页面， Page 构造器可能并不好用。

此时，可以使用 Component 构造器来构造页面。 Component 构造器的主要区别是：方法需要放在 `methods: {}` 里面。

代码示例：

```js
Component({
  data: {
    text: "This is page data."
  },
  methods: {
    onLoad: function(options) {
      // 页面创建时执行
    },
    onPullDownRefresh: function() {
      // 下拉刷新时执行
    },
    // 事件响应函数
    viewTap: function() {
      // ...
    }
  }
})
```

这种创建方式非常类似于 自定义组件 ，可以像自定义组件一样使用 behaviors 等高级特性。

#### 页面生命周期
#### 页面路由
#### 模块化
#### API

## 自定义组件

开发者可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用；也可以将复杂的页面拆分成多个低耦合的模块，有助于代码维护。自定义组件在使用时与基础组件非常相似。

**创建自定义组件**

类似于页面，一个自定义组件由 json wxml wxss js 4 个文件组成。要编写一个自定义组件，首先需要在 json 文件中进行自定义组件声明（将 component 字段设为 true 可将这一组文件设为自定义组件）：

```json
{
  "component": true
}
```

同时，还要在 wxml 文件中编写组件模板，在 wxss 文件中加入组件样式，它们的写法与页面的写法类似。具体细节和注意事项参见 组件模板和样式 。

注意：在组件 wxss 中不应使用 ID 选择器、属性选择器和标签名选择器。

在自定义组件的 js 文件中，需要使用 Component() 来注册组件，并提供组件的属性定义、内部数据和自定义方法。

组件的属性值和内部数据将被用于组件 wxml 的渲染，其中，属性值是可由组件外部传入的。更多细节参见 Component 构造器 。

代码示例：

```js
Component({
  properties: {
    // 这里定义了innerText属性，属性值可以在组件使用时指定
    innerText: {
      type: String,
      value: "default value",
    },
  },
  data: {
    // 这里是一些组件内部数据
    someData: {},
  },
  methods: {
    // 这里是一个自定义方法
    customMethod: function () {},
  },
});
```

**使用自定义组件**

使用已注册的自定义组件前，首先要在页面的 json 文件中进行引用声明。此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径：

```json
{
  "usingComponents": {
    "component-tag-name": "path/to/the/custom/component"
  }
}
```

这样，在页面的 wxml 中就可以像使用基础组件一样使用自定义组件。节点名即自定义组件的标签名，节点属性即传递给组件的属性值。

开发者工具 1.02.1810190 及以上版本支持在 app.json 中声明 usingComponents 字段，在此处声明的自定义组件视为全局自定义组件，在小程序内的页面或自定义组件中可以直接使用而无需再声明。

代码示例：

```html
<view>
  <!-- 以下是对一个自定义组件的引用 -->
  <component-tag-name inner-text="Some text"></component-tag-name>
</view>
```

自定义组件的 wxml 节点结构在与数据结合之后，将被插入到引用位置内。

**细节注意事项**

一些需要注意的细节：

- 因为 WXML 节点标签名只能是小写字母、中划线和下划线的组合，所以自定义组件的标签名也只能包含这些字符。
- 自定义组件也是可以引用自定义组件的，引用方法类似于页面引用自定义组件的方式（使用 usingComponents 字段）。
- 自定义组件和页面所在项目根目录名不能以“wx-”为前缀，否则会报错。

注意，是否在页面文件中使用 usingComponents 会使得页面的 this 对象的原型稍有差异，包括：

- 使用 usingComponents 页面的原型与不使用时不一致，即 Object.getPrototypeOf(this) 结果不同。
- 使用 usingComponents 时会多一些方法，如 selectComponent 。
- 出于性能考虑，使用 usingComponents 时， setData 内容不会被直接深复制，即 this.setData({ field: obj }) 后 this.data.field === obj 。（深复制会在这个值被组件间传递时发生。）

如果页面比较复杂，新增或删除 usingComponents 定义段时建议重新测试一下。

### 组件模板和样式

类似于页面，自定义组件拥有自己的 wxml 模板和 wxss 样式。

**组件模板**

组件模板的写法与页面模板相同。组件模板与组件数据结合后生成的节点树，将被插入到组件的引用位置上。

在组件模板中可以提供一个 <slot> 节点，用于承载组件引用时提供的子节点。

代码示例：

```html
<!-- 组件模板 -->
<view class="wrapper">
  <view>这里是组件的内部节点</view>
  <slot></slot>
</view>
<!-- 引用组件的页面模板 -->
<view>
  <component-tag-name>
    <!-- 这部分内容将被放置在组件 <slot> 的位置上 -->
    <view>这里是插入到组件slot中的内容</view>
  </component-tag-name>
</view>
```

注意，在模板中引用到的自定义组件及其对应的节点名需要在 json 文件中显式定义，否则会被当作一个无意义的节点。除此以外，节点名也可以被声明为抽象节点。

**模板数据绑定**

与普通的 WXML 模板类似，可以使用数据绑定，这样就可以向子组件的属性传递动态数据。

代码示例：

```html
<!-- 引用组件的页面模板 -->
<view>
  <component-tag-name prop-a="{{dataFieldA}}" prop-b="{{dataFieldB}}">
    <!-- 这部分内容将被放置在组件 <slot> 的位置上 -->
    <view>这里是插入到组件slot中的内容</view>
  </component-tag-name>
</view>
```

在以上例子中，组件的属性 propA 和 propB 将收到页面传递的数据。页面可以通过 setData 来改变绑定的数据字段。

注意：这样的数据绑定只能传递 JSON 兼容数据。自基础库版本 2.0.9 开始，还可以在数据中包含函数（但这些函数不能在 WXML 中直接调用，只能传递给子组件）。

**组件 wxml 的 slot**

在组件的 wxml 中可以包含 slot 节点，用于承载组件使用者提供的 wxml 结构。

默认情况下，一个组件的 wxml 中只能有一个 slot 。需要使用多 slot 时，可以在组件 js 中声明启用。

```js
Component({
  options: {
    multipleSlots: true, // 在组件定义时的选项中启用多slot支持
  },
  properties: {
    /* ... */
  },
  methods: {
    /* ... */
  },
});
```

此时，可以在这个组件的 wxml 中使用多个 slot ，以不同的 name 来区分。

```html
<!-- 组件模板 -->
<view class="wrapper">
  <slot name="before"></slot>
  <view>这里是组件的内部细节</view>
  <slot name="after"></slot>
</view>
```

使用时，用 slot 属性来将节点插入到不同的 slot 上。

```html
<!-- 引用组件的页面模板 -->
<view>
  <component-tag-name>
    <!-- 这部分内容将被放置在组件 <slot name="before"> 的位置上 -->
    <view slot="before">这里是插入到组件slot name="before"中的内容</view>
    <!-- 这部分内容将被放置在组件 <slot name="after"> 的位置上 -->
    <view slot="after">这里是插入到组件slot name="after"中的内容</view>
  </component-tag-name>
</view>
```

**组件样式**

组件对应 wxss 文件的样式，只对组件 wxml 内的节点生效。编写组件样式时，需要注意以下几点：

- 组件和引用组件的页面不能使用 id 选择器（#a）、属性选择器（[a]）和标签名选择器，请改用 class 选择器。
- 组件和引用组件的页面中使用后代选择器（.a .b）在一些极端情况下会有非预期的表现，如遇，请避免使用。
- 子元素选择器（.a>.b）只能用于 view 组件与其子节点之间，用于其他组件可能导致非预期的情况。
- 继承样式，如 font 、 color ，会从组件外继承到组件内。
- 除继承样式外， app.wxss 中的样式、组件所在页面的的样式对自定义组件无效（除非更改组件样式隔离选项）。

```css
#a {
} /* 在组件中不能使用 */
[a] {
} /* 在组件中不能使用 */
button {
} /* 在组件中不能使用 */
.a > .b {
} /* 除非 .a 是 view 组件节点，否则不一定会生效 */
```

除此以外，组件可以指定它所在节点的默认样式，使用 :host 选择器（需要包含基础库 1.7.2 或更高版本的开发者工具支持）。

代码示例：

```css
/* 组件 custom-component.wxss */
:host {
  color: yellow;
}
```

```html
<!-- 页面的 WXML -->
<custom-component>这段文本是黄色的</custom-component>
```

**组件样式隔离**

默认情况下，自定义组件的样式只受到自定义组件 wxss 的影响。除非以下两种情况：

1. app.wxss 或页面的 wxss 中使用了标签名选择器（或一些其他特殊选择器）来直接指定样式，这些选择器会影响到页面和全部组件。通常情况下这是不推荐的做法。
2. 指定特殊的样式隔离选项 styleIsolation 。

```js
Component({
  options: {
    styleIsolation: "isolated",
  },
});
```

styleIsolation 选项从基础库版本 2.6.5 开始支持。它支持以下取值：

- isolated 表示启用样式隔离，在自定义组件内外，使用 class 指定的样式将不会相互影响（一般情况下的默认值）；
- apply-shared 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面；
- shared 表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss 中指定的样式也会影响页面和其他设置了 apply-shared 或 shared 的自定义组件。（这个选项在插件中不可用。）

使用后两者时，请务必注意组件间样式的相互影响。

如果这个 Component 构造器用于构造页面 ，则默认值为 shared ，且还有以下几个额外的样式隔离选项可用：

- page-isolated 表示在这个页面禁用 app.wxss ，同时，页面的 wxss 不会影响到其他自定义组件；
- page-apply-shared 表示在这个页面禁用 app.wxss ，同时，页面 wxss 样式不会影响到其他自定义组件，但设为 shared 的自定义组件会影响到页面；
- page-shared 表示在这个页面禁用 app.wxss ，同时，页面 wxss 样式会影响到其他设为 apply-shared 或 shared 的自定义组件，也会受到设为 shared 的自定义组件的影响。

从小程序基础库版本 2.10.1 开始，也可以在页面或自定义组件的 json 文件中配置 styleIsolation （这样就不需在 js 文件的 options 中再配置）。例如：

```json
{
  "styleIsolation": "isolated"
}
```

此外，小程序基础库版本 2.2.3 以上支持 addGlobalClass 选项，即在 Component 的 options 中设置 addGlobalClass: true 。 这个选项等价于设置 styleIsolation: apply-shared ，但设置了 styleIsolation 选项后这个选项会失效。

代码示例：

```js
/* 组件 custom-component.js */
Component({
  options: {
    addGlobalClass: true,
  },
});
```

```html
<!-- 组件 custom-component.wxml -->
<text class="red-text"
  >这段文本的颜色由 `app.wxss` 和页面 `wxss` 中的样式定义来决定</text
>
```

```css
/* app.wxss */
.red-text {
  color: red;
}
```

**外部样式类**

基础库 1.9.90 开始支持，低版本需做兼容处理。

有时，组件希望接受外部传入的样式类。此时可以在 Component 中用 externalClasses 定义段定义若干个外部样式类。

这个特性可以用于实现类似于 view 组件的 hover-class 属性：页面可以提供一个样式类，赋予 view 的 hover-class ，这个样式类本身写在页面中而非 view 组件的实现中。

注意：在同一个节点上使用普通样式类和外部样式类时，两个类的优先级是未定义的，因此最好避免这种情况。

代码示例：

```css
/* 组件 custom-component.js */
Component({
  externalClasses: ['my-class']
})
```

```html
<!-- 组件 custom-component.wxml -->
<custom-component class="my-class"
  >这段文本的颜色由组件外的 class 决定</custom-component
>
```

这样，组件的使用者可以指定这个样式类对应的 class ，就像使用普通属性一样。在 2.7.1 之后，可以指定多个对应的 class 。

代码示例：

```html
<!-- 页面的 WXML -->
<custom-component my-class="red-text" />
<custom-component my-class="large-text" />
<!-- 以下写法需要基础库版本 2.7.1 以上 -->
<custom-component my-class="red-text large-text" />
```

```css
.red-text {
  color: red;
}
.large-text {
  font-size: 1.5em;
}
```

**引用页面或父组件的样式**

基础库 2.9.2 开始支持，低版本需做兼容处理。

即使启用了样式隔离 isolated ，组件仍然可以在局部引用组件所在页面的样式或父组件的样式。

例如，如果在页面 wxss 中定义了：

```css
.blue-text {
  color: blue;
}
```

在这个组件中可以使用 ~ 来引用这个类的样式：

```html
<view class="~blue-text"> 这段文本是蓝色的 </view>
```

如果在一个组件的父组件 wxss 中定义了：

```css
.red-text {
  color: red;
}
```

在这个组件中可以使用 ^ 来引用这个类的样式：

```html
<view class="^red-text"> 这段文本是红色的 </view>
```

也可以连续使用多个 ^ 来引用祖先组件中的样式。

注意：如果组件是比较独立、通用的组件，请优先使用外部样式类的方式，而非直接引用父组件或页面的样式。

**虚拟化组件节点**

基础库 2.11.2 开始支持，低版本需做兼容处理。

默认情况下，自定义组件本身的那个节点是一个“普通”的节点，使用时可以在这个节点上设置 class style 、动画、 flex 布局等，就如同普通的 view 组件节点一样。

```html
<!-- 页面的 WXML -->
<view style="display: flex">
  <!-- 默认情况下，这是一个普通的节点 -->
  <custom-component style="color: blue; flex: 1">蓝色、满宽的</custom-component>
</view>
```

但有些时候，自定义组件并不希望这个节点本身可以设置样式、响应 flex 布局等，而是希望自定义组件内部的第一层节点能够响应 flex 布局或者样式由自定义组件本身完全决定。

这种情况下，可以将这个自定义组件设置为“虚拟的”：

```js
Component({
  options: {
    virtualHost: true,
  },
  properties: {
    style: {
      // 定义 style 属性可以拿到 style 属性上设置的值
      type: String,
    },
  },
  externalClass: ["class"], // 可以将 class 设为 externalClass
});
```

这样，可以将 flex 放入自定义组件内：

```html
<!-- 页面的 WXML -->
<view style="display: flex">
  <!-- 如果设置了 virtualHost ，节点上的样式将失效 -->
  <custom-component style="color: blue">不是蓝色的</custom-component>
</view>
<!-- custom-component.wxml -->
<view style="flex: 1">
  满宽的
  <slot></slot>
</view>
```

需要注意的是，自定义组件节点上的 class style 和动画将不再生效，但仍可以：

- 将 style 定义成 properties 属性来获取 style 上设置的值；
- 将 class 定义成 externalClasses 外部样式类使得自定义组件 wxml 可以使用 class 值。

### Component 构造器

Component 构造器可用于定义组件，调用 Component 构造器时可以指定组件的属性、数据、方法等。

详细的参数含义和使用请参考 Component 参考文档。

```js
Component({
  behaviors: [],

  properties: {
    myProperty: {
      // 属性名
      type: String,
      value: "",
    },
    myProperty2: String, // 简化的定义方式
  },

  data: {}, // 私有数据，可用于模板渲染

  lifetimes: {
    // 生命周期函数，可以为函数，或一个在methods段中定义的方法名
    attached: function () {},
    moved: function () {},
    detached: function () {},
  },

  // 生命周期函数，可以为函数，或一个在methods段中定义的方法名
  attached: function () {}, // 此处attached的声明会被lifetimes字段中的声明覆盖
  ready: function () {},

  pageLifetimes: {
    // 组件所在页面的生命周期函数
    show: function () {},
    hide: function () {},
    resize: function () {},
  },

  methods: {
    onMyButtonTap: function () {
      this.setData({
        // 更新属性和数据的方法与更新页面数据的方法类似
      });
    },
    // 内部方法建议以下划线开头
    _myPrivateMethod: function () {
      // 这里将 data.A[0].B 设为 'myPrivateData'
      this.setData({
        "A[0].B": "myPrivateData",
      });
    },
    _propertyChange: function (newVal, oldVal) {},
  },
});
```

**使用 Component 构造器构造页面**

事实上，小程序的页面也可以视为自定义组件。因而，页面也可以使用 Component 构造器构造，拥有与普通组件一样的定义段与实例方法。但此时要求对应 json 文件中包含 usingComponents 定义段。

此时，组件的属性可以用于接收页面的参数，如访问页面 /pages/index/index?paramA=123&paramB=xyz ，如果声明有属性 paramA 或 paramB ，则它们会被赋值为 123 或 xyz 。

页面的生命周期方法（即 on 开头的方法），应写在 methods 定义段中。

代码示例：

```js
{
  "usingComponents": {}
}
Component({

  properties: {
    paramA: Number,
    paramB: String,
  },

  methods: {
    onLoad: function() {
      this.data.paramA // 页面参数 paramA 的值
      this.data.paramB // 页面参数 paramB 的值
    }
  }

})
```

使用 Component 构造器来构造页面的一个好处是可以使用 behaviors 来提取所有页面中公用的代码段。

例如，在所有页面被创建和销毁时都要执行同一段代码，就可以把这段代码提取到 behaviors 中。

代码示例：

```js
// page-common-behavior.js
module.exports = Behavior({
  attached: function () {
    // 页面创建时执行
    console.info("Page loaded!");
  },
  detached: function () {
    // 页面销毁时执行
    console.info("Page unloaded!");
  },
});
// 页面 A
var pageCommonBehavior = require("./page-common-behavior");
Component({
  behaviors: [pageCommonBehavior],
  data: {
    /* ... */
  },
  methods: {
    /* ... */
  },
});
// 页面 B
var pageCommonBehavior = require("./page-common-behavior");
Component({
  behaviors: [pageCommonBehavior],
  data: {
    /* ... */
  },
  methods: {
    /* ... */
  },
});
```

### 组件间通信与事件

**组件间通信**

组件间的基本通信方式有以下几种。

- WXML 数据绑定：用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容数据（自基础库版本 2.0.9 开始，还可以在数据中包含函数）。具体在 组件模板和样式 章节中介绍。
- 事件：用于子组件向父组件传递数据，可以传递任意数据。

如果以上两种方式不足以满足需要，父组件还可以通过 this.selectComponent 方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法。

**监听事件**

事件系统是组件间通信的主要方式之一。自定义组件可以触发任意的事件，引用组件的页面可以监听这些事件。关于事件的基本概念和用法，参见 事件 。

监听自定义组件事件的方法与监听基础组件事件的方法完全一致：

代码示例：

```html
<!-- 当自定义组件触发“myevent”事件时，调用“onMyEvent”方法 -->
<component-tag-name bindmyevent="onMyEvent" />
<!-- 或者可以写成 -->
<component-tag-name bind:myevent="onMyEvent" />
```

```js
Page({
  onMyEvent: function (e) {
    e.detail; // 自定义组件触发事件时提供的detail对象
  },
});
```

**触发事件**

自定义组件触发事件时，需要使用 triggerEvent 方法，指定事件名、detail 对象和事件选项：

代码示例：

在开发者工具中预览效果

```html
<!-- 在自定义组件中 -->
<button bindtap="onTap">点击这个按钮将触发“myevent”事件</button>
```

```js
Component({
  properties: {},
  methods: {
    onTap: function () {
      var myEventDetail = {}; // detail对象，提供给事件监听函数
      var myEventOption = {}; // 触发事件的选项
      this.triggerEvent("myevent", myEventDetail, myEventOption);
    },
  },
});
```

触发事件的选项包括：

| 选项名       | 类型    | 是否必填 | 默认值 | 描述                                                                                              |
| ------------ | ------- | -------- | ------ | ------------------------------------------------------------------------------------------------- |
| bubbles      | Boolean | 否       | false  | 事件是否冒泡                                                                                      |
| composed     | Boolean | 否       | false  | 事件是否可以穿越组件边界，为 false 时，事件将只能在引用组件的节点树上触发，不进入其他任何组件内部 |
| capturePhase | Boolean | 否       | false  | 事件是否拥有捕获阶段                                                                              |

关于冒泡和捕获阶段的概念，请阅读 事件 章节中的相关说明。

代码示例：

在开发者工具中预览效果

```html
<!-- 页面 page.wxml -->
<another-component bindcustomevent="pageEventListener1">
  <my-component bindcustomevent="pageEventListener2"></my-component>
</another-component>
<!-- 组件 another-component.wxml -->
<view bindcustomevent="anotherEventListener">
  <slot />
</view>
<!-- 组件 my-component.wxml -->
<view bindcustomevent="myEventListener">
  <slot />
</view>
```

```js
// 组件 my-component.js
Component({
  methods: {
    onTap: function () {
      this.triggerEvent("customevent", {}); // 只会触发 pageEventListener2
      this.triggerEvent("customevent", {}, { bubbles: true }); // 会依次触发 pageEventListener2 、 pageEventListener1
      this.triggerEvent("customevent", {}, { bubbles: true, composed: true }); // 会依次触发 pageEventListener2 、 anotherEventListener 、 pageEventListener1
    },
  },
});
```

**获取组件实例**

可在父组件里调用 this.selectComponent ，获取子组件的实例对象。（插件的自定义组件将返回 null）

调用时需要传入一个匹配选择器 selector，如：this.selectComponent(".my-component")。

selector 详细语法可查看 selector 语法参考文档。

代码示例：

在开发者工具中预览效果

```js
// 父组件
Page({
  data: {},
  getChildComponent: function () {
    const child = this.selectComponent(".my-component");
    console.log(child);
  },
});
```

在上例中，父组件将会获取 class 为 my-component 的子组件实例对象，即子组件的 this 。

若需要自定义 selectComponent 返回的数据，可使用内置 behavior: wx://component-export

从基础库版本 2.2.3 开始提供支持。

使自定义组件中支持 export 定义段，这个定义段可以用于指定组件被 selectComponent 调用时的返回值。

代码示例：

在开发者工具中预览效果

```js
// 自定义组件 my-component 内部
Component({
  behaviors: ["wx://component-export"],
  export() {
    return { myField: "myValue" };
  },
});
```

```html
<!-- 使用自定义组件时 -->
<my-component id="the-id" />
```

```js
// 父组件调用
const child = this.selectComponent("#the-id"); // 等于 { myField: 'myValue' }
```

在上例中，父组件获取 id 为 the-id 的子组件实例的时候，得到的是对象 { myField: 'myValue' } 。

### 组件生命周期

组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发。

其中，最重要的生命周期是 created attached detached ，包含一个组件实例生命流程的最主要时间点。

- 组件实例刚刚被创建好时， created 生命周期被触发。此时，组件数据 this.data 就是在 Component 构造器中定义的数据 data 。 此时还不能调用 setData 。 通常情况下，这个生命周期只应该用于给组件 this 添加一些自定义属性字段。
- 在组件完全初始化完毕、进入页面节点树后， attached 生命周期被触发。此时， this.data 已被初始化为组件的当前值。这个生命周期很有用，绝大多数初始化工作可以在这个时机进行。
- 在组件离开页面节点树后， detached 生命周期被触发。退出一个页面时，如果组件还在页面节点树中，则 detached 会被触发。

**定义生命周期方法**

生命周期方法可以直接定义在 Component 构造器的第一级参数中。

自小程序基础库版本 2.2.3 起，组件的的生命周期也可以在 lifetimes 字段内进行声明（这是推荐的方式，其优先级最高）。

代码示例：

```js
Component({
  lifetimes: {
    attached: function () {
      // 在组件实例进入页面节点树时执行
    },
    detached: function () {
      // 在组件实例被从页面节点树移除时执行
    },
  },
  // 以下是旧式的定义方式，可以保持对 <2.2.3 版本基础库的兼容
  attached: function () {
    // 在组件实例进入页面节点树时执行
  },
  detached: function () {
    // 在组件实例被从页面节点树移除时执行
  },
  // ...
});
```

在 behaviors 中也可以编写生命周期方法，同时不会与其他 behaviors 中的同名生命周期相互覆盖。但要注意，如果一个组件多次直接或间接引用同一个 behavior ，这个 behavior 中的生命周期函数在一个执行时机内只会执行一次。

可用的全部生命周期如下表所示。

| 生命周期 | 参数         | 描述                                     | 最低版本 |
| -------- | ------------ | ---------------------------------------- | -------- |
| created  | 无           | 在组件实例刚刚被创建时执行               | 1.6.3    |
| attached | 无           | 在组件实例进入页面节点树时执行           | 1.6.3    |
| ready    | 无           | 在组件在视图层布局完成后执行             | 1.6.3    |
| moved    | 无           | 在组件实例被移动到节点树另一个位置时执行 | 1.6.3    |
| detached | 无           | 在组件实例被从页面节点树移除时执行       | 1.6.3    |
| error    | Object Error | 每当组件方法抛出错误时执行               | 2.4.1    |

**组件所在页面的生命周期**

还有一些特殊的生命周期，它们并非与组件有很强的关联，但有时组件需要获知，以便组件内部处理。这样的生命周期称为“组件所在页面的生命周期”，在 pageLifetimes 定义段中定义。其中可用的生命周期包括：

| 生命周期 | 参数        | 描述                         | 最低版本 |
| -------- | ----------- | ---------------------------- | -------- |
| show     | 无          | 组件所在的页面被展示时执行   | 2.2.3    |
| hide     | 无          | 组件所在的页面被隐藏时执行   | 2.2.3    |
| resize   | Object Size | 组件所在的页面尺寸变化时执行 | 2.4.0    |

代码示例：

```js
Component({
  pageLifetimes: {
    show: function () {
      // 页面被展示
    },
    hide: function () {
      // 页面被隐藏
    },
    resize: function (size) {
      // 页面尺寸变化
    },
  },
});
```

### behaviors

behaviors 是用于组件间代码共享的特性，类似于一些编程语言中的 “mixins” 或 “traits”。

每个 behavior 可以包含一组属性、数据、生命周期函数和方法。组件引用它时，它的属性、数据和方法会被合并到组件中，生命周期函数也会在对应时机被调用。 每个组件可以引用多个 behavior ，behavior 也可以引用其它 behavior 。

详细的参数含义和使用请参考 Behavior 参考文档。

**组件中使用**

组件引用时，在 behaviors 定义段中将它们逐个列出即可。

代码示例：

在开发者工具中预览效果

```js
// my-component.js
var myBehavior = require("my-behavior");
Component({
  behaviors: [myBehavior],
  properties: {
    myProperty: {
      type: String,
    },
  },
  data: {
    myData: "my-component-data",
  },
  created: function () {
    console.log("[my-component] created");
  },
  attached: function () {
    console.log("[my-component] attached");
  },
  ready: function () {
    console.log("[my-component] ready");
  },
  methods: {
    myMethod: function () {
      console.log("[my-component] log by myMethod");
    },
  },
});
```

在上例中， my-component 组件定义中加入了 my-behavior，

而 my-behavior 结构为：

- 属性：myBehaviorProperty
- 数据字段：myBehaviorData
- 方法：myBehaviorMethod
- 生命周期函数：attached、created、ready

这将使 my-component 最终结构为：

- 属性：myBehaviorProperty、myProperty
- 数据字段：myBehaviorData、myData
- 方法：myBehaviorMethod、myMethod
- 生命周期函数：attached、created、ready

当组件触发生命周期时，上例生命周期函数执行顺序为：

1. [my-behavior] created
2. [my-component] created
3. [my-behavior] attached
4. [my-component] attached
5. [my-behavior] ready
6. [my-component] ready

详细规则参考 同名字段的覆盖和组合规则。

**同名字段的覆盖和组合规则**

组件和它引用的 behavior 中可以包含同名的字段，对这些字段的处理方法如下：

- 如果有同名的属性 (properties) 或方法 (methods)：

  1. 若组件本身有这个属性或方法，则组件的属性或方法会覆盖 behavior 中的同名属性或方法；
  2. 若组件本身无这个属性或方法，则在组件的 behaviors 字段中定义靠后的 behavior 的属性或方法会覆盖靠前的同名属性或方法；
  3. 在 2 的基础上，若存在嵌套引用 behavior 的情况，则规则为：父 behavior 覆盖 子 behavior 中的同名属性或方法。

- 如果有同名的数据字段 (data)：

  1. 若同名的数据字段都是对象类型，会进行对象合并；
  2. 其余情况会进行数据覆盖，覆盖规则为：组件 > 父 behavior > 子 behavior 、 靠后的 behavior > 靠前的 behavior。（优先级高的覆盖优先级低的，最大的为优先级最高）

- 生命周期函数不会相互覆盖，而是在对应触发时机被逐个调用：

  - 对于不同的生命周期函数之间，遵循组件生命周期函数的执行顺序；
  - 对于同种生命周期函数，遵循如下规则：
    - behavior 优先于组件执行；
    - 子 behavior 优先于 父 behavior 执行；
    - 靠前的 behavior 优先于 靠后的 behavior 执行；
  - 如果同一个 behavior 被一个组件多次引用，它定义的生命周期函数只会被执行一次。

代码示例：

在开发者工具中预览效果

**内置 behaviors**

自定义组件可以通过引用内置的 behavior 来获得内置组件的一些行为。

```js
Component({
  behaviors: ["wx://form-field"],
});
```

在上例中， wx://form-field 代表一个内置 behavior ，它使得这个自定义组件有类似于表单控件的行为。

内置 behavior 往往会为组件添加一些属性。在没有特殊说明时，组件可以覆盖这些属性来改变它的 type 或添加 observer 。

- wx://form-field

使自定义组件有类似于表单控件的行为。 form 组件可以识别这些自定义组件，并在 submit 事件中返回组件的字段名及其对应字段值。

详细用法以及代码示例可见：form 组件参考文档

- wx://form-field-group

从基础库版本 2.10.2 开始提供支持。

使 form 组件可以识别到这个自定义组件内部的所有表单控件。

详细用法以及代码示例可见：form 组件参考文档

- wx://form-field-button

从基础库版本 2.10.3 开始提供支持。

使 form 组件可以识别到这个自定义组件内部的 button 。如果自定义组件内部有设置了 form-type 的 button ，它将被组件外的 form 接受。

详细用法以及代码示例可见：form 组件参考文档

- wx://component-export

从基础库版本 2.2.3 开始提供支持。

使自定义组件支持 export 定义段。这个定义段可以用于指定组件被 selectComponent 调用时的返回值。

详细用法以及代码示例可见：selectComponent 参考文档

### 组件间关系

**定义和使用组件间关系**

有时需要实现这样的组件：

```js
<custom-ul>
  <custom-li> item 1 </custom-li>
  <custom-li> item 2 </custom-li>
</custom-ul>
```

这个例子中， custom-ul 和 custom-li 都是自定义组件，它们有相互间的关系，相互间的通信往往比较复杂。此时在组件定义时加入 relations 定义段，可以解决这样的问题。示例：

在开发者工具中预览效果

```js
// path/to/custom-ul.js
Component({
  relations: {
    "./custom-li": {
      type: "child", // 关联的目标节点应为子节点
      linked: function (target) {
        // 每次有custom-li被插入时执行，target是该节点实例对象，触发在该节点attached生命周期之后
      },
      linkChanged: function (target) {
        // 每次有custom-li被移动后执行，target是该节点实例对象，触发在该节点moved生命周期之后
      },
      unlinked: function (target) {
        // 每次有custom-li被移除时执行，target是该节点实例对象，触发在该节点detached生命周期之后
      },
    },
  },
  methods: {
    _getAllLi: function () {
      // 使用getRelationNodes可以获得nodes数组，包含所有已关联的custom-li，且是有序的
      var nodes = this.getRelationNodes("path/to/custom-li");
    },
  },
  ready: function () {
    this._getAllLi();
  },
});
// path/to/custom-li.js
Component({
  relations: {
    "./custom-ul": {
      type: "parent", // 关联的目标节点应为父节点
      linked: function (target) {
        // 每次被插入到custom-ul时执行，target是custom-ul节点实例对象，触发在attached生命周期之后
      },
      linkChanged: function (target) {
        // 每次被移动后执行，target是custom-ul节点实例对象，触发在moved生命周期之后
      },
      unlinked: function (target) {
        // 每次被移除时执行，target是custom-ul节点实例对象，触发在detached生命周期之后
      },
    },
  },
});
```

注意：必须在两个组件定义中都加入 relations 定义，否则不会生效。

**关联一类组件**

在开发者工具中预览效果

有时，需要关联的是一类组件，如：

```html
<custom-form>
  <view>
    input
    <custom-input></custom-input>
  </view>
  <custom-submit> submit </custom-submit>
</custom-form>
```

custom-form 组件想要关联 custom-input 和 custom-submit 两个组件。此时，如果这两个组件都有同一个 behavior：

```js
// path/to/custom-form-controls.js
module.exports = Behavior({
  // ...
});
// path/to/custom-input.js
var customFormControls = require("./custom-form-controls");
Component({
  behaviors: [customFormControls],
  relations: {
    "./custom-form": {
      type: "ancestor", // 关联的目标节点应为祖先节点
    },
  },
});
// path/to/custom-submit.js
var customFormControls = require("./custom-form-controls");
Component({
  behaviors: [customFormControls],
  relations: {
    "./custom-form": {
      type: "ancestor", // 关联的目标节点应为祖先节点
    },
  },
});
```

则在 relations 关系定义中，可使用这个 behavior 来代替组件路径作为关联的目标节点：

```js
// path/to/custom-form.js
var customFormControls = require("./custom-form-controls");
Component({
  relations: {
    customFormControls: {
      type: "descendant", // 关联的目标节点应为子孙节点
      target: customFormControls,
    },
  },
});
```

**relations 定义段**

relations 定义段包含目标组件路径及其对应选项，可包含的选项见下表。

| 选项        | 类型     | 是否必填 | 描述                                                                                                    |
| ----------- | -------- | -------- | ------------------------------------------------------------------------------------------------------- |
| type        | String   | 是       | 目标组件的相对关系，可选的值为 parent 、 child 、 ancestor 、 descendant                                |
| linked      | Function | 否       | 关系生命周期函数，当关系被建立在页面节点树中时触发，触发时机在组件 attached 生命周期之后                |
| linkChanged | Function | 否       | 关系生命周期函数，当关系在页面节点树中发生改变时触发，触发时机在组件 moved 生命周期之后                 |
| unlinked    | Function | 否       | 关系生命周期函数，当关系脱离页面节点树时触发，触发时机在组件 detached 生命周期之后                      |
| target      | String   | 否       | 如果这一项被设置，则它表示关联的目标节点所应具有的 behavior，所有拥有这一 behavior 的组件节点都会被关联 |

### 数据监听器

数据监听器可以用于监听和响应任何属性和数据字段的变化。从小程序基础库版本 2.6.1 开始支持。

**使用数据监听器**
有时，在一些数据字段被 setData 设置时，需要执行一些操作。

例如， this.data.sum 永远是 this.data.numberA 与 this.data.numberB 的和。此时，可以使用数据监听器进行如下实现。

```js
Component({
  attached: function () {
    this.setData({
      numberA: 1,
      numberB: 2,
    });
  },
  observers: {
    "numberA, numberB": function (numberA, numberB) {
      // 在 numberA 或者 numberB 被设置时，执行这个函数
      this.setData({
        sum: numberA + numberB,
      });
    },
  },
});
```

在开发者工具中预览效果

**监听字段语法**
数据监听器支持监听属性或内部数据的变化，可以同时监听多个。一次 setData 最多触发每个监听器一次。

同时，监听器可以监听子数据字段，如下例所示。

```js
Component({
  observers: {
    "some.subfield": function (subfield) {
      // 使用 setData 设置 this.data.some.subfield 时触发
      // （除此以外，使用 setData 设置 this.data.some 也会触发）
      subfield === this.data.some.subfield;
    },
    "arr[12]": function (arr12) {
      // 使用 setData 设置 this.data.arr[12] 时触发
      // （除此以外，使用 setData 设置 this.data.arr 也会触发）
      arr12 === this.data.arr[12];
    },
  },
});
```

如果需要监听所有子数据字段的变化，可以使用通配符 \*\* 。

```js
Component({
  observers: {
    "some.field.**": function (field) {
      // 使用 setData 设置 this.data.some.field 本身或其下任何子数据字段时触发
      // （除此以外，使用 setData 设置 this.data.some 也会触发）
      field === this.data.some.field;
    },
  },
  attached: function () {
    // 这样会触发上面的 observer
    this.setData({
      "some.field": {
        /* ... */
      },
    });
    // 这样也会触发上面的 observer
    this.setData({
      "some.field.xxx": {
        /* ... */
      },
    });
    // 这样还是会触发上面的 observer
    this.setData({
      some: {
        /* ... */
      },
    });
  },
});
```

特别地，仅使用通配符 \*\* 可以监听全部 setData 。

```js
Component({
  observers: {
    "**": function () {
      // 每次 setData 都触发
    },
  },
});
```

Bugs & Tips:

数据监听器监听的是 setData 涉及到的数据字段，即使这些数据字段的值没有发生变化，数据监听器依然会被触发。
如果在数据监听器函数中使用 setData 设置本身监听的数据字段，可能会导致死循环，需要特别留意。
数据监听器和属性的 observer 相比，数据监听器更强大且通常具有更好的性能。

### 纯数据字段

纯数据字段是一些不用于界面渲染的 data 字段，可以用于提升页面更新性能。从小程序基础库版本 2.8.2 开始支持。

**组件数据中的纯数据字段**
有些情况下，某些 data 中的字段（包括 setData 设置的字段）既不会展示在界面上，也不会传递给其他组件，仅仅在当前组件内部使用。

此时，可以指定这样的数据字段为“纯数据字段”，它们将仅仅被记录在 this.data 中，而不参与任何界面渲染过程，这样有助于提升页面更新性能。

指定“纯数据字段”的方法是在 Component 构造器的 options 定义段中指定 pureDataPattern 为一个正则表达式，字段名符合这个正则表达式的字段将成为纯数据字段。

在开发者工具中预览效果

代码示例：

```js
Component({
  options: {
    pureDataPattern: /^_/, // 指定所有 _ 开头的数据字段为纯数据字段
  },
  data: {
    a: true, // 普通数据字段
    _b: true, // 纯数据字段
  },
  methods: {
    myMethod() {
      this.data._b; // 纯数据字段可以在 this.data 中获取
      this.setData({
        c: true, // 普通数据字段
        _d: true, // 纯数据字段
      });
    },
  },
});
// 上述组件中的纯数据字段不会被应用到 WXML 上：
<view wx:if="{{a}}"> 这行会被展示 </view>
<view wx:if="{{_b}}"> 这行不会被展示 </view>
```

**组件属性中的纯数据字段**
属性也可以被指定为纯数据字段（遵循 pureDataPattern 的正则表达式）。

属性中的纯数据字段可以像普通属性一样接收外部传入的属性值，但不能将它直接用于组件自身的 WXML 中。

代码示例：

```js
Component({
  options: {
    pureDataPattern: /^_/,
  },
  properties: {
    a: Boolean,
    _b: {
      type: Boolean,
      observer() {
        // 不要这样做！这个 observer 永远不会被触发
      },
    },
  },
});
```

注意：属性中的纯数据字段的属性 observer 永远不会触发！如果想要监听属性值变化，使用 数据监听器 代替。

从小程序基础库版本 2.10.1 开始，也可以在页面或自定义组件的 json 文件中配置 pureDataPattern （这样就不需在 js 文件的 options 中再配置）。此时，其值应当写成字符串形式：

```json
{
  "pureDataPattern": "^_"
}
```

**使用数据监听器监听纯数据字段**
数据监听器 可以用于监听纯数据字段（与普通数据字段一样）。这样，可以通过监听、响应纯数据字段的变化来改变界面。

下面的示例是一个将 JavaScript 时间戳转换为可读时间的自定义组件。

在开发者工具中预览效果

代码示例：

```js
Component({
  options: {
    pureDataPattern: /^timestamp$/ // 将 timestamp 属性指定为纯数据字段
  },
  properties: {
    timestamp: Number,
  },
  observers: {
    timestamp: function () {
      // timestamp 被设置时，将它展示为可读时间字符串
      var timeString = new Date(this.data.timestamp).toLocaleString()
      this.setData({
        timeString: timeString
      })
    }
  }
})
<view>{{timeString}}</view>
```

### 抽象节点

这个特性自小程序基础库版本 1.9.6 开始支持。

**在组件中使用抽象节点**
有时，自定义组件模板中的一些节点，其对应的自定义组件不是由自定义组件本身确定的，而是自定义组件的调用者确定的。这时可以把这个节点声明为“抽象节点”。

例如，我们现在来实现一个“选框组”（selectable-group）组件，它其中可以放置单选框（custom-radio）或者复选框（custom-checkbox）。这个组件的 wxml 可以这样编写：

代码示例：

在开发者工具中预览效果

```html
<!-- selectable-group.wxml -->
<view wx:for="{{labels}}">
  <label>
    <selectable disabled="{{false}}"></selectable>
    {{item}}
  </label>
</view>
```

其中，“selectable”不是任何在 json 文件的 usingComponents 字段中声明的组件，而是一个抽象节点。它需要在 componentGenerics 字段中声明：

```js
{
  "componentGenerics": {
    "selectable": true
  }
}
```

**使用包含抽象节点的组件**
在使用 selectable-group 组件时，必须指定“selectable”具体是哪个组件：

```html
<selectable-group generic:selectable="custom-radio" />
```

这样，在生成这个 selectable-group 组件的实例时，“selectable”节点会生成“custom-radio”组件实例。类似地，如果这样使用：

```html
<selectable-group generic:selectable="custom-checkbox" />
```

“selectable”节点则会生成“custom-checkbox”组件实例。

注意：上述的 custom-radio 和 custom-checkbox 需要包含在这个 wxml 对应 json 文件的 usingComponents 定义段中。

```json
{
  "usingComponents": {
    "custom-radio": "path/to/custom/radio",
    "custom-checkbox": "path/to/custom/checkbox"
  }
}
```

**抽象节点的默认组件**
抽象节点可以指定一个默认组件，当具体组件未被指定时，将创建默认组件的实例。默认组件可以在 componentGenerics 字段中指定：

```
{
  "componentGenerics": {
    "selectable": {
      "default": "path/to/default/component"
    }
  }
}
```

Tips:

节点的 generic 引用 generic:xxx="yyy" 中，值 yyy 只能是静态值，不能包含数据绑定。因而抽象节点特性并不适用于动态决定节点名的场景。

### 自定义组件扩展

为了更好定制自定义组件的功能，可以使用自定义组件扩展机制。从小程序基础库版本 2.2.3 开始支持。

**扩展后的效果**

为了更好的理解扩展后的效果，先举一个例子：

在开发者工具中预览效果

```js
// behavior.js
module.exports = Behavior({
  definitionFilter(defFields) {
    defFields.data.from = "behavior";
  },
});

// component.js
Component({
  data: {
    from: "component",
  },
  behaviors: [require("behavior.js")],
  ready() {
    console.log(this.data.from); // 此处会发现输出 behavior 而不是 component
  },
});
```

通过例子可以发现，自定义组件的扩展其实就是提供了修改自定义组件定义段的能力，上述例子就是修改了自定义组件中的 data 定义段里的内容。

**使用扩展**
Behavior() 构造器提供了新的定义段 definitionFilter ，用于支持自定义组件扩展。 definitionFilter 是一个函数，在被调用时会注入两个参数，第一个参数是使用该 behavior 的 component/behavior 的定义对象，第二个参数是该 behavior 所使用的 behavior 的 definitionFilter 函数列表。

以下举个例子来说明：

```js
// behavior3.js
module.exports = Behavior({
  definitionFilter(defFields, definitionFilterArr) {},
});

// behavior2.js
module.exports = Behavior({
  behaviors: [require("behavior3.js")],
  definitionFilter(defFields, definitionFilterArr) {
    // definitionFilterArr[0](defFields)
  },
});

// behavior1.js
module.exports = Behavior({
  behaviors: [require("behavior2.js")],
  definitionFilter(defFields, definitionFilterArr) {},
});

// component.js
Component({
  behaviors: [require("behavior1.js")],
});
```

上述代码中声明了 1 个自定义组件和 3 个 behavior，每个 behavior 都使用了 definitionFilter 定义段。那么按照声明的顺序会有如下事情发生：

1. 当进行 behavior2 的声明时就会调用 behavior3 的 definitionFilter 函数，其中 defFields 参数是 behavior2 的定义段， definitionFilterArr 参数即为空数组，因为 behavior3 没有使用其他的 behavior 。
2. 当进行 behavior1 的声明时就会调用 behavior2 的 definitionFilter 函数，其中 defFields 参数是 behavior1 的定义段， definitionFilterArr 参数是一个长度为 1 的数组，definitionFilterArr[0] 即为 behavior3 的 definitionFilter 函数，因为 behavior2 使用了 behavior3。用户在此处可以自行决定在进行 behavior1 的声明时要不要调用 behavior3 的 definitionFilter 函数，如果需要调用，在此处补充代码 definitionFilterArr[0](defFields) 即可，definitionFilterArr 参数会由基础库补充传入。
3. 同理，在进行 component 的声明时就会调用 behavior1 的 definitionFilter 函数。

简单概括，definitionFilter 函数可以理解为当 A 使用了 B 时，A 声明就会调用 B 的 definitionFilter 函数并传入 A 的定义对象让 B 去过滤。此时如果 B 还使用了 C 和 D ，那么 B 可以自行决定要不要调用 C 和 D 的 definitionFilter 函数去过滤 A 的定义对象。

代码示例：

在开发者工具中预览效果

**真实案例**
下面利用扩展简单实现自定义组件的计算属性功能:

```js
// behavior.js
module.exports = Behavior({
  lifetimes: {
    created() {
      this._originalSetData = this.setData; // 原始 setData
      this.setData = this._setData; // 封装后的 setData
    },
  },
  definitionFilter(defFields) {
    const computed = defFields.computed || {};
    const computedKeys = Object.keys(computed);
    const computedCache = {};

    // 计算 computed
    const calcComputed = (scope, insertToData) => {
      const needUpdate = {};
      const data = (defFields.data = defFields.data || {});

      for (let key of computedKeys) {
        const value = computed[key].call(scope); // 计算新值
        if (computedCache[key] !== value)
          needUpdate[key] = computedCache[key] = value;
        if (insertToData) data[key] = needUpdate[key]; // 直接插入到 data 中，初始化时才需要的操作
      }

      return needUpdate;
    };

    // 重写 setData 方法
    defFields.methods = defFields.methods || {};
    defFields.methods._setData = function (data, callback) {
      const originalSetData = this._originalSetData; // 原始 setData
      originalSetData.call(this, data, callback); // 做 data 的 setData
      const needUpdate = calcComputed(this); // 计算 computed
      originalSetData.call(this, needUpdate); // 做 computed 的 setData
    };

    // 初始化 computed
    calcComputed(defFields, true); // 计算 computed
  },
});
```

在组件中使用：

```js
const beh = require('./behavior.js')
Component({
  behaviors: [beh],
  data: {
    a: 0,
  },
  computed: {
    b() {
      return this.data.a + 100
    },
  },
  methods: {
    onTap() {
      this.setData({
        a: ++this.data.a,
      })
    }
  }
})
<view>data: {{a}}</view>
<view>computed: {{b}}</view>
<button bindtap="onTap">click</button>
```

实现原理很简单，对已有的 setData 进行二次封装，在每次 setData 的时候计算出 computed 里各字段的值，然后设到 data 中，已达到计算属性的效果。

> 此实现只是作为一个简单案例来展示，请勿直接在生产环境中使用。

**官方扩展包**

[computed](https://github.com/wechat-miniprogram/computed)

# 框架

## 小程序配置

### 全局配置

小程序根目录下的 app.json 文件用来对微信小程序进行全局配置。文件内容为一个 JSON 对象，有以下属性：

配置项

| 属性 | 类型 | 必填 | 描述 | 最低版本 |
|---|---|---|---|---|
| entryPagePath | string | 否 | 小程序默认启动首页 |  |
| pages | `string[]` | 是 | 页面路径列表 |  |
| window | Object | 否 | 全局的默认窗口表现 |  |
| tabBar | Object | 否 | 底部 tab 栏的表现 |  |
| networkTimeout | Object | 否 | 网络超时时间 |  |
| debug | boolean | 否 | 是否开启 debug 模式，默认关闭 |  |
| functionalPages | boolean | 否 | 是否启用插件功能页，默认关闭 | 2.1.0 |
| subpackages | `Object[]` | 否 | 分包结构配置 | 1.7.3 |
| workers | string | 否 | Worker 代码放置的目录 | 1.9.90 |
| requiredBackgroundModes | `string[]` | 否 | 需要在后台使用的能力，如「音乐播放」 |  |
| plugins | Object | 否 | 使用到的插件 | 1.9.6 |
| preloadRule | Object | 否 | 分包预下载规则 | 2.3.0 |
| resizable | boolean | 否 | PC 小程序是否支持用户任意改变窗口大小（包括最大化窗口）；iPad 小程序是否支持屏幕旋转。默认关闭 | 2.3.0 |
| usingComponents | Object | 否 | 全局自定义组件配置 | 开发者工具 1.02.1810190 |
| permission | Object | 否 | 小程序接口权限相关设置 | 微信客户端 7.0.0 |
| sitemapLocation | string | 是 | 指明 sitemap.json 的位置 |  |
| style | string | 否 | 指定使用升级后的weui样式 | 2.8.0 |
| useExtendedLib | Object | 否 | 指定需要引用的扩展库 | 2.2.1 |
| entranceDeclare | Object | 否 | 微信消息用小程序打开 | 微信客户端7.0.9 |
| darkmode | boolean | 否 | 小程序支持 DarkMode | 2.11.0 |
| themeLocation | string | 否 | 指明 theme.json 的位置，darkmode为true为必填 | 开发者工具 1.03.2004271 |
| lazyCodeLoading | string | 否 | 配置自定义组件代码按需注入 | 2.11.1 |
| singlePage | Object | 否 | 单页模式相关配置 | 2.12.0 |

**entryPagePath**

指定小程序的默认启动路径（首页），常见情景是从微信聊天列表页下拉启动、小程序列表启动等。如果不填，将默认为 pages 列表的第一项。不支持带页面路径参数。

```json
{
  "entryPagePath": "pages/index/index"
}
```

**pages**

用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径（含文件名） 信息。文件名不需要写文件后缀，框架会自动去寻找对应位置的 .json, .js, .wxml, .wxss 四个文件进行处理。

未指定 entryPagePath 时，数组的第一项代表小程序的初始页面（首页）。

小程序中新增/减少页面，都需要对 pages 数组进行修改。

如开发目录为：

```
├── app.js
├── app.json
├── app.wxss
├── pages
│   │── index
│   │   ├── index.wxml
│   │   ├── index.js
│   │   ├── index.json
│   │   └── index.wxss
│   └── logs
│       ├── logs.wxml
│       └── logs.js
└── utils
```

则需要在 app.json 中写

```json
{
  "pages": ["pages/index/index", "pages/logs/logs"]
}
```

**window**

用于设置小程序的状态栏、导航条、标题、窗口背景色。

| 属性 | 类型 | 默认值 | 描述 | 最低版本 |
|---|---|---|---|---|
| navigationBarBackgroundColor | HexColor | #000000 | 导航栏背景颜色，如 #000000 |  |
| navigationBarTextStyle | string | white | 导航栏标题颜色，仅支持 black / white |  |
| navigationBarTitleText | string |  | 导航栏标题文字内容 |  |
| navigationStyle | string | default | 导航栏样式，仅支持以下值：default 默认样式 custom 自定义导航栏，只保留右上角胶囊按钮。参见注 2。 | 微信客户端 6.6.0 |
| backgroundColor | HexColor | #ffffff | 窗口的背景色 |  |
| backgroundTextStyle | string | dark | 下拉 loading 的样式，仅支持 dark / light |  |
| backgroundColorTop | string | #ffffff | 顶部窗口的背景色，仅 iOS 支持 | 微信客户端 6.5.16 |
| backgroundColorBottom | string | #ffffff | 底部窗口的背景色，仅 iOS 支持 | 微信客户端 6.5.16 |
| enablePullDownRefresh | boolean | false | 是否开启全局的下拉刷新。详见 Page.onPullDownRefresh |  |
| onReachBottomDistance | number | 50 | 页面上拉触底事件触发时距页面底部距离，单位为 px。详见 Page.onReachBottom |  |
| pageOrientation | string | portrait | 屏幕旋转设置，支持 auto / portrait / landscape 详见 响应显示区域变化 | 2.4.0 (auto) / 2.5.0 (landscape) |

注 1：HexColor（十六进制颜色值），如"#ff00ff"
注 2：关于navigationStyle
- 客户端 7.0.0 以下版本，navigationStyle 只在 app.json 中生效。
- 客户端 6.7.2 版本开始，`navigationStyle: custom` 对 web-view 组件无效
- 开启 custom 后，低版本客户端需要做好兼容。开发者工具基础库版本切到 1.7.0（不代表最低版本，只供调试用）可方便切到旧视觉

如：

```json
{
  "window": {
    "navigationBarBackgroundColor": "#ffffff",
    "navigationBarTextStyle": "black",
    "navigationBarTitleText": "微信接口功能演示",
    "backgroundColor": "#eeeeee",
    "backgroundTextStyle": "light"
  }
}
```

**tabBar**

如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。

| 属性 | 类型 | 必填 | 默认值 | 描述 | 最低版本 |
|---|---|---|---|---|---|
| color | HexColor | 是 |  | tab 上的文字默认颜色，仅支持十六进制颜色 |  |
| selectedColor | HexColor | 是 |  | tab 上的文字选中时的颜色，仅支持十六进制颜色 |  |
| backgroundColor | HexColor | 是 |  | tab 的背景色，仅支持十六进制颜色 |  |
| borderStyle | string | 否 | black | tabbar 上边框的颜色， 仅支持 black / white |  |
| list | Array | 是 |  | tab 的列表，详见 list 属性说明，最少 2 个、最多 5 个 tab |  |
| position | string | 否 | bottom | tabBar 的位置，仅支持 bottom / top |  |
| custom | boolean | 否 | false | 自定义 tabBar，见详情 | 2.5.0 |

其中 list 接受一个数组，只能配置最少 2 个、最多 5 个 tab。tab 按数组的顺序排序，每个项都是一个对象，其属性值如下：

| 属性 | 类型 | 必填 | 说明 |
|---|---|---|---|
| pagePath | string | 是 | 页面路径，必须在 pages 中先定义 |
| text | string | 是 | tab 上按钮文字 |
| iconPath | string | 否 | 图片路径，icon 大小限制为 40kb，建议尺寸为 81px * 81px，不支持网络图片。当 position 为 top 时，不显示 icon。 |
| selectedIconPath | string | 否 | 选中时的图片路径，icon 大小限制为 40kb，建议尺寸为 81px * 81px，不支持网络图片。当 position 为 top 时，不显示 icon。 |

**networkTimeout**

各类网络请求的超时时间，单位均为毫秒。

| 属性 | 类型 | 必填 | 默认值 | 说明 |
|---|---|---|---|---|
| request | number | 否 | 60000 | wx.request 的超时时间，单位：毫秒。 |
| connectSocket | number | 否 | 60000 | wx.connectSocket 的超时时间，单位：毫秒。 |
| uploadFile | number | 否 | 60000 | wx.uploadFile 的超时时间，单位：毫秒。 |
| downloadFile | number | 否 | 60000 | wx.downloadFile 的超时时间，单位：毫秒。 |

**debug**

可以在开发者工具中开启 debug 模式，在开发者工具的控制台面板，调试信息以 info 的形式给出，其信息有 Page 的注册，页面路由，数据更新，事件触发等。可以帮助开发者快速定位一些常见的问题。

**functionalPages**

插件所有者小程序需要设置这一项来启用插件功能页。

**subpackages**

启用分包加载时，声明项目分包结构。

写成 subPackages 也支持。

**workers**

使用 Worker 处理多线程任务时，设置 Worker 代码放置的目录

**requiredBackgroundModes**

申明需要后台运行的能力，类型为数组。目前支持以下项目：

- audio: 后台音乐播放
- location: 后台定位

如：

```json
{
  "pages": ["pages/index/index"],
  "requiredBackgroundModes": ["audio", "location"]
}
```

注：在此处申明了后台运行的接口，开发版和体验版上可以直接生效，正式版还需通过审核。

**plugins**

声明小程序需要使用的插件。

**preloadRule**

声明分包预下载的规则。

**resizable**

在 iPad 上运行的小程序可以设置支持屏幕旋转。

在 PC 上运行的小程序，用户可以按照任意比例拖动窗口大小，也可以在小程序菜单中最大化窗口

**usingComponents**

在此处声明的自定义组件视为全局自定义组件，在小程序内的页面或自定义组件中可以直接使用而无需再声明。

**permission**

小程序接口权限相关设置。字段类型为 Object，结构为：

| 属性 | 类型 | 必填 | 默认值 | 描述 |
|---|---|---|---|---|
| scope.userLocation | PermissionObject | 否 |  | 位置相关权限声明 |

PermissionObject 结构

| 属性 | 类型 | 必填 | 默认值 | 说明 |
|---|---|---|---|---|
| desc | string | 是 |  | 小程序获取权限时展示的接口用途说明。最长 30 个字符 |

如：

```JSON
{
  "pages": ["pages/index/index"],
  "permission": {
    "scope.userLocation": {
      "desc": "你的位置信息将用于小程序位置接口的效果展示" // 高速公路行驶持续后台定位
    }
  }
}
```

**sitemapLocation**

指明 sitemap.json 的位置；默认为 'sitemap.json' 即在 app.json 同级目录下名字的 sitemap.json 文件

配置示例

```json
{
  "pages": ["pages/index/index", "pages/logs/index"],
  "window": {
    "navigationBarTitleText": "Demo"
  },
  "tabBar": {
    "list": [
      {
        "pagePath": "pages/index/index",
        "text": "首页"
      },
      {
        "pagePath": "pages/logs/logs",
        "text": "日志"
      }
    ]
  },
  "networkTimeout": {
    "request": 10000,
    "downloadFile": 10000
  },
  "debug": true,
}
```

**style**

微信客户端 7.0 开始，UI 界面进行了大改版。小程序也进行了基础组件的样式升级。app.json 中配置 "style": "v2"可表明启用新版的组件样式。

本次改动涉及的组件有 button icon radio checkbox switch slider。可前往小程序示例进行体验。

**useExtendedLib**

最新的 nightly 版开发者工具开始支持，同时基础库从支持 npm 的版本（2.2.1）起支持

指定需要引用的扩展库。目前支持以下项目：

- kbone: 多端开发框架
- weui: WeUI 组件库

指定后，相当于引入了对应扩展库相关的最新版本的 npm 包，同时也不占用小程序的包体积。rc工具版本支持分包引用。用法如下：

```json
{
  "useExtendedLib": {
    "kbone": true,
    "weui": true
  }
}
```

**entranceDeclare**

聊天位置消息用打车类小程序打开，详情参考。

```json
"entranceDeclare": {
  "locationMessage": {
    "path": "pages/index/index",
    "query": "foo=bar"
  }
}
```

**darkmode**

微信iOS客户端 7.0.12 版本、Android客户端 7.0.13 版本正式支持 DarkMode，可通过配置"darkmode": true表示当前小程序可适配 DarkMode，所有基础组件均会根据系统主题展示不同的默认样式，navigation bar 和 tab bar 也会根据开发者的配置自动切换。

配置后，请根据 DarkMode 适配指南自行完成基础样式以外的适配工作。

```json
{
  "darkmode": true
}
```

**themeLocation**

自定义 theme.json 的路径，当配置`"darkmode":true`时，当前配置文件为必填项。

```json
{
  "themeLocation": "/path/to/theme.json"
}
```

**lazyCodeLoading**

通常情况下，在小程序启动期间，所有页面及自定义组件的代码都会进行注入，当前页面没有使用到的自定义组件和页面在注入后其实并没有被使用。

自基础库版本 2.11.1 起，小程序支持有选择地注入必要的代码，以降低小程序的启动时间和运行时内存。

```json
{
  "lazyCodeLoading": "requiredComponents"
}
```

当配置了这一项时，小程序仅注入当前页面需要的自定义组件和页面代码，在页面中必然不会用到的自定义组件不会被加载和初始化。

注意：添加这项配置后，未使用到的代码文件将不被执行。

**singlePage**

基础库 2.11.3 及以上版本支持，目前分享到朋友圈 (Beta) 后打开会进入单页模式

单页模式相关配置

| 属性 | 类型 | 必填 | 默认值 | 描述 |
|---|---|---|---|---|
| navigationBarFit | String | 否 | 默认自动调整，若原页面是自定义导航栏，则为 float，否则为 squeezed | 导航栏与页面的相交状态，值为 float 时表示导航栏浮在页面上，与页面相交；值为 squeezed 时表示页面被导航栏挤压，与页面不相交 |

### 页面配置

每一个小程序页面也可以使用 .json 文件来对本页面的窗口表现进行配置。页面中配置项在当前页面会覆盖 app.json 的 window 中相同的配置项。文件内容为一个 JSON 对象，有以下属性：

配置项

| 属性 | 类型 | 默认值 | 描述 | 最低版本 |
|---|---|---|---|---|
| navigationBarBackgroundColor | HexColor | #000000 | 导航栏背景颜色，如 #000000 |  |
| navigationBarTextStyle | string | white | 导航栏标题颜色，仅支持 black / white |  |
| navigationBarTitleText | string |  | 导航栏标题文字内容 |  |
| navigationStyle | string | default | 导航栏样式，仅支持以下值：default 默认样式 custom 自定义导航栏，只保留右上角胶囊按钮 | 微信客户端 7.0.0 |
| backgroundColor | HexColor | #ffffff | 窗口的背景色 |  |
| backgroundTextStyle | string | dark | 下拉 loading 的样式，仅支持 dark / light |  |
| backgroundColorTop | string | #ffffff | 顶部窗口的背景色，仅 iOS 支持 | 微信客户端 6.5.16 |
| backgroundColorBottom | string | #ffffff | 底部窗口的背景色，仅 iOS 支持 | 微信客户端 6.5.16 |
| enablePullDownRefresh | boolean | false | 是否开启当前页面下拉刷新。详见 Page.onPullDownRefresh |  |
| onReachBottomDistance | number | 50 | 页面上拉触底事件触发时距页面底部距离，单位为px。详见 Page.onReachBottom |  |
| pageOrientation | string | portrait | 屏幕旋转设置，支持 auto / portrait / landscape 详见 响应显示区域变化 | 2.4.0 (auto) / 2.5.0 (landscape) |
| disableScroll | boolean | false | 设置为 true 则页面整体不能上下滚动。只在页面配置中有效，无法在 app.json 中设置 |  |
| usingComponents | Object | 否 | 页面自定义组件配置 | 1.6.3 |
| style | string | default | 启用新版的组件样式 | 2.10.2 |
| singlePage | Object | 否 | 单页模式相关配置 | 2.12.0 |

> 页面配置中只能设置 app.json 中 window 对应的配置项，以决定本页面的窗口表现，所以无需写 window 这个属性。

**singlePage**

基础库 2.11.3 及以上版本支持，目前分享到朋友圈 (Beta) 后打开会进入单页模式

单页模式相关配置

| 属性 | 类型 | 必填 | 默认值 | 描述 |
|---|---|---|---|---|
| navigationBarFit | String | 否 | 默认自动调整，若原页面是自定义导航栏，则为 float，否则为 squeezed | 导航栏与页面的相交状态，值为 float 时表示导航栏浮在页面上，与页面相交；值为 squeezed 时表示页面被导航栏挤压，与页面不相交 |

配置示例

```json
{
  "navigationBarBackgroundColor": "#ffffff",
  "navigationBarTextStyle": "black",
  "navigationBarTitleText": "微信接口功能演示",
  "backgroundColor": "#eeeeee",
  "backgroundTextStyle": "light"
}
```

### sitemap 配置

微信现已开放小程序内搜索，开发者可以通过 sitemap.json 配置，或者管理后台页面收录开关来配置其小程序页面是否允许微信索引。当开发者允许微信索引时，微信会通过爬虫的形式，为小程序的页面内容建立索引。当用户的搜索词条触发该索引时，小程序的页面将可能展示在搜索结果中。 爬虫访问小程序内页面时，会携带特定的 `user-agent：mpcrawler` 及场景值：1129。需要注意的是，若小程序爬虫发现的页面数据和真实用户的呈现不一致，那么该页面将不会进入索引中。

**sitemap 配置**

小程序根目录下的 sitemap.json 文件用于配置小程序及其页面是否允许被微信索引，文件内容为一个 JSON 对象，如果没有 sitemap.json ，则默认为所有页面都允许被索引；sitemap.json 有以下属性：

配置项

| 属性 | 类型 | 必填 | 描述 |
|---|---|---|---|
| rules | Object[] | 是 | 索引规则列表 |

rules

rules 配置项指定了索引规则，每项规则为一个JSON对象，属性如下所示：

| 属性 | 类型 | 必填 | 默认值 | 取值 | 取值说明 |
|---|---|---|---|---|---|
| action | string | 否 | "allow" | "allow"、"disallow" | 命中该规则的页面是否能被索引 |
| page | string | 是 |  | "*"、页面的路径 | * 表示所有页面，不能作为通配符使用 |
| params | string[] | 否 | [] |  | 当 page 字段指定的页面在被本规则匹配时可能使用的页面参数名称的列表（不含参数值） |
| matching | string | 否 | "inclusive" | 参考 matching 取值说明 | 当 page 字段指定的页面在被本规则匹配时，此参数说明 params 匹配方式 |
| priority | Number | 否 |  |  | 优先级，值越大则规则越早被匹配，否则默认从上到下匹配 |

matching 取值说明

| 值 | 说明 |
|---|---|
| exact | 当小程序页面的参数列表等于 params 时，规则命中 |
| inclusive | 当小程序页面的参数列表包含 params 时，规则命中 |
| exclusive | 当小程序页面的参数列表与 params 交集为空时，规则命中 |
| partial | 当小程序页面的参数列表与 params 交集不为空时，规则命中 |

> 注：没有 sitemap.json 则默认所有页面都能被索引

> 注：{"action": "allow", "page": "*"} 是优先级最低的默认规则，未显式指明 "disallow" 的都默认被索引

## 框架接口

### 小程序 App

#### APP

`App(Object object)`

注册小程序。接受一个 Object 参数，其指定小程序的生命周期回调等。

`App()` 必须在 app.js 中调用，必须调用且只能调用一次。不然会出现无法预期的后果。

| 属性 | 类型 | 默认值 | 必填 | 说明 | 最低版本 |
|---|---|---|---|---|---|
| onLaunch | function |  | 否 | 生命周期回调——监听小程序初始化。 |  |
| onShow | function |  | 否 | 生命周期回调——监听小程序启动或切前台。 |  |
| onHide | function |  | 否 | 生命周期回调——监听小程序切后台。 |  |
| onError | function |  | 否 | 错误监听函数。 |  |
| onPageNotFound | function |  | 否 | 页面不存在监听函数。 | 1.9.90 |
| onUnhandledRejection | function |  | 否 | 未处理的 Promise 拒绝事件监听函数。 | 2.10.0 |
| onThemeChange | function |  | 否 | 监听系统主题变化 | 2.11.0 |
| 其他 | any |  | 否 | 开发者可以添加任意的函数或数据变量到 Object 参数中，用 this 可以访问 |  |

关于小程序前后台的定义和小程序的运行机制，请参考运行机制章节。

`onLaunch(Object object)`

小程序初始化完成时触发，全局只触发一次。参数也可以使用 wx.getLaunchOptionsSync 获取。参数：与 wx.getLaunchOptionsSync 一致。

`onShow(Object object)`

小程序启动，或从后台进入前台显示时触发。也可以使用 wx.onAppShow 绑定监听。参数：与 wx.onAppShow 一致。

`onHide()`

小程序从前台进入后台时触发。也可以使用 wx.onAppHide 绑定监听。

`onError(String error)`

小程序发生脚本错误或 API 调用报错时触发。也可以使用 wx.onError 绑定监听。参数：与 wx.onError 一致。

`onPageNotFound(Object object)`

小程序要打开的页面不存在时触发。也可以使用 wx.onPageNotFound 绑定监听。注意事项请参考 wx.onPageNotFound。参数：与 wx.onPageNotFound 一致。

`onUnhandledRejection(Object object)`

小程序有未处理的 Promise 拒绝时触发。也可以使用 wx.onUnhandledRejection 绑定监听。注意事项请参考 wx.onUnhandledRejection。参数：与 wx.onUnhandledRejection 一致。

`onThemeChange(Object object)`

系统切换主题时触发。也可以使用 wx.onThemeChange 绑定监听。参数：与 wx.onThemeChange 一致

#### getApp

`AppObject getApp(Object object)`

获取到小程序全局唯一的 App 实例。

| 属性 | 类型 | 默认值 | 必填 | 说明 | 最低版本 |
|---|---|---|---|---|---|
| allowDefault | boolean | false | 否 | 在 App 未定义时返回默认实现。当App被调用时，默认实现中定义的属性会被覆盖合并到App中。一般用于独立分包 | 2.2.4 |

示例代码

```js
// other.js
var appInstance = getApp()
console.log(appInstance.globalData) // I am global data
```

注意

- 不要在定义于 `App()` 内的函数中，或调用 App 前调用 `getApp()` ，使用 this 就可以拿到 app 实例。
- 通过 `getApp()` 获取实例之后，不要私自调用生命周期函数。

### 页面

1. `Page(Object object)`

注册小程序中的一个页面。接受一个 Object 类型参数，其指定页面的初始数据、生命周期回调、事件处理函数等。

| 属性 | 类型 | 默认值 | 必填 | 说明 |
|---|---|---|---|---|
| data | Object |  |  | 页面的初始数据 |
| onLoad | function |  |  | 生命周期回调—监听页面加载 |
| onShow | function |  |  | 生命周期回调—监听页面显示 |
| onReady | function |  |  | 生命周期回调—监听页面初次渲染完成 |
| onHide | function |  |  | 生命周期回调—监听页面隐藏 |
| onUnload | function |  |  | 生命周期回调—监听页面卸载 |
| onPullDownRefresh | function |  |  | 监听用户下拉动作 |
| onReachBottom | function |  |  | 页面上拉触底事件的处理函数 |
| onShareAppMessage | function |  |  | 用户点击右上角转发 |
| onShareTimeline | function |  |  | 用户点击右上角转发到朋友圈 |
| onAddToFavorites | function |  |  | 用户点击右上角收藏 |
| onPageScroll | function |  |  | 页面滚动触发事件的处理函数 |
| onResize | function |  |  | 页面尺寸改变时触发，详见 响应显示区域变化 |
| onTabItemTap | function |  |  | 当前是 tab 页时，点击 tab 时触发 |
| 其他 | any |  |  | 开发者可以添加任意的函数或数据到 Object 参数中，在页面的函数中用 this 可以访问 |

#### data

data 是页面第一次渲染使用的初始数据。页面加载时，data 将会以JSON字符串的形式由逻辑层传至渲染层，因此data中的数据必须是可以转成JSON的类型：字符串，数字，布尔值，对象，数组。渲染层可以通过 WXML 对数据进行绑定。

#### 生命周期回调函数

`onLoad(Object query)`

页面加载时触发。一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数。

参数：

| 名称 | 类型 | 说明 |
|---|---|---|
| query | Object | 打开当前页面路径中的参数 |

`onShow()`

页面显示/切入前台时触发。

`onReady()`

页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。

> 注意：对界面内容进行设置的 API 如wx.setNavigationBarTitle，请在onReady之后进行。详见生命周期

`onHide()`

页面隐藏/切入后台时触发。 如 wx.navigateTo 或底部 tab 切换到其他页面，小程序切入后台等。

`onUnload()`

页面卸载时触发。如wx.redirectTo或wx.navigateBack到其他页面时。

#### 页面事件处理函数

`onPullDownRefresh()`

监听用户下拉刷新事件。需要在app.json的window选项中或页面配置中开启enablePullDownRefresh。

可以通过wx.startPullDownRefresh触发下拉刷新，调用后触发下拉刷新动画，效果与用户手动下拉刷新一致。

当处理完数据刷新后，wx.stopPullDownRefresh可以停止当前页面的下拉刷新。

`onReachBottom()`

监听用户上拉触底事件。

可以在app.json的window选项中或页面配置中设置触发距离onReachBottomDistance。在触发距离内滑动期间，本事件只会被触发一次。

`onPageScroll(Object object)`

监听用户滑动页面事件。

参数 Object object:

| 属性 | 类型 | 说明 |
|---|---|---|
| scrollTop | Number | 页面在垂直方向已滚动的距离（单位px） |

> 注意：请只在需要的时候才在 page 中定义此方法，不要定义空方法。以减少不必要的事件派发对渲染层-逻辑层通信的影响。 注意：请避免在 onPageScroll 中过于频繁的执行 setData 等引起逻辑层-渲染层通信的操作。尤其是每次传输大量数据，会影响通信耗时。

`onAddToFavorites(Object object)`

监听用户点击右上角菜单“收藏”按钮的行为，并自定义收藏内容。

参数 Object object:

| 参数 | 类型 | 说明 |
|---|---|---|
| webviewUrl | String | 页面中包含web-view组件时，返回当前web-view的url |

此事件处理函数需要 return 一个 Object，用于自定义收藏内容：

| 字段 | 说明 | 默认值 |
|---|---|---|
| title | 自定义标题 | 页面标题或账号名称 |
| imageUrl | 自定义图片，显示图片长宽比为 1：1 | 页面截图 |
| query | 自定义query字段 | 当前页面的query |

`onShareAppMessage(Object object)`

监听用户点击页面内转发按钮（button 组件 open-type="share"）或右上角菜单“转发”按钮的行为，并自定义转发内容。

> 注意：只有定义了此事件处理函数，右上角菜单才会显示“转发”按钮

参数 Object object:

| 参数 | 类型 | 说明 | 最低版本 |
|---|---|---|---|
| from | String | 转发事件来源。button：页面内转发按钮；menu：右上角转发菜单 | 1.2.4 |
| target | Object | 如果 from 值是 button，则 target 是触发这次转发事件的 button，否则为 undefined | 1.2.4 |
| webViewUrl | String | 页面中包含web-view组件时，返回当前web-view的url | 1.6.4 |

此事件处理函数需要 return 一个 Object，用于自定义转发内容，返回内容如下：

| 字段 | 说明 | 默认值 | 最低版本 |
|---|---|---|---|
| title | 转发标题 | 当前小程序名称 |  |
| path | 转发路径 | 当前页面 path ，必须是以 / 开头的完整路径 |  |
| imageUrl | 自定义图片路径，可以是本地文件路径、代码包文件路径或者网络图片路径。支持PNG及JPG。显示图片长宽比是 5:4。 | 使用默认截图 | 1.5.0 |

`onShareTimeline()`

监听右上角菜单“分享到朋友圈”按钮的行为，并自定义分享内容。

注意：只有定义了此事件处理函数，右上角菜单才会显示“分享到朋友圈”按钮

自定义转发内容

事件处理函数返回一个 Object，用于自定义分享内容，不支持自定义页面路径，返回内容如下：

| 字段 | 说明 | 默认值 | 最低版本 |
|---|---|---|---|
| title | 自定义标题，即朋友圈列表页上显示的标题 | 当前小程序名称 |  |
| query | 自定义页面路径中携带的参数，如 path?a=1&b=2 的 “?” 后面部分 | 当前页面路径携带的参数 |  |
| imageUrl | 自定义图片路径，可以是本地文件或者网络图片。支持 PNG 及 JPG，显示图片长宽比是 1:1。 | 默认使用小程序 Logo |  |

`onResize(Object object)`

小程序屏幕旋转时触发。详见 响应显示区域变化

`onTabItemTap(Object object)`

点击 tab 时触发

Object 参数说明：

| 参数 | 类型 | 说明 | 最低版本 |
|---|---|---|---|
| index | String | 被点击tabItem的序号，从0开始 | 1.9.0 |
| pagePath | String | 被点击tabItem的页面路径 | 1.9.0 |
| text | String | 被点击tabItem的按钮文字 | 1.9.0 |

#### 组件事件处理函数

Page 中还可以定义组件事件处理函数。在渲染层的组件中加入事件绑定，当事件被触发时，就会执行 Page 中定义的事件处理函数。

示例代码：

```js
<view bindtap="viewTap"> click me </view>
Page({
  viewTap: function() {
    console.log('view tap')
  }
})
```

#### Page.route

到当前页面的路径，类型为String。

#### Page.prototype.setData

`Page.prototype.setData(Object data, Function callback)`

setData 函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的 this.data 的值（同步）。

参数说明

| 字段 | 类型 | 必填 | 描述 | 最低版本 |
|---|---|---|---|---|
| data | Object | 是 | 这次要改变的数据 |  |
| callback | Function | 否 | setData引起的界面更新渲染完毕后的回调函数 | 1.5.0 |

Object 以 key: value 的形式表示，将 this.data 中的 key 对应的值改变成 value。

其中 key 可以以数据路径的形式给出，支持改变数组中的某一项或对象的某个属性，如 array[2].message，a.b.c.d，并且不需要在 this.data 中预先定义。

注意：

1. 直接修改 this.data 而不调用 this.setData 是无法改变页面的状态的，还会造成数据不一致。
2. 仅支持设置可 JSON 化的数据。
3. 单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。
4. 请不要把 data 中任何一项的 value 设为 undefined ，否则这一项将不被设置并可能遗留一些潜在问题。

#### 页面间通信

如果一个页面由另一个页面通过 wx.navigateTo 打开，这两个页面间将建立一条数据通道：

- 被打开的页面可以通过 this.getOpenerEventChannel() 方法来获得一个 EventChannel 对象；
- wx.navigateTo 的 success 回调中也包含一个 EventChannel 对象。

这两个 EventChannel 对象间可以使用 emit 和 on 方法相互发送、监听事件。

2. getCurrentPages

`PageObject[] getCurrentPages()`

获取当前页面栈。数组中第一个元素为首页，最后一个元素为当前页面。

注意：

- 不要尝试修改页面栈，会导致路由以及页面状态错误。
- 不要在 App.onLaunch 的时候调用 getCurrentPages()，此时 page 还没有生成。

### 自定义组件

#### Component

`Component(Object object)`

创建自定义组件，接受一个 Object 类型的参数。

参数

Object object

| 定义段 | 类型 | 是否必填 | 描述 | 最低版本 |
|---|---|---|---|---|
| properties | Object Map | 否 | 组件的对外属性，是属性名到属性设置的映射表 |  |
| data | Object | 否 | 组件的内部数据，和 properties 一同用于组件的模板渲染 |  |
| observers | Object | 否 | 组件数据字段监听器，用于监听 properties 和 data 的变化，参见 数据监听器 | 2.6.1 |
| methods | Object | 否 | 组件的方法，包括事件响应函数和任意的自定义方法，关于事件响应函数的使用，参见 组件间通信与事件 |  |
| behaviors | String Array | 否 | 类似于mixins和traits的组件间代码复用机制，参见 behaviors |  |
| created | Function | 否 | 组件生命周期函数-在组件实例刚刚被创建时执行，注意此时不能调用 setData  |  |
| attached | Function | 否 | 组件生命周期函数-在组件实例进入页面节点树时执行 |  |
| ready | Function | 否 | 组件生命周期函数-在组件布局完成后执行 |  |
| moved | Function | 否 | 组件生命周期函数-在组件实例被移动到节点树另一个位置时执行 |  |
| detached | Function | 否 | 组件生命周期函数-在组件实例被从页面节点树移除时执行 |  |
| relations | Object | 否 | 组件间关系定义，参见 组件间关系 |  |
| externalClasses | String Array | 否 | 组件接受的外部样式类，参见 外部样式类 |  |
| options | Object Map | 否 | 一些选项（文档中介绍相关特性时会涉及具体的选项设置，这里暂不列举） |  |
| lifetimes | Object | 否 | 组件生命周期声明对象，参见 组件生命周期 | 2.2.3 |
| pageLifetimes | Object | 否 | 组件所在页面的生命周期声明对象，参见 组件生命周期 | 2.2.3 |
| definitionFilter | Function | 否 | 定义段过滤器，用于自定义组件扩展，参见 自定义组件扩展 | 2.2.3 |

生成的组件实例可以在组件的方法、生命周期函数和属性 observer 中通过 this 访问。组件包含一些通用属性和方法。

| 属性名 | 类型 | 描述 |
|---|---|---|
| is | String | 组件的文件路径 |
| id | String | 节点id |
| dataset | String | 节点dataset |
| data | Object | 组件数据，包括内部数据和属性值 |
| properties | Object | 组件数据，包括内部数据和属性值（与 data 一致） |

| 方法名 | 参数 | 描述 | 最低版本 |
|---|---|---|---|
| setData | Object newData | 设置data并执行视图层渲染 |  |
| hasBehavior | Object behavior | 检查组件是否具有 behavior （检查时会递归检查被直接或间接引入的所有behavior） |  |
| triggerEvent | String name, Object detail, Object options | 触发事件，参见 组件间通信与事件 |  |
| createSelectorQuery |  | 创建一个 SelectorQuery 对象，选择器选取范围为这个组件实例内 |  |
| createIntersectionObserver |  | 创建一个 IntersectionObserver 对象，选择器选取范围为这个组件实例内 |  |
| createMediaQueryObserver |  | 创建一个 MediaQueryObserver 对象 | 2.11.1 |
| selectComponent | String selector | 使用选择器选择组件实例节点，返回匹配到的第一个组件实例对象（会被 wx://component-export 影响） |  |
| selectAllComponents | String selector | 使用选择器选择组件实例节点，返回匹配到的全部组件实例对象组成的数组（会被 wx://component-export 影响） |  |
| selectOwnerComponent |  | 选取当前组件节点所在的组件实例（即组件的引用者），返回它的组件实例对象（会被 wx://component-export 影响） | 2.8.2 |
| getRelationNodes | String relationKey | 获取这个关系所对应的所有关联节点，参见 组件间关系 |  |
| groupSetData | Function callback | 立刻执行 callback ，其中的多个 setData 之间不会触发界面绘制（只有某些特殊场景中需要，如用于在不同组件同时 setData 时进行界面绘制同步） | 2.4.0 |
| getTabBar |  | 返回当前页面的 custom-tab-bar 的组件实例，详见自定义 tabBar | 2.6.2 |
| getPageId |  | 返回页面标识符（一个字符串），可以用来判断几个自定义组件实例是不是在同一个页面内 | 2.7.1 |
| animate | String selector, Array keyframes, Number duration, Function callback | 执行关键帧动画，详见动画 | 2.9.0 |
| clearAnimation | String selector, Object options, Function callback | 清除关键帧动画，详见动画 | 2.9.0 |
| setUpdatePerformanceListener | Object options, Function listener | 清除关键帧动画，详见动画 | 2.12.0 |

代码示例：

```js
Component({

  behaviors: [],

  // 属性定义（详情参见下文）
  properties: {
    myProperty: { // 属性名
      type: String,
      value: ''
    },
    myProperty2: String // 简化的定义方式
  },

  data: {}, // 私有数据，可用于模板渲染

  lifetimes: {
    // 生命周期函数，可以为函数，或一个在methods段中定义的方法名
    attached: function () { },
    moved: function () { },
    detached: function () { },
  },

  // 生命周期函数，可以为函数，或一个在methods段中定义的方法名
  attached: function () { }, // 此处attached的声明会被lifetimes字段中的声明覆盖
  ready: function() { },

  pageLifetimes: {
    // 组件所在页面的生命周期函数
    show: function () { },
    hide: function () { },
    resize: function () { },
  },

  methods: {
    onMyButtonTap: function(){
      this.setData({
        // 更新属性和数据的方法与更新页面数据的方法类似
      })
    },
    // 内部方法建议以下划线开头
    _myPrivateMethod: function(){
      // 这里将 data.A[0].B 设为 'myPrivateData'
      this.setData({
        'A[0].B': 'myPrivateData'
      })
    },
    _propertyChange: function(newVal, oldVal) {

    }
  }

})
```

注意：在 properties 定义段中，属性名采用驼峰写法（propertyName）；在 wxml 中，指定属性值时则对应使用连字符写法（component-tag-name property-name="attr value"），应用于数据绑定时采用驼峰写法（attr=""）。

properties 定义

| 定义段 | 类型 | 是否必填 | 描述 | 最低版本 |
|---|---|---|---|---|
| type |  | 是 | 属性的类型 |  |
| optionalTypes | Array | 否 | 属性的类型（可以指定多个） | 2.6.5 |
| value |  | 否 | 属性的初始值 |  |
| observer | Function | 否 | 属性值变化时的回调函数 |  |

属性值的改变情况可以使用 observer 来监听。目前，在新版本基础库中不推荐使用这个字段，而是使用 Component 构造器的 observers 字段代替，它更加强大且性能更好。

属性的类型可以为 String Number Boolean Object Array 其一，也可以为 null 表示不限制类型。

多数情况下，属性最好指定一个确切的类型。这样，在 WXML 中以字面量指定属性值时，值可以获得一个确切的类型，如：

```js
<custom-comp min="1" max="5" />
```

此时，由于自定义组件的对应属性被规定为 Number 类型， min 和 max 会被赋值为 1 和 5 ，而非 "1" 和 "5" ，即：

```js
this.data.min === 1 // true
this.data.max === 5 // true
```

**Bug & Tips:**

- 使用 this.data 可以获取内部数据和属性值；但直接修改它不会将变更应用到界面上，应使用 setData 修改。
- 生命周期函数无法在组件方法中通过 this 访问到。
- 属性名应避免以 data 开头，即不要命名成 dataXyz 这样的形式，因为在 WXML 中， data-xyz="" 会被作为节点 dataset 来处理，而不是组件属性。
- 在一个组件的定义和使用时，组件的属性名和 data 字段相互间都不能冲突（尽管它们位于不同的定义段中）。
- 从基础库 2.0.9 开始，对象类型的属性和 data 字段中可以包含函数类型的子字段，即可以通过对象类型的属性字段来传递函数。低于这一版本的基础库不支持这一特性。
- bug : 位于 slot 中的自定义组件没有触发 pageLifetimes 中声明的页面生命周期，此问题在 2.5.2 中修复。
- bug : 对于 type 为 Object 或 Array 的属性，如果通过该组件自身的 this.setData 来改变属性值的一个子字段，则依旧会触发属性 observer ，且 observer 接收到的 newVal 是变化的那个子字段的值， oldVal 为空， changedPath 包含子字段的字段名相关信息；目前推荐使用 observers 定义段代替。

#### Behavior

`Behavior(Object object)`

注册一个 behavior，接受一个 Object 类型的参数。

| 定义段 | 类型 | 是否必填 | 描述 | 最低版本 |
|---|---|---|---|---|
| properties | Object Map | 否 | 同组件的属性 |  |
| data | Object | 否 | 同组件的数据 |  |
| methods | Object | 否 | 同自定义组件的方法 |  |
| behaviors | String Array | 否 | 引入其它的 behavior |  |
| created | Function | 否 | 生命周期函数 |  |
| attached | Function | 否 | 生命周期函数 |  |
| ready | Function | 否 | 生命周期函数 |  |
| moved | Function | 否 | 生命周期函数 |  |
| detached | Function | 否 | 生命周期函数 |  |

代码示例：

```js
// my-behavior.js
module.exports = Behavior({
  behaviors: [],
  properties: {
    myBehaviorProperty: {
      type: String
    }
  },
  data: {
    myBehaviorData: {}
  },
  attached: function(){},
  methods: {
    myBehaviorMethod: function(){}
  }
})
```

### 模块化

#### require

any `require(string path)`

引入模块。返回模块通过 module.exports 或 exports 暴露的接口。

参数

| 名称 | 类型 | 说明 |
|---|---|---|
| path | string | 需要引入模块文件相对于当前文件的相对路径，或npm模块名，或npm模块路径。不支持绝对路径 |

示例代码

```js
// common.js
function sayHello(name) {
  console.log(`Hello ${name} !`)
}
function sayGoodbye(name) {
  console.log(`Goodbye ${name} !`)
}

module.exports.sayHello = sayHello
exports.sayGoodbye = sayGoodbye
```

```js
var common = require('common.js')
Page({
  helloMINA: function() {
    common.sayHello('MINA')
  },
  goodbyeMINA: function() {
    common.sayGoodbye('MINA')
  }
})
```

#### module

Object module

当前模块对象

属性

| 属性 | 类型 | 说明 |
|---|---|---|
| exports | Object | 模块向外暴露的对象，使用require引用该模块时可以获取 |

#### exports

Object exports

module.exports 的引用

### 基础功能

#### wx

Object wx

小程序 API 全局对象，用于承载小程序能力相关 API。具体请参考小程序 API 参考文档。

#### wx.env

Object wx.env
小程序环境变量对象

String wx.env.USER_DATA_PATH
文件系统中的用户目录路径

#### console

console
向调试面板中打印日志。console 是一个全局对象，可以直接访问。在微信客户端中，向 vConsole 中输出日志。

方法
`console.debug()`
向调试面板中打印 debug 日志

`console.log()`
向调试面板中打印 log 日志

`console.info()`
向调试面板中打印 info 日志

`console.warn()`
向调试面板中打印 warn 日志

`console.error()`
向调试面板中打印 error 日志

`console.group(string label)`
在调试面板中创建一个新的分组。随后输出的内容都会被添加一个缩进，表示该内容属于当前分组。调用 console.groupEnd 之后分组结束。

`console.groupEnd()`
结束由 console.group 创建的分组

注意
由于 vConsole 功能有限，以及不同客户端对 console 方法的支持情况有差异，建议开发者在小程序中只使用本文档中提供的方法。
部分内容展示的限制请参见调试

#### 定时器

1. setTimeout

number `setTimeout(function callback, number delay, any rest)`

设定一个定时器。在定时到期以后执行注册的回调函数

2. clearTimeout

`clearTimeout(number timeoutID)`

取消由 setTimeout 设置的定时器。

3. setInterval

number `setInterval(function callback, number delay, any rest)`

设定一个定时器。按照指定的周期（以毫秒计）来执行注册的回调函数

4. clearInterval

`clearInterval(number intervalID)`

取消由 setInterval 设置的定时器。

# 组件

## 图片组件的样式模式

原生组件 image 的 mode 的合法值，默认值 scaleToFill

1. 缩放模式

- scaleToFill 不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素
- aspectFit 保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。
- aspectFill 保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。
- widthFix 宽度不变，高度自动变化，保持原图宽高比不变
- heightFix 高度不变，宽度自动变化，保持原图宽高比不变

2. 裁剪模式，不缩放图片

- top 只显示图片的顶部区域
- bottom 只显示图片的底部区域
- center 只显示图片的中间区域
- left 只显示图片的左边区域
- right 只显示图片的右边区域
- top left 只显示图片的左上边区域
- top right 只显示图片的右上边区域
- bottom left 只显示图片的左下边区域
- bottom right 只显示图片的右下边区域

图片 UI 组件 van-image 填充模式 fit，默认值 fill

- contain 保持宽高缩放图片，使图片的长边能完全显示出来
- cover 保持宽高缩放图片，使图片的短边能完全显示出来，裁剪长边
- fill 拉伸图片，使图片填满元素
- widthFix 缩放模式，宽度不变，高度自动变化，保持原图宽高比不变
- heightFix 缩放模式，高度不变，宽度自动变化，保持原图宽高比不变
- none 保持图片原有尺寸

# 底层框架
## 组件运行原理

在使用自定义组件的小程序页面中，Exparser 将接管所有的自定义组件注册与实例化。从外部接口上看，小程序基础库提供有 Page 和 Component 两个构造器。以 Component 为例，在小程序启动时，构造器会将开发者设置的 properties、data、methods 等定义段，写入 Exparser 的组件注册表中。这个组件在被其它组件引用时，就可以根据这些注册信息来创建自定义组件的实例。Page 构造器的大体运行流程与之相仿，只是参数形式不一样。这样每个页面就有一个与之对应的组件，称为“页面根组件”。

在初始化页面时，Exparser 会创建出页面根组件的一个实例，用到的其他组件也会响应创建组件实例（这是一个递归的过程）。组件创建的过程大致有以下几个要点：

1. 根据组件注册信息，从组件原型上创建出组件节点的 JS 对象，即组件的 this；
2. 将组件注册信息中的 data 复制一份，作为组件数据，即 this.data；
3. 将这份数据结合组件 WXML，据此创建出 Shadow Tree，由于 Shadow Tree 中可能引用有其他组件，因而这会递归触发其他组件创建过程；
4. 将 ShadowTree 拼接到 Composed Tree 上，并生成一些缓存数据用于优化组件更新性能；
5. 触发组件的 created 生命周期函数；
6. 如果不是页面根组件，需要根据组件节点上的属性定义，来设置组件的属性值；
7. 当组件实例被展示在页面上时，触发组件的 attached 生命周期函数，如果 Shadw Tree 中有其他组件，也逐个触发它们的生命周期函数。

## 原生组件运行机制

在原生组件内部，其节点树非常简单，基本上可以认为只有一个 div 元素。上面这行代码在渲染层开始运行时，会经历以下几个步聚：

1. 组件被创建，包括组件属性会依次赋值。
2. 组件被插入到 DOM 树里，浏览器内核会立即计算布局，此时我们可以读取出组件相对页面的位置（x, y 坐标）、宽高。
3. 组件通知客户端，客户端在相同的位置上，根据宽高插入一块原生区域，之后客户端就在这块区域渲染界面
4. 当位置或宽高发生变化时，组件会通知客户端做相应的调整

我们可以看出，原生组件在 WebView 这一层的渲染任务是很简单，只需要渲染一个占位元素，之后客户端在这块占位元素之上叠了一层原生界面。因此，原生组件的层级会比所有在 WebView 层渲染的普通组件要高。

## 同层渲染

「同层渲染」顾名思义则是指通过一定的技术手段把原生组件直接渲染到 WebView 层级上，此时「原生组件层」已经不存在，原生组件此时已被直接挂载到 WebView 节点上。你几乎可以像使用非原生组件一样去使用「同层渲染」的原生组件，比如使用 view、image 覆盖原生组件、使用 z-index 指定原生组件的层级、把原生组件放置在 scroll-view、swiper、movable-view 等容器内，通过 WXSS 设置原生组件的样式等等。

**iOS 端**

小程序在 iOS 端使用 WKWebView 进行渲染的，WKWebView 在内部采用的是分层的方式进行渲染，它会将 WebKit 内核生成的 Compositing Layer（合成层）渲染成 iOS 上的一个 WKCompositingView，这是一个客户端原生的 View，不过可惜的是，内核一般会将多个 DOM 节点渲染到一个 Compositing Layer 上，因此合成层与 DOM 节点之间不存在一对一的映射关系。不过我们发现，当把一个 DOM 节点的 CSS 属性设置为 `overflow: scroll` （低版本需同时设置 `-webkit-overflow-scrolling: touch`）之后，WKWebView 会为其生成一个 WKChildScrollView，与 DOM 节点存在映射关系，这是一个原生的 UIScrollView 的子类，也就是说 WebView 里的滚动实际上是由真正的原生滚动组件来承载的。WKWebView 这么做是为了可以让 iOS 上的 WebView 滚动有更流畅的体验。虽说 WKChildScrollView 也是原生组件，但 WebKit 内核已经处理了它与其他 DOM 节点之间的层级关系，因此你可以直接使用 WXSS 控制层级而不必担心遮挡的问题。

小程序 iOS 端的「同层渲染」也正是基于 WKChildScrollView 实现的，原生组件在 attached 之后会直接挂载到预先创建好的 WKChildScrollView 容器下，大致的流程如下：

1. 创建一个 DOM 节点并设置其 CSS 属性为 `overflow: scroll` 且 `-webkit-overflow-scrolling: touch`；
2. 通知客户端查找到该 DOM 节点对应的原生 WKChildScrollView 组件；
3. 将原生组件挂载到该 WKChildScrollView 节点上作为其子 View。

通过上述流程，小程序的原生组件就被插入到 WKChildScrollView 了，也即是在 步骤 1 创建的那个 DOM 节点对应的原生 ScrollView 的子节点。此时，修改这个 DOM 节点的样式属性同样也会应用到原生组件上。因此，「同层渲染」的原生组件与普通的内置组件表现并无二致。

**Android 端**

小程序在 Android 端采用 chromium 作为 WebView 渲染层，与 iOS 不同的是，Android 端的 WebView 是单独进行渲染而不会在客户端生成类似 iOS 那样的 Compositing View (合成层)，经渲染后的 WebView 是一个完整的视图，因此需要采用其他的方案来实现「同层渲染」。经过我们的调研发现，chromium 支持 WebPlugin 机制，WebPlugin 是浏览器内核的一个插件机制，主要用来解析和描述 embed 标签。Android 端的同层渲染就是基于 embed 标签结合 chromium 内核扩展来实现的。

Android 端「同层渲染」的大致流程如下:

1. WebView 侧创建一个 embed DOM 节点并指定组件类型；
2. chromium 内核会创建一个 WebPlugin 实例，并生成一个 RenderLayer；
3. Android 客户端初始化一个对应的原生组件；
4. Android 客户端将原生组件的画面绘制到步骤 2 创建的 RenderLayer 所绑定的 SurfaceTexture 上；
5. 通知 chromium 内核渲染该 RenderLayer；
6. chromium 渲染该 embed 节点并上屏。

这样就实现了把一个原生组件渲染到 WebView 上，这个流程相当于给 WebView 添加了一个外置的插件，如果你有留意 Chrome 浏览器上的 pdf 预览，会发现实际上它也是基于 `<embed />` 标签实现的。

这种方式可以用于 map、video、canvas、camera 等原生组件的渲染，对于 input 和 textarea，采用的方案是直接对 chromium 的组件进行扩展，来支持一些 WebView 本身不具备的能力。

对比 iOS 端的实现，Android 端的「同层渲染」真正将原生组件视图加到了 WebView 的渲染流程中且 embed 节点是真正的 DOM 节点，理论上可以将任意 WXSS 属性作用在该节点上。Android 端相对来说是更加彻底的「同层渲染」，但相应的重构成本也会更高一些。