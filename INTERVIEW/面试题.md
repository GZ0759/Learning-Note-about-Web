> 根据网上的面试题整理出来的

# HTML

## Doctype 作用，严格模式与混杂模式.

`<!DOCTYPE>` 声明必须是 HTML 文档的第一行，位于 `<html>` 标签之前。<!DOCTYPE> 声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。HTML5 不基于 SGML，所以不需要引用 DTD。

严格模式：又称标准模式，是指浏览器按照 W3C 标准解析代码。混杂模式：又称怪异模式或兼容模式，是指浏览器用自己的方式解析代码。浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD 直接相关。DOCTYPE 不存在或格式不正确会导致文档以混杂模式呈现。

## HTML5 新特性

- 语义化标签（header、section、article、aside、nav、footer）
- 增强型表单：新增属性（例如 require、placeholder）、新增元素（datalist、output）
- Canvas 画布，`getContext()` 方法可返回一个对象，该对象提供了用于在画布上绘图的方法和属性。
- 多媒体相关 API。音频（audio）和视频（video）。
- History API。通过脚本管理浏览器的历史记录。
- 本地储存。sessionStorage 和 localStorage。
- 离线应用程序。cache manifest 文件
- 文件 API。FileReader API。
- 通信 API。跨文档消息传输功能、使用 WebSockets API 来通过 socket 端口传递数据的功能和通过 Server-Sent Eventsource API 将服务器端事件主动推动到客户端的功能。
- Web Workers 处理线程。web worker 是运行在后台的 JavaScript，不会影响页面的性能。
- 获取地理位置信息。获取用户地理位置信息的 Geolocation API。
- 拖放 API 和通知 API。

### WebSocket

它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。

WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。readyState 属性返回实例对象的当前状态，共有四种。实例对象的 onopen 属性，用于指定连接成功后的回调函数。实例对象的 onclose 属性，用于指定连接关闭后的回调函数。实例对象的 onmessage 属性，用于指定收到服务器数据后的回调函数。实例对象的 `send()` 方法用于向服务器发送数据。

### Web Workers

Javascript 是运行在单线程环境中，也就是说无法同时运行多个脚本。但是，如果将这段代码交给 Web Worker 去运行的话，那么情况就不一样了：浏览器会在后台启动一个独立的 worker 线程来专门负责代码的运行，因此，页面在这段 Javascript 代码运行期间依然可以响应用户的其他操作。

Web Worker 规范中定义了两类工作线程，分别是专用线程 Dedicated Worker 和共享线程 Shared Worker，其中，Dedicated Worker 只能为一个页面所使用，而 Shared Worker 则可以被多个页面所共享。

只需调用 `Worker()` 构造函数并传入一个要在 worker 线程内运行的脚本的 URI，即可创建一个新的 worker。Worker 与其主页面之间的通信是通过 onmessage 事件和 `postMessage()` 方法实现的。

## HTML5 兼容性

IE9+以及谷歌、火狐、苹果等主流浏览器对大部分 HTML5 属性均为支持状态。IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签。浏览器支持新标签后，还需要添加标签默认的样式（当然最好的方式是直接使用成熟的框架、使用最多的是 html5shim 框架）。

```html
<!--[if lt IE 9]>
  <script>
    src = "http://html5shim.googlecode.com/svn/trunk/html5.js";
  </script>
<![endif]-->
```

## HTML5 标签变化

新增的标签

- 结构标签
  - article 一篇文章
  - header 一个页面或一个区域的头部
  - nav 导航链接
  - section 一个区域
  - aside 页面内容部分的侧边栏
  - hgroup 文件中一个区域的相关信息
  - figure 一组媒体内容以及它们的标题
  - figcaption figure 元素的标题
  - footer 一个页面或一个区域的底部
  - dialog 一个对话框

- 多媒体标签
  - videa 一个视频
  - audio 音频内容
  - source 媒体资源
  - canvas 图片
  - embed 外部的可交互的内容或插件，例如 flash

- Web 应用标签
  - meter 状态标签（实时状态显示：气压、气温）
  - progress 状态标签（任务过程：安装、加载）
  - menu 命令列表
  - menuitem menu 命令列表标签
  - command menu 标记定义一个命令按钮

- 其它标签
  - ruby 注释或音标
  - rp 不支持 ruby 元素的显示内容
  - rt 对 ruby 的注释内容文本
  - mark 有标记的文本（黄色选中状态）
  - output 一些输入类型
  - keygen 表单里一个生成的键值
  - time 一个日期/时间

移除的元素有纯表现的元素（basefont/big/center/font/s/strike/tt/u）、对可用性产生负面影响的元素（frame/frameset/noframes）、产生混淆的元素（acronym/applet/isindex/dir）。

重定义标签。显示不变，只是表达的含义进行了重新定义的标签。

- b 代表内联文本，通常是粗体，没有传递表示重要的意思
- i 代表内联文本，通常是斜体，没有传递表示重要的意思
- dd 可以同 details 与 figure 一同使用，定义包含文本，dialog 也可用
- dt 可以同 details 与 figure 一同使用，汇总细节，dialog 也可用
- hr 表示主题结束，而不是水平线，虽然显示相同
- menu 重新定义用户界面的菜单，配合 commond 或者 menuitem 使用
- small 表示小字体，例如打印注释或者法律条款
- strong 表示重要性而不是强调符号

## 如何区分 HTML 和 HTML5?

HTML5 文档类型声明：`<!doctype html>`。DOCTYPE 声明的方式是区分 HTML 和 HTML5 标志的一个重要因素，此外，还可以根据新增的结构、功能元素来加以区分。

## 语义化的理解

HTML 语义化就是让页面的内容结构化，便于阅读和维护，便于浏览器、搜索引擎解析，利于 SEO。

## HTML5 的 webstorage 和 cookies

webstorage 是本地存储，存储在客户端，包括 localStorage 和 sessionStorage。

localStorage 生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。

sessionStorage 仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。源生接口可以接受，亦可再次封装来对Object和Array有更好的支持。

cookie 在浏览器和服务器间来回传递。生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。存放数据大小为4K左右 。有个数限制（各浏览器不同），一般不能超过20个。与服务器端通信：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题。

## iframe 缺点

iframe 会阻塞主页面的 Onload 事件；iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。

使用 iframe 之前需要考虑这两个缺点。如果需要使用 iframe，最好是通过 javascript 动态给 iframe 添加 src 属性值，这样可以可以绕开以上两个问题。

# CSS

## 行内元素. 块级元素

一个行内元素只占据它对应标签的边框所包含的空间。

行内元素有：a b span img input select strong（强调的语气）

块级元素占据其父元素（容器）的整个空间，因此创建了一个“块”。通常浏览器会在块级元素前后另起一个新行。

块级元素有：div ul ol li dl dt dd h1 h2 h3 h4 p

## CSS 选择符

标签选择器、类选择器、id 选择器、后代选择器、子选择器、相邻选择器、通配符选择器、属性选择器。

伪元素（::first-letter/::first-line/::before/::after）。

伪类（:link/:visited/:hover/:active）、结构化伪类和表单伪类。

## CSS3 新增伪类

p:first-of-type 选择属于其父元素的首个 `<p>` 元素的每个 `<p>` 元素。

p:last-of-type 选择属于其父元素的最后 `<p>` 元素的每个 `<p>` 元素。

p:only-of-type 选择属于其父元素唯一的 `<p>` 元素的每个 `<p>` 元素。

p:only-child 选择属于其父元素的唯一子元素的每个 `<p>` 元素。

p:nth-child(2) 选择属于其父元素的第二个子元素的每个 `<p>` 元素。

:enabled :disabled 控制表单控件的禁用状态。

:checked 单选框或复选框被选中。

## CSS3 新特性

视觉表现更进步（圆角、阴影和渐变、transform 变换、filter 滤镜和混合模式、animation 动画）、布局更为丰富（CSS3 媒介查询、弹性盒子布局、格珊布局）。

- CSS3 边框（Borders）。可以创建圆角边框，添加阴影框，并作为边界的形象而不使用设计程序。

`border-image`	设置所有边框图像的速记属性。
`border-radius`	一个用于设置所有四个边框- *-半径属性的速记属性
`box-shadow`	附加一个或多个下拉框的阴影

- CSS3 背景。CSS3中包含几个新的背景属性，提供更大背景元素控制。

`background-clip`	规定背景的绘制区域。
`background-origin`	规定背景图片的定位区域。
`background-size`	规定背景图片的尺寸。

- CSS3 渐变。CSS3 定义了两种类型的渐变（gradients）。
  - 线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向`background: linear-gradient(direction, color-stop1, color-stop2, ...)`
  - 径向渐变（Radial Gradients）- 由它们的中心定义`background: radial-gradient(center, shape size, start-color, ..., last-color);`

- CSS3 文本效果

`hanging-punctuation`	规定标点字符是否位于线框之外。
`punctuation-trim`	规定是否对标点字符进行修剪。
`text-align-last`	设置如何对齐最后一行或紧挨着强制换行符之前的行。
`text-emphasis`	向元素的文本应用重点标记以及重点标记的前景色。
`text-justify`	规定当 text-align 设置为 "justify" 时所使用的对齐方法。
`text-outline`	规定文本的轮廓。
`text-overflow`	规定当文本溢出包含元素时发生的事情。
`text-shadow`	向文本添加阴影。
`text-wrap`	规定文本的换行规则。
`word-break`	规定非中日韩文本的换行规则。
`word-wrap`	允许对长的不可分割的单词进行分割并换行到下一行。

- CSS3 字体

以前 CSS3 的版本，网页设计师不得不使用用户计算机上已经安装的字体。使用 CSS3，网页设计师可以使用他/她喜欢的任何字体。当你发现您要使用的字体文件时，只需简单的将字体文件包含在网站中，它会自动下载给需要的用户。您所选择的字体在新的 CSS3 版本有关于`@font-face`规则描述。您"自己的"的字体是在 CSS3 @font-face 规则中定义的。

- CSS3 转换和变形

  - 2D新转换属性

  `transform`	适用于2D或3D转换的元素

  `transform-origin`	允许您更改转化元素位置

  - 2D 转换方法

  `matrix(n,n,n,n,n,n)`	定义 2D 转换，使用六个值的矩阵。  
  `translate(x,y)`	定义 2D 转换，沿着 X 和 Y 轴移动元素。  
  `translateX(n)`	定义 2D 转换，沿着 X 轴移动元素。  
  `translateY(n)`	定义 2D 转换，沿着 Y 轴移动元素。  
  `scale(x,y)`	定义 2D 缩放转换，改变元素的宽度和高度。  
  `scaleX(n)`	定义 2D 缩放转换，改变元素的宽度。  
  `scaleY(n)`	定义 2D 缩放转换，改变元素的高度。  
  `rotate(angle)`	定义 2D 旋转，在参数中规定角度。  
  `skew(x-angle,y-angle)`	定义 2D 倾斜转换，沿着 X 和 Y 轴。  
  `skewX(angle)`	定义 2D 倾斜转换，沿着 X 轴。  
  `skewY(angle)`	定义 2D 倾斜转换，沿着 Y 轴。  

  - 3D转换属性

  `transform`	向元素应用 2D 或 3D 转换。

  `transform-origin`	允许你改变被转换元素的位置。

  `transform-style`	规定被嵌套元素如何在 3D 空间中显示。

  `perspective`	规定 3D 元素的透视效果。

  `perspective-origin`	规定 3D 元素的底部位置。

  `backface-visibility`	定义元素在不面对屏幕时是否可见。


  - 3D 转换方法

  `matrix3d(n,n,n,n,n,n, n,n,n,n,n,n,n,n,n,n)`	定义 3D 转换，使用 16 个值的 4x4 矩阵。
  `translate3d(x,y,z)`	定义 3D 转化。
  `translateX(x)`	定义 3D 转化，仅使用用于 X 轴的值。
  `translateY(y)`	定义 3D 转化，仅使用用于 Y 轴的值。
  `translateZ(z)`	定义 3D 转化，仅使用用于 Z 轴的值。
  `scale3d(x,y,z)`	定义 3D 缩放转换。
  `scaleX(x)`	定义 3D 缩放转换，通过给定一个 X 轴的值。
  `scaleY(y)`	定义 3D 缩放转换，通过给定一个 Y 轴的值。
  `scaleZ(z)`	定义 3D 缩放转换，通过给定一个 Z 轴的值。
  `rotate3d(x,y,z,angle)`	定义 3D 旋转。
  `rotateX(angle)`	定义沿 X 轴的 3D 旋转。
  `rotateY(angle)`	定义沿 Y 轴的 3D 旋转。
  `rotateZ(angle)`	定义沿 Z 轴的 3D 旋转。
  `perspective(n)`	定义 3D 转换元素的透视视图。

- CSS3 过渡

`transition`	简写属性，用于在一个属性中设置四个过渡属性。

`transition-property`	规定应用过渡的 CSS 属性的名称。

`transition-duration`	定义过渡效果花费的时间。默认是 0。

`transition-timing-function`	规定过渡效果的时间曲线。默认是 "ease"。

`transition-delay`	规定过渡效果何时开始。默认是 0。


- CSS3 动画

要创建CSS3动画，你需要了解@keyframes规则。@keyframes规则是创建动画。 @keyframes规则内指定一个CSS样式和动画将逐步从目前的样式更改为新的样式。

`@keyframes`	规定动画。
`animation`	所有动画属性的简写属性，除了 animation-play-state 属性。
`animation-name`	规定 @keyframes 动画的名称。
`animation-duration`	规定动画完成一个周期所花费的秒或毫秒,默认是 0。
`animation-delay`	规定动画何时开始,默认是 0。
`animation-iteration-count`	规定动画被播放的次数,默认是 1。
`animation-direction`	规定动画是否在下一周期逆向地播放,默认是 "normal"。
`animation-play-state`	规定动画是否正在运行或暂停,默认是 "running"。

- CSS3 多列

`column-count`	指定元素应该被分割的列数。

`column-fill`	指定如何填充列。

`column-gap`	指定列与列之间的间隙。

`column-rule`	所有 column-rule-* 属性的简写。

`column-rule-color`	指定两列间边框的颜色。

`column-rule-style`	指定两列间边框的样式。

`column-rule-width`	指定两列间边框的厚度。

`column-span`	指定元素要跨越多少列。

`column-width`	指定列的宽度。

`columns`	设置 column-width 和 column-count 的简写。

- CSS3 盒模型

在 CSS3 中, 增加了一些新的用户界面特性来调整元素尺寸，框尺寸和外边框，主要包括以下用户界面属性：

resize属性指定一个元素是否应该由用户去调整大小。

`resize：none | both | horizontal | vertical | inherit`

box-sizing 属性允许您以确切的方式定义适应某个区域的具体内容。

`box-sizing: content-box | border-box | inherit`

outline-offset 属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。

`outline:outline-color outline-style outline-width outine-offset`

- CSS3 flex box

CSS3 弹性盒（Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。

引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。

`display`	指定 HTML 元素盒子类型。  
`flex-flow`	flex-direction 和 flex-wrap 的简写。  
`flex-direction`	指定了弹性容器中子元素的排列方式。  
`flex-wrap`	设置弹性盒子的子元素超出父容器时是否换行。  
`justify-content`	设置弹性盒子元素在主轴（横轴）方向上的对齐方式。  
`align-items`	设置弹性盒子元素在侧轴（纵轴）方向上的对齐方式。  
`align-content`	修改 flex-wrap 属性的行为，类似 align-items, 但不是设置子元素对齐，而是设置行对齐。  
`order`	设置弹性盒子的子元素排列顺序。  
`align-self`	在弹性子元素上使用，覆盖容器的 align-items 属性。  
`flex`	设置弹性盒子的子元素如何分配空间，是 flex-grow、flex-shrink 和 flex-basis 属性的简写属性。  
`flex-grow`	一个数字，规定项目将相对于其他灵活的项目进行扩展的量。  
`flex-shrink`	一个数字，规定项目将相对于其他灵活的项目进行收缩的量。  
`flex-basis`	项目的长度，合法值："auto"、"inherit" 或一个后跟 "%"、"px"、"em" 或任何其他长度单位的数字。  

- CSS3 多媒体查询

从 CSS 版本 2 开始，就可以通过媒体类型在 CSS 中获得媒体支持。如果您曾经使用过打印样式表，那么您可能已经使用过媒体类型。

```JavaScript
<link rel="stylesheet" type="text/css" href="site.css" media="screen" />
<link rel="stylesheet" type="text/css" href="print.css" media="print" />
```

媒体查询规则。`@media all and (min-width: 800px) { ... }`

@media all 是媒体类型，也就是说，将此 CSS 应用于所有媒体类型。(min-width:800px) 是包含媒体查询的表达式，如果浏览器的最小宽度为 800 像素，则会告诉浏览器只运用下列 CSS。

```css
@media (min-width:800px) and (max-width:1200px) and (orientation:portrait) { ... }

@media (min-width:800px) or (orientation:portrait) { ... }

@media (not min-width:800px) { ... }
```

## 清除浮动

浮动元素脱离了文档流，其父元素也看不到它了，因而也不会包围它。浮动产生的副作用有：父元素背景不能显示、边框不能撑开、margin/padding 设置值不能正确显示。

1. 为父元素添加 `overflow: hidden`或 auto ，兼容 IE 则使用 `zoom: 1`
2. 同时浮动父元素或设置父元素固定高度
3. 添加非浮动的清除元素或清除伪类

## position 属性

1. 静态定位`static`。默认值，没有定位，元素出现在正常的流中（忽略四个定位属性或者 z-index 声明）。
2. 相对定位`relative`。相对于其正常位置进行定位。可以使用四个定位属性移动位置。
3. 绝对定位`absolute`。相对于离它最近的 position 不为 static 的祖先元素定位。元素的位置通过 "left", "top", "right" 以及 "bottom" 这四个定位属性进行规定。
4. 固定定位`fixed`。相对于浏览器窗口或手持设备的屏幕进行定位。根元素（很多场景下可以看成是`<html>`）被称为“初始包含块”。元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。
5. 继承值`inherit`。规定应该从父元素继承 position 属性的值。

## link 和 @import 的区别。

从属关系区别。`@import` 是 CSS 提供的语法规则，只有导入样式表的作用；`link` 是 HTML 提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。

加载顺序区别。加载页面时，link 标签引入的 CSS 被同时加载；`@import` 引入的 CSS 将在页面加载完毕后被加载。

兼容性区别。`@import` 是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link 标签作为 HTML 元素，不存在兼容性问题。

DOM 可控性区别。可以通过 JS 操作 DOM ，插入 `link` 标签来改变样式；由于 DOM 方法是基于文档的，无法使用`@import` 的方式插入样式。

权重区别。link 引入的样式权重大于`@import` 引入的样式。

# JavaScript

## 前端优化

加载页面和静态资源

- 静态资源的压缩合并，减小资源的大小，减少http请求
- 静态资源缓存，
- 使用CDN让资源加载更快
- 使用SSR（服务端渲染）后端渲染，数据直接输出到HTML中

页面渲染优化

- CSS放前面，JS放后面
- 懒加载（图片懒加载，下拉加载更多）
- 减少DOM查询，对DOM查询做缓存
- 减少DOM操作，多个DOM操作尽量合并在一起执行
- 事件节流
- 尽早执行操作（如使用DOMCotentLoaded）

## typeof 返回数据类型

Undefined、Boolean、Number、String、Function、Object、Symbol

## jsonp 原理

要理解跨域，先要了解一下“同源策略”。所谓同源是指，域名，协议，端口相同。所谓“同源策略“，简单的说就是基于安全考虑，当前域不能访问其他域的东西。

JSONP 实现跨域请求的原理简单的说，就是动态创建`<script>`标签，然后利用`<script>`的 src 不受同源策略约束来跨域获取数据。Ajax 是页面无刷新请求数据操作。

## 异步 ajax 优缺点

优点：不会造成 UI 卡死，用户体验好；局部刷新页面，省流量。

缺点：后退按钮无效，多个请求回调时间不确定，对搜索引擎不友好、数据安全。

## src 与 href

href 表示超文本引用（hypertext reference），在 `<link>` 和 `<a>` 等元素上使用。src 表示来源地址，是指外部资源的位置，指向的内容将会嵌入到文档中当前标签 所在的位置，在 img、script、iframe 等元素上。

## 前端闭包

使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。

闭包有三个特性：

1. 函数嵌套函数
2. 函数内部可以引用外部的参数和变量
3. 参数和变量不会被垃圾回收机制回收

## js 垃圾回收方法

标记清除（mark and sweep）

这是 JavaScript 最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。

垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了。

引用计数(reference counting)

在低版本 IE 中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加 1，如果该变量的值变成了另外一个，则这个值得引用次数减 1，当这个值的引用次数变为 0 的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的空间。

在 IE 中虽然 JavaScript 对象通过标记清除的方式进行垃圾回收，但 BOM 与 DOM 对象却是通过引用计数回收垃圾的， 也就是说只要涉及 BOM 及 DOM 就会出现循环引用问题。

## 创建 Ajax 的步骤

1. 创建 XMLHttpRequest 对象，也就是创建一个异步调用对象；
2. 创建一个新的 HTTP 请求，并指定改 HTTP 请求的方法、URL 以及验证信息；
3. 设置响应 HTTP 状态变化的函数；
4. 发送 HTTP 请求；
5. 获取异步调用返回的数据；
6. 使用 JavaScript 和 DOM 实现局部刷新；

```js
var xhr;
if (window.XMLHttpRequest) { // 标准浏览器
  xhr = new XMLHttpRequest();
}else { // IE浏览器
  xhr = ActiveXObject('Microsoft.XMLHTTP');
}

xhr.open('get', 'api/ajax.php', true); // 创建HTTP连接

xhr.oreadystatechange = function () { // 响应HTTP状态变化
  if (xhr.readyState == 4) {
    if (xhr.status == 200) {
      var data = xhr.responseText;
    }
  }
}

xhr.send(); // 向服务器发送请求
```

## GET 请求和 POST 请求。

1. 使用 Get 请求时,参数在 URL 中显示,而使用 Post 请求,则不会显示出来；
2. Post 传输的数据量大，可以达到 2M，而 Get 方法由于受到 URL 长度的限制,只能传递大约 1024 字节.
3. Get 请求请求需注意缓存问题，Post 请求不需担心这个问题；
4. Post 请求必须设置 Content-Type 值为 application/x-form-www-urlencoded；
5. 发送请求时,因为 Get 请求的参数都在 url 里,所以 send 函数发送的参数为 null,而 Post 请求在使用 send 方法时,却需赋予其参数；
6. GET 方式请求的数据会被浏览器缓存起来，因此其他人就可以从浏览器的历史记录中读取到这些数据，例如账号和密码等。在某种情况下，GET 方式会带来严重的安全问题。而 POST 方式相对来说就可以避免这些问题。

## TypeScript 语法

简单笼统地说，TypeScript 是 JavaScript 的超集，是微软开发的一种脚本语言。和 JavaScript 一样，是现在项目开发中热门的脚本语言。

TypeScript 是一种强类型语言，可编译成 JavaScript，包含了 JavaScript 的所有元素，可以载入 JavaScript 代码运行，扩展了 JavaScript 的语法。相比 JavaScript，TypeScript 是真面向对象，增加了静态类型，类，模块，接口和类型注解。

TypeScript 的编译器很智能，会进行冲突检测，举个例子，一个 enum 的数据，你初始化一个数据，再用一个 switch 语句，编译器会判定其他选项为无效的，会编译错误，直接指出错误原因，这在 JavaScript 是不会指出错误的。

## Web 客户端

主流浏览器的内核。IE 浏览器是 Trident，Mozilla 浏览器是 Gecko，Safari 浏览器是 Webkit，Chrome 浏览器是 Blink，Opera 浏览器现在也是 Blink。

同源策略是对 XHR 的一个主要约束，它为通信设置了“相同的域、相同的端口、相同的协议”这一限制。试图访问上述限制之外的资源，都会引发安全错误，除非采用被认可的跨域解决方案。这个解决方案叫做 CORS（ Cross-Origin Resource Sharing，跨源资源共享）， IE8 通过 XDomainRequest 对象支持 CORS，其他浏览器通过 XHR 对象原生支持 CORS。图像 Ping 和 JSONP 是另外两种跨域通信的技术，但不如 CORS 稳妥。

## 遍历

1. 普通的for循环。最简单的一种，正常用的话也不会出现什么问题，想中断也可以中断，性能上也还可以。

```js
var arr = [1, 2, 3]
for(var i = 0; i < arr.length; i++) { // 这里的i是代表数组的下标
    console.log(i); // 0, 1, 2
};
```

2. `for in`遍历。这个更多是用来遍历对象，很少用来遍历数组，不过 item 对应与数组的 key 值，建议不要用该方法来遍历数组，因为它的效率是最低的。遍历对象时，可以遍历到myObject的原型方法method,如果不想遍历原型方法和属性的话，可以在循环内部判断一下，hasOwnPropery方法可以判断某属性是否是该对象的实例属性

```js
// 遍历对象
for (var key in myObject) {
　　if(myObject.hasOwnProperty(key)){
　　　　console.log(key);
　　}
}

// 遍历数组
var arr = [1, 2, 3]
for(var item in arr) { // item遍历数组时为数组的下标，遍历对象时为对象的key值
    console.log(item); // 0, 1, 2
};
```

`for in`遍历数组的毛病
- index索引为字符串型数字，不能直接进行几何运算
- 遍历顺序有可能不是按照实际数组的内部顺序
- 使用`for in`会遍历数组所有的可枚举属性，包括原型。例如原型方法 method 和 name 属性

3. ES5具有遍历数组方法。但是使用 foreach 遍历数组的话，使用 break 不能中断循环，使用 return 也不能返回到外层函数。

方法有`forEach`、`map`、`filter`、`some`、`every`、`reduce`、`reduceRight`等，只不过他们的返回结果不一样。

4. ES6中的`for of`。这个遍历的是数组元素（键值），不包括数组的原型属性 method 和索引 name 。`for of`适用遍历数、数组对象、字符串、`map`、`set`等拥有迭代器对象的集合.但是不能遍历对象,因为没有迭代器对象。与`forEach()`不同的是，它可以正确响应break、continue和return语句。

```js
Array.prototype.method = function () {　　
  console.log(this.length);
}
var myArray = [1, 2, 4, 5, 6, 7]
myArray.name = "数组";
// 1 2 4 5 6 7
for (var value of myArray) {
  console.log(value);
}
```

同样可以通过 ES5 的`Object.keys(myObject)`获取对象的实例属性组成的数组，不包括原型方法和属性。ES2017 引入了跟`Object.keys`配套的`Object.values`和`Object.entries`，作为遍历一个对象的补充手段，供`for of`循环使用。

```js
// Object.keys()
for (var key of Object.keys(someObject)) {
  console.log(key + ": " + someObject[key]);
}

// 遍历map对象时适合用解构
for (var [key, value] of phoneBookMap) {
   console.log(key + "'s phone number is: " + value);
}
```

`for of`的步骤。`for of`循环首先调用集合的`Symbol.iterator`方法，紧接着返回一个新的迭代器对象。迭代器对象可以是任意具有`.next()`方法的对象；`for of`循环将重复调用这个方法，每次循环调用一次。举个例子，这段代码是能想出来的最简单的迭代器：

```js
var zeroesForeverIterator = {
 [Symbol.iterator]: function () {
   return this;
  },
  next: function () {
  return {done: false, value: 0};
 }
};
```

# Vue

## 基础点

### 单页面 SPA

对 SPA 单⻚⾯的理解，优缺点是什么？

SPA（ single-page application ）仅在 Web ⻚⾯初始化时加载相应的 HTML、JavaScript 和 CSS。⼀旦⻚⾯加载完成，SPA 不会因为⽤户的操作⽽进⾏⻚⾯的重新加载或跳转；取⽽代之的是利⽤路由机制实现 HTML 内容的变换，UI 与⽤户的交互，避免⻚⾯的重新加载。

优点：

1. ⽤户体验好、快，内容的改变不需要重新加载整个⻚⾯，避免了不必要的跳转和重复渲染；
2. SPA 相对对服务器压⼒⼩；
3. 前后端职责分离，架构清晰，前端进⾏交互逻辑，后端负责数据处理；
   缺点：
4. ⾸屏（初次）加载慢：为实现单⻚ Web 应⽤功能及显示效果，需要在加载⻚⾯的时候将 JavaScript、CSS 统⼀加载，部分⻚⾯按需加载；
5. 不利于 SEO：由于所有的内容都在⼀个⻚⾯中动态替换显示，所以在 SEO 上其有着天然的弱势。

### Vue 初始化

new Vue() 发生了什么？

1. 结论：new Vue()是创建 Vue 实例，它内部执行了根实例的初始化过程。
2. 具体包括以下操作：

- 选项合并
- $children，$refs，$slots，$createElement 等实例属性的方法初始化
- 自定义事件处理
- 数据响应式处理
- 生命周期钩子调用 （beforecreate created）
- 可能的挂载

3. 总结：new Vue()创建了根实例并准备好数据和方法，未来执行挂载时，此过程还会递归的应用于它的子组件上，最终形成一个有紧密关系的组件实例树。

源码地址：src/core/instance/init.js

### Vue.use 是干什么的？原理是什么？

vue.use 是用来使用插件的，我们可以在插件中扩展全局组件、指令、原型方法等。

过程

1. 检查插件是否注册，若已注册，则直接跳出；
2. 处理入参，将第一个参数之后的参数归集，并在首部塞入 this 上下文；
3. 执行注册方法，调用定义好的 install 方法，传入处理的参数，若没有 install 方法并且插件本身为 function 则直接进行注册；

应用

1. 插件不能重复的加载
   install 方法的第一个参数是 vue 的构造函数，其他参数是 Vue.set 中除了第一个参数的其他参数； 代码：args.unshift(this)
2. 调用插件的 install 方法 代码：typeof plugin.install === 'function'
3. 插件本身是一个函数，直接让函数执行。 代码：plugin.apply(null, args)
4. 缓存插件。 代码：installedPlugins.push(plugin)

源码地址：src/core/global-api/use.js

### 响应式数据

请说一下响应式数据的理解？

根据数据类型来做不同处理，数组和对象类型当值变化时如何劫持。

1. 对象内部通过 defineReactive 方法，使用 Object.defineProperty() 监听数据属性的 get 来进行数据依赖收集，再通过 set 来完成数据更新的派发；

2. 数组则通过重写数组方法来实现的。扩展它的 7 个变更⽅法，通过监听这些方法可以做到依赖收集和派发更新；( push/pop/shift/unshift/splice/reverse/sort )

这里在回答时可以带出一些相关知识点 （比如多层对象是通过递归来实现劫持，顺带提出 vue3 中是使用 proxy 来实现响应式数据）

补充回答：
内部依赖收集是怎么做到的，每个属性都拥有自己的 dep 属性，存放他所依赖的 watcher，当属性变化后会通知自己对应的 watcher 去更新。

响应式流程：
1､defineReactive 把数据定义成响应式的；
2､给属性增加一个 dep，用来收集对应的那些 watcher；
3､等数据变化进行更新
dep.depend() // get 取值：进行依赖收集
dep.notify() // set 设置时：通知视图更新

这里可以引出性能优化相关的内容：1)对象层级过深，性能就会差。2)不需要响应数据的内容不要放在 data 中。3)object.freeze() 可以冻结数据。

源码地址：src/core/observer/index.js 158

### 数组检测

Vue 如何检测数组变化？

数组考虑性能原因没有用 defineProperty 对数组的每一项进行拦截，而是选择重写数组 方法以进行重写。当数组调用到这 7 个方法的时候，执行 ob.dep.notify() 进行派发通知 Watcher 更新；

- 重写数组方法：push/pop/shift/unshift/splice/reverse/sort

补充回答：
在 Vue 中修改数组的索引和长度是无法监控到的。需要通过以下 7 种变异方法修改数组才会触发数组对应的 wacther 进行更新。数组中如果是对象数据类型也会进行递归劫持。
说明：那如果想要改索引更新数据怎么办？
可以通过 Vue.set()来进行处理 =》 核心内部用的是 splice 方法。

```js
// 取出原型方法；
const arrayProto = Array.prototype
// 拷贝原型方法；
export const arrayMethods = Object.create(arrayProto)
// 重写数组方法；
def(arrayMethods, method, function mutator (...args) { }

ob.dep.notify()  // 调用方法时更新视图；
```

源码地址：src/core/observer/array.js 15

### Vue set 方式实现

Vue.set 方法是如何实现的？

我们给对象和数组本身都增加了 dep 属性，当给对象新增不存在的属性则触发对象依赖的 watcher 去更新，当修改数组索引时我们调用数组本身的 splice 方法去更新数组。

补充回答：
官方定义 Vue.set(object, key, value)

1. 如果是数组，调用重写的 splice 方法 （这样可以更新视图 ）
   代码：target.splice(key, 1, val)
2. 如果不是响应式的也不需要将其定义成响应式属性。
3. 如果是对象，将属性定义成响应式的 defineReactive(ob.value, key, val)
   通知视图更新 ob.dep.notify()

源码地址：src/core/observer/index.js 202

### Vue 模板编译原理

Vue 中模板编译原理？

如何将 template 转换成 render 函数(这里要注意的是我们在开发时尽量不要使用 template，因为将 template 转化成 render 方法需要在运行时进行编译操作会有性能损耗，同时引用带有 complier 包的 vue 体积也会变大) 默认.vue 文件中的 template 处理是通过 vue-loader 来进行处理的并不是通过运行时的编译。

1. 将 template 模板转换成 ast 语法树 - parserHTML
2. 对静态语法做静态标记 - markUp
3. 重新生成代码 - codeGen

补充回答：
模板引擎的实现原理就是 new Function + with 来进行实现的。
vue-loader 中处理 template 属性主要靠的是 vue-template-compiler
vue-loader

```js
// template => ast => codegen => with+function 实现生成render方法
let { ast, render } = VueTemplateCompiler.compile(`<div>{{aaa}}</div>`);
console.log(ast, render);

// 模板引擎的实现原理 with + new Function
console.log(new Function(render).tostring());
// render方法执行完毕后生成的是虚拟 dom
// with(this){return _c('div',[_s(aaa)])}
// 代码生成
```

源码设置：

```js
const ast = parse(template.trim(), options); // 将代码解析成ast语法树
if (options.optimize !== false) {
  optimize(ast, options); // 优化代码 标记静态点 标记树
}
const code = generate(ast, options); // 生成代码
```

源码地址：src/compiler/index.js

### 响应式方法

Proxy 与 Object.defineProperty 优劣对比

Proxy 的优势如下:

1. 可以直接监听对象而非属性；
2. 可以直接监听数组的变化；
3. 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；
4. 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；
5. 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；
   Object.defineProperty 的优势如下:
   兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题，而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。

### Vue3.x 响应式数据原理

Vue3.x 改用 Proxy 替代 Object.defineProperty。因为 Proxy 可以直接监听对象和数组的变化，并且有多达 13 种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。

Proxy 只会代理对象的第一层，那么 Vue3 又是怎样处理这个问题的呢？
判断当前 Reflect.get 的返回值是否为 Object，如果是则再通过 reactive 方法做代理， 这样就实现了深度观测。

监测数组的时候可能触发多次 get/set，那么如何防止触发多次呢？
我们可以判断 key 是否为当前被代理对象 target 自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行 trigger。

## 生命周期

### Vue 声明周期方法

Vue 的生命周期方法有哪些？一般在哪一步发起请求及原因

总共分为 8 个阶段：创建前/后，载入前/后，更新前/后，销毁前/后。

1. 创建前/后：

- beforeCreate 阶段：vue 实例的挂载元素 el 和数据对象 data 都为 undefined，还未初始化。说明：在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问。
- created 阶段：vue 实例的数据对象 data 有了，el 还没有。说明：可以做一些初始数据的获取，在当前阶段无法与 Dom 进行交互，如果非要想，可以通过 vm.\$nextTick 来访问 Dom。

2. 载入前/后：

- beforeMount 阶段：vue 实例的\$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点。说明：当前阶段虚拟 Dom 已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发 updated。
- mounted 阶段：vue 实例挂载完成，data.message 成功渲染。说明：在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点，使用\$refs 属性对 Dom 进行操作。

3. 更新前/后：

- beforeUpdate 阶段：响应式数据更新时调用，发生在虚拟 DOM 打补丁之前，适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。说明：可以在当前阶段进行更改数据，不会造成重渲染。
- updated 阶段：虚拟 DOM 重新渲染和打补丁之后调用，组成新的 DOM 已经更新，避免在这个钩子函数中操作数据，防止死循环。说明：当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。

4. 销毁前/后：

- beforeDestroy 阶段：实例销毁前调用，实例还可以用，this 能获取到实例，常用于销毁定时器，解绑事件。说明：在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。
- destroyed 阶段：实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁。说明：当前阶段组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。

补充回答：
第一次页面加载时会触发：beforeCreate, created, beforeMount, mounted。

- created 实例已经创建完成，因为它是最早触发的原因可以进行一些数据，资源的请求。(服务器渲染支持 created 方法)
- mounted 实例已经挂载完成，可以进行一些 DOM 操作。(接口请求)

源码地址：src/core/instance/lifecycle.js

### 声明周期钩子的实现

生命周期钩子是如何实现的？

Vue 的生命周期钩子就是回调函数而已，当创建组件实例的过程中会调用对应的钩子方法。

补充回答：
内部主要是使用 callHook 方法来调用对应的方法。核心是一个发布订阅模式，将钩子订阅好(内部采用数组的方式存储)，在对应的阶段进行发布。
源码地址：src/core/util/options.js 146 core/instance/lifecycle.js 336

### Vue 的父组件和子组件生命周期钩子执行顺序

第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子。

1. 渲染过程：
   父组件挂载完成一定是等子组件都挂载完成后，才算是父组件挂载完，所以父组件的 mounted 在子组件 mouted 之后
   父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted
2. 子组件更新过程：
   影响到父组件：父 beforeUpdate -> 子 beforeUpdate->子 updated -> 父 updted
   不影响父组件：子 beforeUpdate -> 子 updated
3. 父组件更新过程：
   影响到子组件：父 beforeUpdate -> 子 beforeUpdate->子 updated -> 父 updted
   不影响子组件：父 beforeUpdate -> 父 updated
4. 销毁过程：
   父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed
   重要：父组件等待子组件完成后，才会执行自己对应完成的钩子。

## 组件通信

### 组件的函数类型 data

Vue 中的组件的 data 为什么是一个函数？

每次使用组件时都会对组件进行实例化操作，并且调用 data 函数返回一个对象作为组件的数据源。这样可以保证多个组件间数据互不影响。
如果 data 是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间 data 不冲突，data 必须是一个函数。
源码地址：src/core/util/options 121

### 组件通信方式

Vue 组件间通信有哪几种方式？

Vue 组件间通信只要指以下 3 类通信：父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信。

1. props / \$emit 适用 父子组件通信
   这种方法是 Vue 组件的基础，相信大部分同学耳闻能详，所以此处就不举例展开介绍。

2. ref 与 $parent / $children 适用 父子组件通信
   1）ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例
   2）$parent / $children：访问父 / 子实例

3. EventBus （$emit / $on） 适用于 父子、隔代、兄弟组件通信
   这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。

4. $attrs/$listeners 适用于 隔代组件通信
   1）$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind="$attrs" 传入内部组件。通常配合 inheritAttrs 选项一起使用。
   2）$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on="$listeners" 传入内部组件

5. provide / inject 适用于 隔代组件通信
   祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。

6. Vuex 适用于 父子、隔代、兄弟组件通信
   Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。

### 组件中的 name 选项

组件中写 name 选项有哪些好处及作用？

1. 可以通过名字找到对应的组件 （ 递归组件 ）
2. 可以通过 name 属性实现缓存功能 (keep-alive)
3. 可以通过 name 来识别组件 （跨级组件通信时非常重要）

```js
Vue.extend = function () {
  if (name) {
    Sub.options.componentd[name] = Sub;
  }
};
```

源码地址：src/core/vdom/create-element.js 111

### keep-alive 原理

keep-alive 平时在哪里使用？原理是？

keep-alive 主要是组件缓存，采用的是 LRU 算法。最近最久未使用法。
常用的两个属性 include/exclude，允许组件有条件的进行缓存。
两个生命周期 activated/deactivated，用来得知当前组件是否处于活跃状态。

```js
abstract: true, // 抽象组件
props:{
    include: patternTypes,  // 要缓存的有哪些
    exclude: patternTypes, // 要排除的有哪些
    max: [String, Number] //最大缓存数量
}
if(cache[key]) { // 通过key 找到缓存，获取实例
    vnode.componentInstance = cache[key].componentInstance
    remove(keys, key) //将key删除掉
    keys.push(key) // 放到末尾
} else {
    cache[key] = vnode // 没有缓存过
    keys.push(key) //存储key
    if(this.max && keys.length > parseInt(this.max)) { // 如果超过最大缓存数
    // 删除最早缓存的
    pruneCacheEntry(cache, keys[0], keys, this._vnode)
}
}
vnode.data.keepAlive = true // 标记走了缓存
```

### Vue.mixin

Vue.mixin 的使用场景和原理？

Vue.mixin 的作用就是抽离公共的业务逻辑，原理类似“对象的继承”，当组件初始化时会调用 mergeOptions 方法进行合并，采用策略模式针对不同的属性进行合并，如果混入的数据和本身组件中的数据冲突，会采用“就近原则”以组件的数据为准。

补充回答：
mixin 中有很多缺陷“命名冲突问题”，“依赖问题”，“数据来源问题”，这里强调一下 mixin 的数据是不会被共享的。
源码地址：src/core/util/options.js

## 路由

### 路由钩子函数

Vue-router 有几种钩子函数？具体是什么及执行流程是怎样的？

路由钩子的执行流程，钩子函数种类有：全局守卫、路由守卫、组件守卫。

完整的导航解析流程

1. 导航被触发；
2. 在失活的组件里调用 beforeRouteLeave 守卫；
3. 调用全局 beforeEach 守卫；
4. 在复用组件里调用 beforeRouteUpdate 守卫；
5. 调用路由配置里的 beforeEnter 守卫；
6. 解析异步路由组件；
7. 在被激活的组件里调用 beforeRouteEnter 守卫；
8. 调用全局 beforeResolve 守卫；
9. 导航被确认；
10. 调用全局的 afterEach 钩子；
11. DOM 更新；
12. 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。

### vue-router 模式

vue-router 两种模式的区别？

vue-router 有 3 种路由模式：hash、history、abstract。

1. hash 模式：hash + hashChange
   特点：hash 虽然在 URL 中，但不被包括在 HTTP 请求中；用来指导浏览器动作，对服务端安全无用，hash 不会重加载页面。通过监听 hash（#）的变化来执行 js 代码 从而实现 页面的改变。
   核心代码：

```js
window.addEventListener(‘hashchange‘,function(){
    self.urlChange()
})
```

2. history 模式：historyApi + popState
   HTML5 推出的 history API，由 pushState()记录操作历史，监听 popstate 事件来监听到状态变更；
   因为 只要刷新 这个 url（www.ff.ff/jjkj/fdfd/fdf/fd）就会请求服务器，然而服务器上根本没有这个资源，所以就会报404，解决方案就 配置一下服务器端。
   说明：
1. hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；
1. history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；
1. abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.

## 属性作用与对比

### nextTick 原理

nextTick 在哪里使用？原理是？

nextTick 的回调是在下次 DOM 更新循环结束之后执行的延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。nextTick 主要使用了宏任务和微任务。原理就是异步方法(promise, mutationObserver, setImmediate, setTimeout)经常与事件循环一起来问。

补充回答：
vue 多次更新数据，最终会进行批处理更新。内部调用的就是 nextTick 实现了延迟更新，用户自定义的 nextTick 中的回调会被延迟到更新完成后调用，从而可以获取更新后的 DOM。
源码地址：src/core/util/next-tick.js 42

### 虚拟 DOM 的优势和劣势

Vue 为什么需要虚拟 DOM？虚拟 DOM 的优劣如何？

Virtual DOM 就是用 js 对象来描述真实 DOM，是对真实 DOM 的抽象，由于直接操作 DOM 性能低但是 js 层的操作效率高，可以将 DOM 操作转化成对象操作，最终通过 diff 算法比对差异进行更新 DOM (减少了对真实 DOM 的操作)。虚拟 DOM 不依赖真实平台环境从而也可以实现跨平台。

补充回答：
虚拟 DOM 的实现就是普通对象包含 tag、data、children 等属性对真实节点的描述。（本质上就是在 JS 和 DOM 之间的一个缓存）
Vue2 的 Virtual DOM 借鉴了开源库 snabbdom 的实现。
VirtualDOM 映射到真实 DOM 要经历 VNode 的 create、diff、patch 等阶段。
源码地址：src/core/vdom/vnode: 3

### Vue 中 key 的作用

Vue 中 key 的作用和工作原理，说说你对它的理解

key 的作用主要是为了高效的更新虚拟 DOM，其原理是 vue 在 patch 过程中通过 key 可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素，使得整个 patch 过程更加高效，减少 DOM 操作量，提高性能。

补充回答：
1、若不设置 key 还可能在列表更新时引发一些隐蔽的 bug
2、vue 中在使用相同标签名元素的过渡切换时，也会使用到 key 属性，其目的也是为了让 vue 可以区分它们，否则 vue 只会替换其内部属性而不会触发过渡效果。
源码地址：src\core\vdom\patch.js - updateChildren

### Vue 中的 diff 原理

vue 的 diff 算法是平级比较，不考虑跨级比较的情况。内部采用深度递归的方式 + 双指针的方式进行比较。

补充回答：

1. 先比较是否是相同节点
2. 相同节点比较属性，并复用老节点
3. 比较儿子节点，考虑老节点和新节点儿子的情况
4. 优化比较：头头、尾尾、头尾、尾头
5. 比对查找进行复用

Vue2 与 Vue3.x 的 diff 算法：
Vue2 的核心 Diff 算法采用了双端比较的算法，同时从新旧 children 的两端开始进行比较，借助 key 值找到可复用的节点，再进行相关操作。
Vue3.x 借鉴了 ivi 算法和 inferno 算法，该算法中还运用了动态规划的思想求解最长递归子序列。(实际的实现可以结合 Vue3.x 源码看。)
源码地址：src/core/vdom/patch.js 501

### v-if 与 v-for 的优先级

1、v-for 优先于 v-if 被解析
2、如果同时出现，每次渲染都会先执行循环再判断条件，无论如何循环都不可避免，浪费了性能
3、要避免出现这种情况，则在外层嵌套 template，在这一层进行 v-if 判断，然后在内部进行 v-for 循环
4、如果条件出现在循环内部，可通过计算属性提前过滤掉那些不需要显示的项
源码地址：compiler/codegen/index.js

### v-if 与 v-show 的区别

v-if 是真正的条件渲染，直到条件第一次变为真时，才会开始渲染。
v-show 不管初始条件是什么会渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。
注意：v-if 适用于不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。

### computed 和 watch 的区别

computed 和 watch 的区别和运用的场景？

computed： 计算属性。依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；
watch： 监听数据的变化。更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；
运用场景：

1. 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；
2. 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。

### 自定义指令的理解

如何理解自定义指令？

指令的实现原理，可以从编译原理 =>代码生成=> 指令钩子实现进行概述

1. 在生成 ast 语法树时，遇到指令会给当前元素添加 directives 属性
2. 通过 genDirectives 生成指令代码
3. 在 patch 前将指令的钩子提取到 cbs 中，在 patch 过程中调用对应的钩子。
4. 当执行指令对应钩子函数时，调用对应指令定义的方法

## v-modal 原理

V-model 的原理是什么？

v-model 本质就是一个语法糖，可以看成是 value + input 方法的语法糖。可以通过 model 属性的 prop 和 event 属性来进行自定义。原生的 v-model，会根据标签的不同生成不同的事件和属性。
v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：

1. text 和 textarea 元素使用 value 属性和 input 事件；
2. checkbox 和 radio 使用 checked 属性和 change 事件；
3. select 字段将 value 作为 prop 并将 change 作为事件。

## 常考-性能优化

你都做过哪些 Vue 的性能优化？（ 统计后的结果 ）

### 编码阶段

尽量减少 data 中的数据，data 中的数据都会增加 getter 和 setter，会收集对应的 watcher；
如果需要使用 v-for 给每项元素绑定事件时使用事件代理；
SPA 页面采用 keep-alive 缓存组件；
在更多的情况下，使用 v-if 替代 v-show；
key 保证唯一；
使用路由懒加载、异步组件；
防抖、节流；
第三方模块按需导入；
长列表滚动到可视区域动态加载；
图片懒加载；

### 用户体验：

骨架屏；
PWA；
还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启 gzip 压缩等。

### SEO 优化

预渲染；
服务端渲染 SSR；

### 打包优化

压缩代码；
Tree Shaking/Scope Hoisting；
使用 cdn 加载第三方模块；
多线程打包 happypack；
splitChunks 抽离公共文件；
sourceMap 优化；

# 小程序

## 小程序尺寸单位 rpx

尺寸单位 rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为 750rpx。如在 iPhone6 上，屏幕宽度为 375px，共有 750 个物理像素，则 750rpx = 375px = 750 物理像素，1rpx = 0.5px = 1 物理像素。

## 微信小程序获取用户信息

`wx.login(Object object)`。调用接口获取登录凭证（code）。通过凭证进而换取用户登录态信息，包括用户的唯一标识（openid）及本次登录的会话密钥（session_key）等。用户数据的加解密通讯需要依赖会话密钥完成。

`wx.getUserInfo(Object object)`。调用前需要用户授权 `scope.userInfo`。获取用户信息。

## 小程序的目录结构

微信小程序目录结构可以分为三个部分：框架全局文件、框架页面文件和工具类文件。

- 框架全局文件。一个小程序的主题部分由三个文件组成，作为全局文件，必须放在项目的根目录，分别是`app.js`小程序逻辑、`app.json`小程序公共设置和`app.wxss`小程序公共样式表。
  `app.js`文件用来定义全局数据和函数的使用，可以指定小程序的生命周期函数。`app.json`文件可以对五个功能进行设置：配置页面路径、配置窗口表现、配置标签导航、配置网络超时、配置 debug 模式。`app.wxss`文件对 CSS 样式进行了扩充和修改，定义在 app.wxss 中的样式为全局样式，作用于每一个页面。

- 框架页面文件。pages 文件夹主要存放小程序的页面文件，其中每个文件夹为一个页面，每个页面包含四个文件。小程序每个页面必须有.wxml 和.js 文件，其他两种类型的文件（.json和.wxss）可以不需要。注意：为了方便开发者减少配置项，描述页面的四个文件必须具有相同的路径与文件名。

- 工具类文件。在微信小程序框架目录里还有一个“utils”文件夹，它用来存放工具栏的 js 函数。定义这些函数后，要通过 module.exports 将定义的函数名称注册进来，在其他页面才可以使用。

## 小程序文件的作用域

在 JavaScript 文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。通过全局函数 `getApp()` 可以获取全局的应用实例，如果需要全局的数据可以在 `App()` 中设置。也可以在 `App()`中创建自定义全局函数，在 App 全局中使用 `getApp()` 获取到的全局应用实例来调用此方法。

模块只有通过 `module.exports` 或者 `exports` 才能对外暴露接口。在需要使用这些模块的文件中，使用 `require(path)` 将公共代码引入，使用引用实例进行公共方法的调用。

## 小程序常用组件

- view 视图容器。
- scroll-view 可滚动视图区域。
- swiper 滑块视图容器。
- movable-view 可移动的视图容器，在页面中可以拖拽滑动
- cover-view 覆盖在原生组件之上的文本视图。
- cover-image 覆盖在原生组件之上的图片视图。

## WXML 语法

数据绑定。WXML 中的动态数据均来自对应 Page 的 data。数据绑定使用 Mustache 语法（双大括号）将变量包起来。

列表渲染。在组件上使用 `wx: for` 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。默认数组的当前项的下标变量名默认为 index，数组当前项的变量名默认为 item。使用 wx:for-item 可以指定数组当前元素的变量名，使用 wx:for-index 可以指定数组当前下标的变量名。如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 input 中的输入内容，switch 的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。

条件渲染。在框架中，使用 `wx: if=""` 来判断是否需要渲染该代码块，也可以用 `wx: elif` 和 `wx: else` 来添加一个 else 块。因为 wx:if 是一个控制属性，需要将它添加到一个标签上。如果要一次性判断多个组件标签，可以使用一个 `<block/>` 标签将多个组件包装起来，并在上边使用 wx:if 控制属性。

模板。WXML 提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。使用 name 属性，作为模板的名字。然后在`<template/>`内定义代码片段。使用 is 属性，声明需要的使用的模板，然后将模板所需要的 data 传入

引用。WXML 提供两种文件引用方式 import 和 include。import 可以在该文件中使用目标文件定义的 template。import 有作用域的概念，即只会 import 目标文件中定义的 template，而不会 import 目标文件 import 的 template。include 可以将目标文件除了 `<template/>` `<wxs/>` 外的整个代码引入，相当于是拷贝到 include 位置。

## 事件及事件绑定

在组件中绑定一个事件处理函数。如 bindtap，当用户点击该组件的时候会在该页面对应的 Page 中找到相应的事件处理函数。在相应的 Page 定义中写上相应的事件处理函数，参数是 event。

支持使用 WXS 函数绑定事件，WXS 函数接受 2 个参数，第一个是 event，在原有的 event 的基础上加了 event.instance 对象，第二个参数是 ownerInstance，和 event.instance 一样是一个 ComponentDescriptor 对象。在组件中绑定和注册事件处理的 WXS 函数。

事件分为冒泡事件和非冒泡事件：

- 冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。
- 非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。

事件绑定的写法同组件的属性，以 key、value 的形式。

- key 以bind或catch开头，然后跟上事件的类型，如bindtap、catchtouchstart。自基础库版本 1.5.0 起，在非原生组件中，bind和catch后可以紧跟一个冒号，其含义不变，如`bind:tap`、`catch:touchstart`。
- value 是一个字符串，需要在对应的 Page 中定义同名的函数。不然当触发事件的时候会报错。

bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。

## 事件对象

如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。

`BaseEvent` 基础事件对象属性列表。`currentTarget`是代表事件绑定的当前组件，其中`id`表示当前组件的id，`dataset`表示当前组件上由`data-`开头的自定义属性组成的集合。特殊事件 canvas 中的触摸事件不可冒泡，所以没有`currentTarget`。

| 属性 | 类型 | 说明 |
|---|---|---|
| type | String | 事件类型 |
| timeStamp | Integer | 事件生成时的时间戳 |
| target | Object | 触发事件的组件的一些属性值集合 |
| currentTarget | Object | 当前组件的一些属性值集合 |
| mark | Object | 事件标记数据 |

`CustomEvent` 自定义事件对象属性列表（继承 BaseEvent）。自定义事件所携带的数据，如表单组件的提交事件会携带用户的输入，媒体的错误事件会携带错误信息。

| 属性 | 类型 | 说明 |
|---|---|---|
| detail | Object | 额外的信息 |

`TouchEvent` 触摸事件对象属性列表（继承 BaseEvent）：

| 属性 | 类型 | 说明 |
|---|---|---|
| touches | Array | 触摸事件，当前停留在屏幕中的触摸点信息的数组 |
| changedTouches | Array | 触摸事件，当前变化的触摸点信息的数组 |

## 页面跳转

- `wx.switchTab` 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面
- `wx.reLaunch` 关闭所有页面，打开到应用内的某个页面
- `wx.redirectTo` 关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。
- `wx.navigateTo` 保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。使用 wx.navigateBack 可以返回到原页面。小程序中页面栈最多十层。
- `wx.navigateBack` 关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages 获取当前的页面栈，决定需要返回几层。

通过`wx.navigateTo`推入一个新的页面，通过`getCurrentPages`获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。

| 路由方式 | 触发时机 | 页面栈表现 | 进入方式 |
|---|---|---|---|
| 初始化 | 小程序打开的第一个页面 | 新页面入栈 | 从下往上升起 |
| 打开新页面 | 调用 API wx.navigateTo | 新页面入栈 | 从右往左切入 |
| 页面重定向 | 调用 API wx.redirectTo | 当前页面出栈，新页面入栈 | 页面重新加载 |
| 页面返回 | 返回/调用 API wx.navigateBack | 页面不断出栈，直到目标返回页 | 从右往左切回 |
| Tab 切换 | 切换/调用 API wx.switchTab | 页面全部出栈，只留下新的 Tab 页面 | 页面重新加载 |
| 重加载 | 调用 API wx.reLaunch | 页面全部出栈，只留下新的页面 | 页面重新加载 |

`wx.navigateTo`和`wx.redirectTo`只能打开非 TabBar 页面，`wx.switchTab`只能打开 Tabbar 页面，`wx.reLaunch`可以打开任意页面。跳转到 TabBar 页面，路径后不能带参数（注意，Tabbar 页面初始化之后不会被销毁），调用页面路由带的参数可以在目标页面的onLoad中获取。

页面的跳转存在哪些问题呢？
- 与接口的调用一样面临url的管理问题；
- 传递参数的方式不太友好，只能拼装url；
- 参数类型单一，只支持string。

第一个问题很好解决，我们做一个集中管理，比如新建一个router/routes.js文件来实现alias：
```js
// routes.js
module.exports = {
  home: '/pages/index/index',
  uc: '/pages/user_center/index',
};

// page
const routes = require('../../router/routes.js');
Page({
  onReady() {
    wx.navigateTo({
      url: routes.uc,
    });
  },
});
```


第二个问题，实现一个navigateTo函数，接受url参数和query参数，再自动拼接成需要的跳转参数。
```js
const routes = require('../../router/routes.js');

function navigateTo({ url, query }) {
  const queryStr = Object.keys(query).map(k => `${k}=${query[k]}`).join('&');
  wx.navigateTo({
    url: `${url}?${queryStr}`,
  });
}

Page({
  onReady() {
    const userId = '123456';
    navigateTo({
      url: routes.uc,
      query: {
        userId,
      },
    });
  },
});
```

第三个问题，参数保真。把要传的数据转成json字符串（JSON.stringify），然后在下个页面把它转回json数据（JSON.parse）。
```js
// routes.js
function navigateTo({ url, data }) {
  const dataStr = encodeURIComponent(JSON.stringify(data));
  wx.navigateTo({
    url: `${url}?encodedData=${dataStr}`,
  });
}

function extract(options) {
  return JSON.parse(decodeURIComponent(options.encodedData));
}

module.exports = {
  routes,
  navigateTo,
  extract,
};

// page home
const router = require('../../router/index.js');
Page({
  onLoad(options) {
    router.navigateTo({
      url: router.routes.uc,
      data: {
        isActive: true,
      },
    });
  },
});

// page uc
const router = require('../../router/index.js');
Page({
  onLoad(options) {
    const json = router.extract(options);
    console.log(json.isActive); // => true
    console.log(typeof json.isActive); // => "boolean"
    console.log(json.isActive === true); // => true
  },
});
```

## 设置 tabBar

tabBar 就是微信小程序下方的导航栏。

小程序开发过程中，当接受新的消息时，需要给出右上角的红点的提示，只需要调用函数`wx.showTabBarRedDot(Object object)`。

在微信小程序开发过程中，我们有时候需要界面全屏显示，比如调用地图API时，这样才能给用户更好的人机体验，这是后就需要动态的显示和隐藏微信小程序中的tabbar导航栏，关于显示tabbar，我们只需要调用函数：`wx.showTabBar(Object object)`。

在微信小程序开发过程中，我们有时候需要设置更为个性的tabbar，或者由于主题颜色的需求，我们需要保持与主题颜色一样，就需要调整tabbar的整体样式，我们只需要调用函数：`wx.setTabBarStyle(Object object)`。

当有好友发送消息过来时，tabbar右上角会有消息文本提示，这时只需要调用函数：`wx.setTabBarBadge(Object object)`。

## 页面生命周期

在app.js文件中，定义了一些生命周期方法：

- `onLaunch` 监听小程序初始化 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）
- `onShow` 监听小程序显示 当小程序启动，或从后台进入前台显示，会触发 onShow
- `onHide` 监听小程序隐藏 当小程序从前台进入后台，会触发 onHide
- `onError` 错误监听函数 当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息
- 其他 开发者可以添加任意的函数或数据到 Object 参数中，用 this 可以访问

在page页面中定义的生命周期方法：

- `onLoad` 监听页面加载
- `onReady` 监听页面初次渲染完成
- `onShow` 监听页面显示
- `onHide` 监听页面隐藏
- `onUnload` 监听页面卸载

## 转发分享

页面内发起转发。通过给 button 组件设置属性 `open-type="share"`，可以在用户点击按钮后触发 `Page.onShareAppMessage` 事件，如果当前页面没有定义此事件，则点击后无效果。

`onShareAppMessage(Object object)` 监听用户点击页面内转发按钮（button 组件 `open-type="share"`）或右上角菜单“转发”按钮的行为，并自定义转发内容。注意：只有定义了此事件处理函数，右上角菜单才会显示“转发”按钮。

## request 请求后台接口



## http-promise 封装



## webview



## 获取用户收货地址

`wx.chooseAddress(Object object)`。获取用户收货地址。调起用户编辑收货地址原生界面，并在编辑完成后返回用户选择的地址。

参数 `Object object`

| 属性 | 类型 | 必填 | 说明 |
|---|---|---|---|
| success | function | 否 | 接口调用成功的回调函数 |
| fail | function | 否 | 接口调用失败的回调函数 |
| complete | function | 否 | 接口调用结束的回调函数（调用成功、失败都会执行） |

object.success 回调函数的参数 `Object res`

| 属性 | 类型 | 说明 |  |
|---|---|---|---|
| userName | string | 收货人姓名 |  |
| postalCode | string | 邮编 |  |
| provinceName | string | 国标收货地址第一级地址 |  |
| cityName | string | 国标收货地址第二级地址 |  |
| countyName | string | 国标收货地址第三级地址 |  |
| detailInfo | string | 详细收货地址信息 |  |
| nationalCode | string | 收货地址国家码 |  |
| telNumber | string | 收货人手机号码 |  |
| errMsg | string | 错误信息 |  |

## 获取地理位置

`wx.getLocation(Object object)`。获取当前的地理位置、速度。当用户离开小程序后，此接口无法调用。调用前需要 用户授权 `scope.userLocation`。

```js
wx.getLocation({
 type: 'wgs84',
 success (res) {
   const latitude = res.latitude
   const longitude = res.longitude
   const speed = res.speed
   const accuracy = res.accuracy
 }
})
```

## 自定义组件

类似于页面，一个自定义组件由 json wxml wxss js 4个文件组成。要编写一个自定义组件，首先需要在 json 文件中进行自定义组件声明（将 component 字段设为 true 可这一组文件设为自定义组件）。

注意：在组件wxss中不应使用ID选择器、属性选择器和标签名选择器。

在自定义组件的 js 文件中，需要使用 `Component()` 来注册组件，并提供组件的属性定义、内部数据和自定义方法。

组件的属性值和内部数据将被用于组件 wxml 的渲染，其中，属性值是可由组件外部传入的。

```js
Component({
  properties: {
    // 这里定义了innerText属性，属性值可以在组件使用时指定
    innerText: {
      type: String,
      value: 'default value',
    }
  },
  data: {
    // 这里是一些组件内部数据
    someData: {}
  },
  methods: {
    // 这里是一个自定义方法
    customMethod: function(){}
  }
})
```

使用已注册的自定义组件前，首先要在页面的 json 文件中进行引用声明。此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径。这样，在页面的 wxml 中就可以像使用基础组件一样使用自定义组件。节点名即自定义组件的标签名，节点属性即传递给组件的属性值。

# 浏览器

## 主流浏览器的内核分别是什么

- IE浏览器内核：**Trident**内核，也是俗称的IE内核；
- Chrome浏览器内核：统称为Chromium内核或Chrome内核，以前是Webkit内核，现在是**Blink**内核；
- Firefox浏览器内核：**Gecko**内核，俗称Firefox内核；
- Safari浏览器内核：**Webkit**内核；
- Opera浏览器内核：最初是自己的Presto内核，后来是Webkit，现在是**Blink**内核；
- 360浏览器、猎豹浏览器内核：IE+Chrome双内核；
- 搜狗、遨游、QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）；
- 百度浏览器、世界之窗内核：IE内核；
- 2345浏览器内核：以前是IE内核，现在也是IE+Chrome双内核；

## URL到渲染页面过程

一个页面从输入URL到页面加载显示完成，这个过程都发生什么？

1. 首先，在浏览器地址栏中输入url
2. 浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。
3. 在发送http请求前，需要域名解析（DNS解析），解析获取相应的IP地址。
4. 浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。
5. 握手成功后，浏览器向服务器发送http请求，请求数据包。
6. 服务器处理收到的请求，将数据返回至浏览器
7. 浏览器收到HTTP响应
8. 读取页面内容，浏览器渲染，解析html源码
9. 生成Dom树、解析css样式、js交互
10. 客户端和服务器交互
11. ajax查询

其中，步骤2的具体过程是：

- 浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；
- 操作系统缓存：如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统，获取操作系统的记录（保存最近的DNS查询缓存）；
- 路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；
- ISP缓存：若上述均失败，继续向ISP搜索。



