> 根据网上的面试题整理出来的

# HTML

## Doctype 作用，严格模式与混杂模式.

`<!DOCTYPE>` 声明必须是 HTML 文档的第一行，位于 `<html>` 标签之前。<!DOCTYPE> 声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。HTML5 不基于 SGML，所以不需要引用 DTD。

严格模式：又称标准模式，是指浏览器按照 W3C 标准解析代码。混杂模式：又称怪异模式或兼容模式，是指浏览器用自己的方式解析代码。浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD 直接相关。DOCTYPE 不存在或格式不正确会导致文档以混杂模式呈现。

## HTML5 新特性

- 语义化标签（header、section、article、aside、nav、footer）
- 增强型表单：新增属性（例如 require、placeholder）、新增元素（datalist、output）
- Canvas 画布，`getContext()` 方法可返回一个对象，该对象提供了用于在画布上绘图的方法和属性。
- 多媒体相关 API。音频（audio）和视频（video）。
- History API。通过脚本管理浏览器的历史记录。
- 本地储存。sessionStorage 和 localStorage。
- 离线应用程序。cache manifest 文件
- 文件 API。FileReader API。
- 通信 API。跨文档消息传输功能、使用 WebSockets API 来通过 socket 端口传递数据的功能和通过 Server-Sent Eventsource API 将服务器端事件主动推动到客户端的功能。
- Web Workers 处理线程。web worker 是运行在后台的 JavaScript，不会影响页面的性能。
- 获取地理位置信息。获取用户地理位置信息的 Geolocation API。
- 拖放 API 和通知 API。

### WebSocket

它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。

WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。readyState 属性返回实例对象的当前状态，共有四种。实例对象的 onopen 属性，用于指定连接成功后的回调函数。实例对象的 onclose 属性，用于指定连接关闭后的回调函数。实例对象的 onmessage 属性，用于指定收到服务器数据后的回调函数。实例对象的 `send()` 方法用于向服务器发送数据。

### Web Workers

Javascript 是运行在单线程环境中，也就是说无法同时运行多个脚本。但是，如果将这段代码交给 Web Worker 去运行的话，那么情况就不一样了：浏览器会在后台启动一个独立的 worker 线程来专门负责代码的运行，因此，页面在这段 Javascript 代码运行期间依然可以响应用户的其他操作。

Web Worker 规范中定义了两类工作线程，分别是专用线程 Dedicated Worker 和共享线程 Shared Worker，其中，Dedicated Worker 只能为一个页面所使用，而 Shared Worker 则可以被多个页面所共享。

只需调用 `Worker()` 构造函数并传入一个要在 worker 线程内运行的脚本的 URI，即可创建一个新的 worker。Worker 与其主页面之间的通信是通过 onmessage 事件和 `postMessage()` 方法实现的。

## HTML5 兼容性

IE9+以及谷歌、火狐、苹果等主流浏览器对大部分 HTML5 属性均为支持状态。IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签。浏览器支持新标签后，还需要添加标签默认的样式（当然最好的方式是直接使用成熟的框架、使用最多的是 html5shim 框架）。

```html
<!--[if lt IE 9]>
  <script>
    src = "http://html5shim.googlecode.com/svn/trunk/html5.js";
  </script>
<![endif]-->
```

## HTML5 标签变化

新增的标签

- 结构标签
  - article 一篇文章
  - header 一个页面或一个区域的头部
  - nav 导航链接
  - section 一个区域
  - aside 页面内容部分的侧边栏
  - hgroup 文件中一个区域的相关信息
  - figure 一组媒体内容以及它们的标题
  - figcaption figure 元素的标题
  - footer 一个页面或一个区域的底部
  - dialog 一个对话框

- 多媒体标签
  - videa 一个视频
  - audio 音频内容
  - source 媒体资源
  - canvas 图片
  - embed 外部的可交互的内容或插件，例如 flash

- Web 应用标签
  - meter 状态标签（实时状态显示：气压、气温）
  - progress 状态标签（任务过程：安装、加载）
  - menu 命令列表
  - menuitem menu 命令列表标签
  - command menu 标记定义一个命令按钮

- 其它标签
  - ruby 注释或音标
  - rp 不支持 ruby 元素的显示内容
  - rt 对 ruby 的注释内容文本
  - mark 有标记的文本（黄色选中状态）
  - output 一些输入类型
  - keygen 表单里一个生成的键值
  - time 一个日期/时间

移除的元素有纯表现的元素（basefont/big/center/font/s/strike/tt/u）、对可用性产生负面影响的元素（frame/frameset/noframes）、产生混淆的元素（acronym/applet/isindex/dir）。

重定义标签。显示不变，只是表达的含义进行了重新定义的标签。

- b 代表内联文本，通常是粗体，没有传递表示重要的意思
- i 代表内联文本，通常是斜体，没有传递表示重要的意思
- dd 可以同 details 与 figure 一同使用，定义包含文本，dialog 也可用
- dt 可以同 details 与 figure 一同使用，汇总细节，dialog 也可用
- hr 表示主题结束，而不是水平线，虽然显示相同
- menu 重新定义用户界面的菜单，配合 commond 或者 menuitem 使用
- small 表示小字体，例如打印注释或者法律条款
- strong 表示重要性而不是强调符号

## 如何区分 HTML 和 HTML5?

HTML5 文档类型声明：`<!doctype html>`。DOCTYPE 声明的方式是区分 HTML 和 HTML5 标志的一个重要因素，此外，还可以根据新增的结构、功能元素来加以区分。

## 语义化的理解

HTML 语义化就是让页面的内容结构化，便于阅读和维护，便于浏览器、搜索引擎解析，利于 SEO。

## HTML5 的 webstorage 和 cookies

webstorage 是本地存储，存储在客户端，包括 localStorage 和 sessionStorage。

localStorage 生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。

sessionStorage 仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。源生接口可以接受，亦可再次封装来对Object和Array有更好的支持。

cookie 在浏览器和服务器间来回传递。生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。存放数据大小为4K左右 。有个数限制（各浏览器不同），一般不能超过20个。与服务器端通信：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题。

## iframe 缺点

iframe 会阻塞主页面的 Onload 事件；iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。

使用 iframe 之前需要考虑这两个缺点。如果需要使用 iframe，最好是通过 javascript 动态给 iframe 添加 src 属性值，这样可以可以绕开以上两个问题。

# CSS

## 行内元素. 块级元素

一个行内元素只占据它对应标签的边框所包含的空间。

行内元素有：a b span img input select strong（强调的语气）

块级元素占据其父元素（容器）的整个空间，因此创建了一个“块”。通常浏览器会在块级元素前后另起一个新行。

块级元素有：div ul ol li dl dt dd h1 h2 h3 h4 p

## CSS 选择符

标签选择器、类选择器、id 选择器、后代选择器、子选择器、相邻选择器、通配符选择器、属性选择器。

伪元素（::first-letter/::first-line/::before/::after）。

伪类（:link/:visited/:hover/:active）、结构化伪类和表单伪类。

## CSS3 新增伪类

p:first-of-type 选择属于其父元素的首个 `<p>` 元素的每个 `<p>` 元素。

p:last-of-type 选择属于其父元素的最后 `<p>` 元素的每个 `<p>` 元素。

p:only-of-type 选择属于其父元素唯一的 `<p>` 元素的每个 `<p>` 元素。

p:only-child 选择属于其父元素的唯一子元素的每个 `<p>` 元素。

p:nth-child(2) 选择属于其父元素的第二个子元素的每个 `<p>` 元素。

:enabled :disabled 控制表单控件的禁用状态。

:checked 单选框或复选框被选中。

## CSS3 新特性

视觉表现更进步（圆角、阴影和渐变、transform 变换、filter 滤镜和混合模式、animation 动画）、布局更为丰富（CSS3 媒介查询、弹性盒子布局、格珊布局）。

- CSS3 边框（Borders）。可以创建圆角边框，添加阴影框，并作为边界的形象而不使用设计程序。

`border-image`	设置所有边框图像的速记属性。
`border-radius`	一个用于设置所有四个边框- *-半径属性的速记属性
`box-shadow`	附加一个或多个下拉框的阴影

- CSS3 背景。CSS3中包含几个新的背景属性，提供更大背景元素控制。

`background-clip`	规定背景的绘制区域。
`background-origin`	规定背景图片的定位区域。
`background-size`	规定背景图片的尺寸。

- CSS3 渐变。CSS3 定义了两种类型的渐变（gradients）。
  - 线性渐变（Linear Gradients）- 向下/向上/向左/向右/对角方向`background: linear-gradient(direction, color-stop1, color-stop2, ...)`
  - 径向渐变（Radial Gradients）- 由它们的中心定义`background: radial-gradient(center, shape size, start-color, ..., last-color);`

- CSS3 文本效果

`hanging-punctuation`	规定标点字符是否位于线框之外。
`punctuation-trim`	规定是否对标点字符进行修剪。
`text-align-last`	设置如何对齐最后一行或紧挨着强制换行符之前的行。
`text-emphasis`	向元素的文本应用重点标记以及重点标记的前景色。
`text-justify`	规定当 text-align 设置为 "justify" 时所使用的对齐方法。
`text-outline`	规定文本的轮廓。
`text-overflow`	规定当文本溢出包含元素时发生的事情。
`text-shadow`	向文本添加阴影。
`text-wrap`	规定文本的换行规则。
`word-break`	规定非中日韩文本的换行规则。
`word-wrap`	允许对长的不可分割的单词进行分割并换行到下一行。

- CSS3 字体

以前 CSS3 的版本，网页设计师不得不使用用户计算机上已经安装的字体。使用 CSS3，网页设计师可以使用他/她喜欢的任何字体。当你发现您要使用的字体文件时，只需简单的将字体文件包含在网站中，它会自动下载给需要的用户。您所选择的字体在新的 CSS3 版本有关于`@font-face`规则描述。您"自己的"的字体是在 CSS3 @font-face 规则中定义的。

- CSS3 转换和变形

  - 2D新转换属性

  `transform`	适用于2D或3D转换的元素

  `transform-origin`	允许您更改转化元素位置

  - 2D 转换方法

  `matrix(n,n,n,n,n,n)`	定义 2D 转换，使用六个值的矩阵。  
  `translate(x,y)`	定义 2D 转换，沿着 X 和 Y 轴移动元素。  
  `translateX(n)`	定义 2D 转换，沿着 X 轴移动元素。  
  `translateY(n)`	定义 2D 转换，沿着 Y 轴移动元素。  
  `scale(x,y)`	定义 2D 缩放转换，改变元素的宽度和高度。  
  `scaleX(n)`	定义 2D 缩放转换，改变元素的宽度。  
  `scaleY(n)`	定义 2D 缩放转换，改变元素的高度。  
  `rotate(angle)`	定义 2D 旋转，在参数中规定角度。  
  `skew(x-angle,y-angle)`	定义 2D 倾斜转换，沿着 X 和 Y 轴。  
  `skewX(angle)`	定义 2D 倾斜转换，沿着 X 轴。  
  `skewY(angle)`	定义 2D 倾斜转换，沿着 Y 轴。  

  - 3D转换属性

  `transform`	向元素应用 2D 或 3D 转换。

  `transform-origin`	允许你改变被转换元素的位置。

  `transform-style`	规定被嵌套元素如何在 3D 空间中显示。

  `perspective`	规定 3D 元素的透视效果。

  `perspective-origin`	规定 3D 元素的底部位置。

  `backface-visibility`	定义元素在不面对屏幕时是否可见。


  - 3D 转换方法

  `matrix3d(n,n,n,n,n,n, n,n,n,n,n,n,n,n,n,n)`	定义 3D 转换，使用 16 个值的 4x4 矩阵。
  `translate3d(x,y,z)`	定义 3D 转化。
  `translateX(x)`	定义 3D 转化，仅使用用于 X 轴的值。
  `translateY(y)`	定义 3D 转化，仅使用用于 Y 轴的值。
  `translateZ(z)`	定义 3D 转化，仅使用用于 Z 轴的值。
  `scale3d(x,y,z)`	定义 3D 缩放转换。
  `scaleX(x)`	定义 3D 缩放转换，通过给定一个 X 轴的值。
  `scaleY(y)`	定义 3D 缩放转换，通过给定一个 Y 轴的值。
  `scaleZ(z)`	定义 3D 缩放转换，通过给定一个 Z 轴的值。
  `rotate3d(x,y,z,angle)`	定义 3D 旋转。
  `rotateX(angle)`	定义沿 X 轴的 3D 旋转。
  `rotateY(angle)`	定义沿 Y 轴的 3D 旋转。
  `rotateZ(angle)`	定义沿 Z 轴的 3D 旋转。
  `perspective(n)`	定义 3D 转换元素的透视视图。

- CSS3 过渡

`transition`	简写属性，用于在一个属性中设置四个过渡属性。

`transition-property`	规定应用过渡的 CSS 属性的名称。

`transition-duration`	定义过渡效果花费的时间。默认是 0。

`transition-timing-function`	规定过渡效果的时间曲线。默认是 "ease"。

`transition-delay`	规定过渡效果何时开始。默认是 0。


- CSS3 动画

要创建CSS3动画，你需要了解@keyframes规则。@keyframes规则是创建动画。 @keyframes规则内指定一个CSS样式和动画将逐步从目前的样式更改为新的样式。

`@keyframes`	规定动画。
`animation`	所有动画属性的简写属性，除了 animation-play-state 属性。
`animation-name`	规定 @keyframes 动画的名称。
`animation-duration`	规定动画完成一个周期所花费的秒或毫秒,默认是 0。
`animation-delay`	规定动画何时开始,默认是 0。
`animation-iteration-count`	规定动画被播放的次数,默认是 1。
`animation-direction`	规定动画是否在下一周期逆向地播放,默认是 "normal"。
`animation-play-state`	规定动画是否正在运行或暂停,默认是 "running"。

- CSS3 多列

`column-count`	指定元素应该被分割的列数。

`column-fill`	指定如何填充列。

`column-gap`	指定列与列之间的间隙。

`column-rule`	所有 column-rule-* 属性的简写。

`column-rule-color`	指定两列间边框的颜色。

`column-rule-style`	指定两列间边框的样式。

`column-rule-width`	指定两列间边框的厚度。

`column-span`	指定元素要跨越多少列。

`column-width`	指定列的宽度。

`columns`	设置 column-width 和 column-count 的简写。

- CSS3 盒模型

在 CSS3 中, 增加了一些新的用户界面特性来调整元素尺寸，框尺寸和外边框，主要包括以下用户界面属性：

resize属性指定一个元素是否应该由用户去调整大小。

`resize：none | both | horizontal | vertical | inherit`

box-sizing 属性允许您以确切的方式定义适应某个区域的具体内容。

`box-sizing: content-box | border-box | inherit`

outline-offset 属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。

`outline:outline-color outline-style outline-width outine-offset`

- CSS3 flex box

CSS3 弹性盒（Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。

引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。

`display`	指定 HTML 元素盒子类型。  
`flex-flow`	flex-direction 和 flex-wrap 的简写。  
`flex-direction`	指定了弹性容器中子元素的排列方式。  
`flex-wrap`	设置弹性盒子的子元素超出父容器时是否换行。  
`justify-content`	设置弹性盒子元素在主轴（横轴）方向上的对齐方式。  
`align-items`	设置弹性盒子元素在侧轴（纵轴）方向上的对齐方式。  
`align-content`	修改 flex-wrap 属性的行为，类似 align-items, 但不是设置子元素对齐，而是设置行对齐。  
`order`	设置弹性盒子的子元素排列顺序。  
`align-self`	在弹性子元素上使用，覆盖容器的 align-items 属性。  
`flex`	设置弹性盒子的子元素如何分配空间，是 flex-grow、flex-shrink 和 flex-basis 属性的简写属性。  
`flex-grow`	一个数字，规定项目将相对于其他灵活的项目进行扩展的量。  
`flex-shrink`	一个数字，规定项目将相对于其他灵活的项目进行收缩的量。  
`flex-basis`	项目的长度，合法值："auto"、"inherit" 或一个后跟 "%"、"px"、"em" 或任何其他长度单位的数字。  

- CSS3 多媒体查询

从 CSS 版本 2 开始，就可以通过媒体类型在 CSS 中获得媒体支持。如果您曾经使用过打印样式表，那么您可能已经使用过媒体类型。

```JavaScript
<link rel="stylesheet" type="text/css" href="site.css" media="screen" />
<link rel="stylesheet" type="text/css" href="print.css" media="print" />
```

媒体查询规则。`@media all and (min-width: 800px) { ... }`

@media all 是媒体类型，也就是说，将此 CSS 应用于所有媒体类型。(min-width:800px) 是包含媒体查询的表达式，如果浏览器的最小宽度为 800 像素，则会告诉浏览器只运用下列 CSS。

```css
@media (min-width:800px) and (max-width:1200px) and (orientation:portrait) { ... }

@media (min-width:800px) or (orientation:portrait) { ... }

@media (not min-width:800px) { ... }
```

## 清除浮动

浮动元素脱离了文档流，其父元素也看不到它了，因而也不会包围它。浮动产生的副作用有：父元素背景不能显示、边框不能撑开、margin/padding 设置值不能正确显示。

1. 为父元素添加 `overflow: hidden`或 auto ，兼容 IE 则使用 `zoom: 1`
2. 同时浮动父元素或设置父元素固定高度
3. 添加非浮动的清除元素或清除伪类

## position 属性

1. 静态定位`static`。默认值，没有定位，元素出现在正常的流中（忽略四个定位属性或者 z-index 声明）。
2. 相对定位`relative`。相对于其正常位置进行定位。可以使用四个定位属性移动位置。
3. 绝对定位`absolute`。相对于离它最近的 position 不为 static 的祖先元素定位。元素的位置通过 "left", "top", "right" 以及 "bottom" 这四个定位属性进行规定。
4. 固定定位`fixed`。相对于浏览器窗口或手持设备的屏幕进行定位。根元素（很多场景下可以看成是`<html>`）被称为“初始包含块”。元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。
5. 继承值`inherit`。规定应该从父元素继承 position 属性的值。

## link 和 @import 的区别。

从属关系区别。`@import` 是 CSS 提供的语法规则，只有导入样式表的作用；`link` 是 HTML 提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。

加载顺序区别。加载页面时，link 标签引入的 CSS 被同时加载；`@import` 引入的 CSS 将在页面加载完毕后被加载。

兼容性区别。`@import` 是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link 标签作为 HTML 元素，不存在兼容性问题。

DOM 可控性区别。可以通过 JS 操作 DOM ，插入 `link` 标签来改变样式；由于 DOM 方法是基于文档的，无法使用`@import` 的方式插入样式。

权重区别。link 引入的样式权重大于`@import` 引入的样式。

# JavaScript

## 前端优化

加载页面和静态资源

- 静态资源的压缩合并，减小资源的大小，减少http请求
- 静态资源缓存，
- 使用CDN让资源加载更快
- 使用SSR（服务端渲染）后端渲染，数据直接输出到HTML中

页面渲染优化

- CSS放前面，JS放后面
- 懒加载（图片懒加载，下拉加载更多）
- 减少DOM查询，对DOM查询做缓存
- 减少DOM操作，多个DOM操作尽量合并在一起执行
- 事件节流
- 尽早执行操作（如使用DOMCotentLoaded）

## typeof 返回数据类型

Undefined、Boolean、Number、String、Function、Object、Symbol

## jsonp 原理

要理解跨域，先要了解一下“同源策略”。所谓同源是指，域名，协议，端口相同。所谓“同源策略“，简单的说就是基于安全考虑，当前域不能访问其他域的东西。

JSONP 实现跨域请求的原理简单的说，就是动态创建`<script>`标签，然后利用`<script>`的 src 不受同源策略约束来跨域获取数据。Ajax 是页面无刷新请求数据操作。

## 异步 ajax 优缺点

优点：不会造成 UI 卡死，用户体验好；局部刷新页面，省流量。

缺点：后退按钮无效，多个请求回调时间不确定，对搜索引擎不友好、数据安全。

## src 与 href

href 表示超文本引用（hypertext reference），在 `<link>` 和 `<a>` 等元素上使用。src 表示来源地址，是指外部资源的位置，指向的内容将会嵌入到文档中当前标签 所在的位置，在 img、script、iframe 等元素上。

## 前端闭包

使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。

闭包有三个特性：

1. 函数嵌套函数
2. 函数内部可以引用外部的参数和变量
3. 参数和变量不会被垃圾回收机制回收

## js 垃圾回收方法

标记清除（mark and sweep）

这是 JavaScript 最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。

垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了。

引用计数(reference counting)

在低版本 IE 中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加 1，如果该变量的值变成了另外一个，则这个值得引用次数减 1，当这个值的引用次数变为 0 的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的空间。

在 IE 中虽然 JavaScript 对象通过标记清除的方式进行垃圾回收，但 BOM 与 DOM 对象却是通过引用计数回收垃圾的， 也就是说只要涉及 BOM 及 DOM 就会出现循环引用问题。

## 创建 Ajax 的步骤

1. 创建 XMLHttpRequest 对象，也就是创建一个异步调用对象；
2. 创建一个新的 HTTP 请求，并指定改 HTTP 请求的方法、URL 以及验证信息；
3. 设置响应 HTTP 状态变化的函数；
4. 发送 HTTP 请求；
5. 获取异步调用返回的数据；
6. 使用 JavaScript 和 DOM 实现局部刷新；

```js
var xhr;
if (window.XMLHttpRequest) { // 标准浏览器
  xhr = new XMLHttpRequest();
}else { // IE浏览器
  xhr = ActiveXObject('Microsoft.XMLHTTP');
}

xhr.open('get', 'api/ajax.php', true); // 创建HTTP连接

xhr.oreadystatechange = function () { // 响应HTTP状态变化
  if (xhr.readyState == 4) {
    if (xhr.status == 200) {
      var data = xhr.responseText;
    }
  }
}

xhr.send(); // 向服务器发送请求
```

## GET 请求和 POST 请求。

1. 使用 Get 请求时,参数在 URL 中显示,而使用 Post 请求,则不会显示出来；
2. Post 传输的数据量大，可以达到 2M，而 Get 方法由于受到 URL 长度的限制,只能传递大约 1024 字节.
3. Get 请求请求需注意缓存问题，Post 请求不需担心这个问题；
4. Post 请求必须设置 Content-Type 值为 application/x-form-www-urlencoded；
5. 发送请求时,因为 Get 请求的参数都在 url 里,所以 send 函数发送的参数为 null,而 Post 请求在使用 send 方法时,却需赋予其参数；
6. GET 方式请求的数据会被浏览器缓存起来，因此其他人就可以从浏览器的历史记录中读取到这些数据，例如账号和密码等。在某种情况下，GET 方式会带来严重的安全问题。而 POST 方式相对来说就可以避免这些问题。

## TypeScript 语法

简单笼统地说，TypeScript 是 JavaScript 的超集，是微软开发的一种脚本语言。和 JavaScript 一样，是现在项目开发中热门的脚本语言。

TypeScript 是一种强类型语言，可编译成 JavaScript，包含了 JavaScript 的所有元素，可以载入 JavaScript 代码运行，扩展了 JavaScript 的语法。相比 JavaScript，TypeScript 是真面向对象，增加了静态类型，类，模块，接口和类型注解。

TypeScript 的编译器很智能，会进行冲突检测，举个例子，一个 enum 的数据，你初始化一个数据，再用一个 switch 语句，编译器会判定其他选项为无效的，会编译错误，直接指出错误原因，这在 JavaScript 是不会指出错误的。

## Web 客户端

主流浏览器的内核。IE 浏览器是 Trident，Mozilla 浏览器是 Gecko，Safari 浏览器是 Webkit，Chrome 浏览器是 Blink，Opera 浏览器现在也是 Blink。

同源策略是对 XHR 的一个主要约束，它为通信设置了“相同的域、相同的端口、相同的协议”这一限制。试图访问上述限制之外的资源，都会引发安全错误，除非采用被认可的跨域解决方案。这个解决方案叫做 CORS（ Cross-Origin Resource Sharing，跨源资源共享）， IE8 通过 XDomainRequest 对象支持 CORS，其他浏览器通过 XHR 对象原生支持 CORS。图像 Ping 和 JSONP 是另外两种跨域通信的技术，但不如 CORS 稳妥。

## 遍历

1. 普通的for循环。最简单的一种，正常用的话也不会出现什么问题，想中断也可以中断，性能上也还可以。

```js
var arr = [1, 2, 3]
for(var i = 0; i < arr.length; i++) { // 这里的i是代表数组的下标
    console.log(i); // 0, 1, 2
};
```

2. `for in`遍历。这个更多是用来遍历对象，很少用来遍历数组，不过 item 对应与数组的 key 值，建议不要用该方法来遍历数组，因为它的效率是最低的。遍历对象时，可以遍历到myObject的原型方法method,如果不想遍历原型方法和属性的话，可以在循环内部判断一下，hasOwnPropery方法可以判断某属性是否是该对象的实例属性

```js
// 遍历对象
for (var key in myObject) {
　　if(myObject.hasOwnProperty(key)){
　　　　console.log(key);
　　}
}

// 遍历数组
var arr = [1, 2, 3]
for(var item in arr) { // item遍历数组时为数组的下标，遍历对象时为对象的key值
    console.log(item); // 0, 1, 2
};
```

`for in`遍历数组的毛病
- index索引为字符串型数字，不能直接进行几何运算
- 遍历顺序有可能不是按照实际数组的内部顺序
- 使用`for in`会遍历数组所有的可枚举属性，包括原型。例如原型方法 method 和 name 属性

3. ES5具有遍历数组方法。但是使用 foreach 遍历数组的话，使用 break 不能中断循环，使用 return 也不能返回到外层函数。

方法有`forEach`、`map`、`filter`、`some`、`every`、`reduce`、`reduceRight`等，只不过他们的返回结果不一样。

4. ES6中的`for of`。这个遍历的是数组元素（键值），不包括数组的原型属性 method 和索引 name 。`for of`适用遍历数、数组对象、字符串、`map`、`set`等拥有迭代器对象的集合.但是不能遍历对象,因为没有迭代器对象。与`forEach()`不同的是，它可以正确响应break、continue和return语句。

```js
Array.prototype.method = function () {　　
  console.log(this.length);
}
var myArray = [1, 2, 4, 5, 6, 7]
myArray.name = "数组";
// 1 2 4 5 6 7
for (var value of myArray) {
  console.log(value);
}
```

同样可以通过 ES5 的`Object.keys(myObject)`获取对象的实例属性组成的数组，不包括原型方法和属性。ES2017 引入了跟`Object.keys`配套的`Object.values`和`Object.entries`，作为遍历一个对象的补充手段，供`for of`循环使用。

```js
// Object.keys()
for (var key of Object.keys(someObject)) {
  console.log(key + ": " + someObject[key]);
}

// 遍历map对象时适合用解构
for (var [key, value] of phoneBookMap) {
   console.log(key + "'s phone number is: " + value);
}
```

`for of`的步骤。`for of`循环首先调用集合的`Symbol.iterator`方法，紧接着返回一个新的迭代器对象。迭代器对象可以是任意具有`.next()`方法的对象；`for of`循环将重复调用这个方法，每次循环调用一次。举个例子，这段代码是能想出来的最简单的迭代器：

```js
var zeroesForeverIterator = {
 [Symbol.iterator]: function () {
   return this;
  },
  next: function () {
  return {done: false, value: 0};
 }
};
```

# Vue

## vue 生命周期

`beforeCreate`。组建实例化刚被创建，该过程在组件属性计算之前，在这个时候 data 和 el，以及自定义的 message 都是 undefined

`created`。组件实例化创建完成，属性已绑定，但是 dom 还未生成，\$el 属性还不存在,在这个时候 data 和 message 已经初始化了

`beforeMount`。模板编译/挂载之前 \$el 和 data、message 都被初始化了

`mounted`。模板编译/挂载之后 \$el 和 data、message 都被初始化了

`beforeUpdate`。组件更新之前

`updated`。组件更新之后

`activated`。keep-alive,组件激活时被调用

`deactivated`。keep-alive,组件移除时被调用

`beforeDestory`。组件销毁前被调用

`destory`。组件销毁后被调用

## Vue 工作原理

数据响应原理。

当把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。

这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在属性被访问和修改时通知变更。

每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据属性记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。

Virtual Dom。

为什么使用 virtual-dom？因为直接频繁地操作 dom 会有很高的性能消耗。

虚拟 dom，使用 JS 对象模拟 dom 进行操作。Vnode 是虚拟 DOM 节点类，其实例 vnode 是一个包含着渲染 DOM 节点所需要的一切信息的普通对象。`render()` 方法根据当前 vm 的数据生成 vnode。

简单来说，新老 vnode 基本属性相同时，进行 diff（过程较复杂）；新老 vnode 基本属性不同时，删除老的 dom，新建新的真实 dom。

更新真实 dom 流程与 diff 过程交叉，利用了源码中重要的 patch 函数，生成真实 dom 更新视图。

## 组件的 key

key 的作用是为了在 diff 算法执行时更快的找到对应的节点，提高 diff 速度。vue 和 react 都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。在 vue 的 diff 函数中。

# 小程序

## 小程序尺寸单位 rpx

尺寸单位 rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为 750rpx。如在 iPhone6 上，屏幕宽度为 375px，共有 750 个物理像素，则 750rpx = 375px = 750 物理像素，1rpx = 0.5px = 1 物理像素。

## 微信小程序获取用户信息

`wx.login(Object object)`。调用接口获取登录凭证（code）。通过凭证进而换取用户登录态信息，包括用户的唯一标识（openid）及本次登录的会话密钥（session_key）等。用户数据的加解密通讯需要依赖会话密钥完成。

`wx.getUserInfo(Object object)`。调用前需要用户授权 `scope.userInfo`。获取用户信息。

## 小程序的目录结构

微信小程序目录结构可以分为三个部分：框架全局文件、框架页面文件和工具类文件。

- 框架全局文件。一个小程序的主题部分由三个文件组成，作为全局文件，必须放在项目的根目录，分别是`app.js`小程序逻辑、`app.json`小程序公共设置和`app.wxss`小程序公共样式表。
  `app.js`文件用来定义全局数据和函数的使用，可以指定小程序的生命周期函数。`app.json`文件可以对五个功能进行设置：配置页面路径、配置窗口表现、配置标签导航、配置网络超时、配置 debug 模式。`app.wxss`文件对 CSS 样式进行了扩充和修改，定义在 app.wxss 中的样式为全局样式，作用于每一个页面。

- 框架页面文件。pages 文件夹主要存放小程序的页面文件，其中每个文件夹为一个页面，每个页面包含四个文件。小程序每个页面必须有.wxml 和.js 文件，其他两种类型的文件（.json和.wxss）可以不需要。注意：为了方便开发者减少配置项，描述页面的四个文件必须具有相同的路径与文件名。

- 工具类文件。在微信小程序框架目录里还有一个“utils”文件夹，它用来存放工具栏的 js 函数。定义这些函数后，要通过 module.exports 将定义的函数名称注册进来，在其他页面才可以使用。

## 小程序文件的作用域

在 JavaScript 文件中声明的变量和函数只在该文件中有效；不同的文件中可以声明相同名字的变量和函数，不会互相影响。通过全局函数 `getApp()` 可以获取全局的应用实例，如果需要全局的数据可以在 `App()` 中设置。也可以在 `App()`中创建自定义全局函数，在 App 全局中使用 `getApp()` 获取到的全局应用实例来调用此方法。

模块只有通过 `module.exports` 或者 `exports` 才能对外暴露接口。在需要使用这些模块的文件中，使用 `require(path)` 将公共代码引入，使用引用实例进行公共方法的调用。

## 小程序常用组件

- view 视图容器。
- scroll-view 可滚动视图区域。
- swiper 滑块视图容器。
- movable-view 可移动的视图容器，在页面中可以拖拽滑动
- cover-view 覆盖在原生组件之上的文本视图。
- cover-image 覆盖在原生组件之上的图片视图。

## WXML 语法

数据绑定。WXML 中的动态数据均来自对应 Page 的 data。数据绑定使用 Mustache 语法（双大括号）将变量包起来。

列表渲染。在组件上使用 `wx: for` 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。默认数组的当前项的下标变量名默认为 index，数组当前项的变量名默认为 item。使用 wx:for-item 可以指定数组当前元素的变量名，使用 wx:for-index 可以指定数组当前下标的变量名。如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 input 中的输入内容，switch 的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。

条件渲染。在框架中，使用 `wx: if=""` 来判断是否需要渲染该代码块，也可以用 `wx: elif` 和 `wx: else` 来添加一个 else 块。因为 wx:if 是一个控制属性，需要将它添加到一个标签上。如果要一次性判断多个组件标签，可以使用一个 `<block/>` 标签将多个组件包装起来，并在上边使用 wx:if 控制属性。

模板。WXML 提供模板（template），可以在模板中定义代码片段，然后在不同的地方调用。使用 name 属性，作为模板的名字。然后在`<template/>`内定义代码片段。使用 is 属性，声明需要的使用的模板，然后将模板所需要的 data 传入

引用。WXML 提供两种文件引用方式 import 和 include。import 可以在该文件中使用目标文件定义的 template。import 有作用域的概念，即只会 import 目标文件中定义的 template，而不会 import 目标文件 import 的 template。include 可以将目标文件除了 `<template/>` `<wxs/>` 外的整个代码引入，相当于是拷贝到 include 位置。

## 事件及事件绑定

在组件中绑定一个事件处理函数。如 bindtap，当用户点击该组件的时候会在该页面对应的 Page 中找到相应的事件处理函数。在相应的 Page 定义中写上相应的事件处理函数，参数是 event。

支持使用 WXS 函数绑定事件，WXS 函数接受 2 个参数，第一个是 event，在原有的 event 的基础上加了 event.instance 对象，第二个参数是 ownerInstance，和 event.instance 一样是一个 ComponentDescriptor 对象。在组件中绑定和注册事件处理的 WXS 函数。

事件分为冒泡事件和非冒泡事件：

- 冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。
- 非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。

事件绑定的写法同组件的属性，以 key、value 的形式。

- key 以bind或catch开头，然后跟上事件的类型，如bindtap、catchtouchstart。自基础库版本 1.5.0 起，在非原生组件中，bind和catch后可以紧跟一个冒号，其含义不变，如`bind:tap`、`catch:touchstart`。
- value 是一个字符串，需要在对应的 Page 中定义同名的函数。不然当触发事件的时候会报错。

bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。

## 事件对象

如无特殊说明，当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。

`BaseEvent` 基础事件对象属性列表。`currentTarget`是代表事件绑定的当前组件，其中`id`表示当前组件的id，`dataset`表示当前组件上由`data-`开头的自定义属性组成的集合。特殊事件 canvas 中的触摸事件不可冒泡，所以没有`currentTarget`。

| 属性 | 类型 | 说明 |
|---|---|---|
| type | String | 事件类型 |
| timeStamp | Integer | 事件生成时的时间戳 |
| target | Object | 触发事件的组件的一些属性值集合 |
| currentTarget | Object | 当前组件的一些属性值集合 |
| mark | Object | 事件标记数据 |

`CustomEvent` 自定义事件对象属性列表（继承 BaseEvent）。自定义事件所携带的数据，如表单组件的提交事件会携带用户的输入，媒体的错误事件会携带错误信息。

| 属性 | 类型 | 说明 |
|---|---|---|
| detail | Object | 额外的信息 |

`TouchEvent` 触摸事件对象属性列表（继承 BaseEvent）：

| 属性 | 类型 | 说明 |
|---|---|---|
| touches | Array | 触摸事件，当前停留在屏幕中的触摸点信息的数组 |
| changedTouches | Array | 触摸事件，当前变化的触摸点信息的数组 |

## 页面跳转

- `wx.switchTab` 跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面
- `wx.reLaunch` 关闭所有页面，打开到应用内的某个页面
- `wx.redirectTo` 关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。
- `wx.navigateTo` 保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。使用 wx.navigateBack 可以返回到原页面。小程序中页面栈最多十层。
- `wx.navigateBack` 关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages 获取当前的页面栈，决定需要返回几层。

通过`wx.navigateTo`推入一个新的页面，通过`getCurrentPages`获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。

| 路由方式 | 触发时机 | 页面栈表现 | 进入方式 |
|---|---|---|---|
| 初始化 | 小程序打开的第一个页面 | 新页面入栈 | 从下往上升起 |
| 打开新页面 | 调用 API wx.navigateTo | 新页面入栈 | 从右往左切入 |
| 页面重定向 | 调用 API wx.redirectTo | 当前页面出栈，新页面入栈 | 页面重新加载 |
| 页面返回 | 返回/调用 API wx.navigateBack | 页面不断出栈，直到目标返回页 | 从右往左切回 |
| Tab 切换 | 切换/调用 API wx.switchTab | 页面全部出栈，只留下新的 Tab 页面 | 页面重新加载 |
| 重加载 | 调用 API wx.reLaunch | 页面全部出栈，只留下新的页面 | 页面重新加载 |

`wx.navigateTo`和`wx.redirectTo`只能打开非 TabBar 页面，`wx.switchTab`只能打开 Tabbar 页面，`wx.reLaunch`可以打开任意页面。跳转到 TabBar 页面，路径后不能带参数（注意，Tabbar 页面初始化之后不会被销毁），调用页面路由带的参数可以在目标页面的onLoad中获取。

页面的跳转存在哪些问题呢？
- 与接口的调用一样面临url的管理问题；
- 传递参数的方式不太友好，只能拼装url；
- 参数类型单一，只支持string。

第一个问题很好解决，我们做一个集中管理，比如新建一个router/routes.js文件来实现alias：
```js
// routes.js
module.exports = {
  home: '/pages/index/index',
  uc: '/pages/user_center/index',
};

// page
const routes = require('../../router/routes.js');
Page({
  onReady() {
    wx.navigateTo({
      url: routes.uc,
    });
  },
});
```


第二个问题，实现一个navigateTo函数，接受url参数和query参数，再自动拼接成需要的跳转参数。
```js
const routes = require('../../router/routes.js');

function navigateTo({ url, query }) {
  const queryStr = Object.keys(query).map(k => `${k}=${query[k]}`).join('&');
  wx.navigateTo({
    url: `${url}?${queryStr}`,
  });
}

Page({
  onReady() {
    const userId = '123456';
    navigateTo({
      url: routes.uc,
      query: {
        userId,
      },
    });
  },
});
```

第三个问题，参数保真。把要传的数据转成json字符串（JSON.stringify），然后在下个页面把它转回json数据（JSON.parse）。
```js
// routes.js
function navigateTo({ url, data }) {
  const dataStr = encodeURIComponent(JSON.stringify(data));
  wx.navigateTo({
    url: `${url}?encodedData=${dataStr}`,
  });
}

function extract(options) {
  return JSON.parse(decodeURIComponent(options.encodedData));
}

module.exports = {
  routes,
  navigateTo,
  extract,
};

// page home
const router = require('../../router/index.js');
Page({
  onLoad(options) {
    router.navigateTo({
      url: router.routes.uc,
      data: {
        isActive: true,
      },
    });
  },
});

// page uc
const router = require('../../router/index.js');
Page({
  onLoad(options) {
    const json = router.extract(options);
    console.log(json.isActive); // => true
    console.log(typeof json.isActive); // => "boolean"
    console.log(json.isActive === true); // => true
  },
});
```

## 设置 tabBar

tabBar 就是微信小程序下方的导航栏。

小程序开发过程中，当接受新的消息时，需要给出右上角的红点的提示，只需要调用函数`wx.showTabBarRedDot(Object object)`。

在微信小程序开发过程中，我们有时候需要界面全屏显示，比如调用地图API时，这样才能给用户更好的人机体验，这是后就需要动态的显示和隐藏微信小程序中的tabbar导航栏，关于显示tabbar，我们只需要调用函数：`wx.showTabBar(Object object)`。

在微信小程序开发过程中，我们有时候需要设置更为个性的tabbar，或者由于主题颜色的需求，我们需要保持与主题颜色一样，就需要调整tabbar的整体样式，我们只需要调用函数：`wx.setTabBarStyle(Object object)`。

当有好友发送消息过来时，tabbar右上角会有消息文本提示，这时只需要调用函数：`wx.setTabBarBadge(Object object)`。

## 页面生命周期

在app.js文件中，定义了一些生命周期方法：

- `onLaunch` 监听小程序初始化 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）
- `onShow` 监听小程序显示 当小程序启动，或从后台进入前台显示，会触发 onShow
- `onHide` 监听小程序隐藏 当小程序从前台进入后台，会触发 onHide
- `onError` 错误监听函数 当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息
- 其他 开发者可以添加任意的函数或数据到 Object 参数中，用 this 可以访问

在page页面中定义的生命周期方法：

- `onLoad` 监听页面加载
- `onReady` 监听页面初次渲染完成
- `onShow` 监听页面显示
- `onHide` 监听页面隐藏
- `onUnload` 监听页面卸载

## 转发分享

页面内发起转发。通过给 button 组件设置属性 `open-type="share"`，可以在用户点击按钮后触发 `Page.onShareAppMessage` 事件，如果当前页面没有定义此事件，则点击后无效果。

`onShareAppMessage(Object object)` 监听用户点击页面内转发按钮（button 组件 `open-type="share"`）或右上角菜单“转发”按钮的行为，并自定义转发内容。注意：只有定义了此事件处理函数，右上角菜单才会显示“转发”按钮。

## request 请求后台接口



## http-promise 封装



## webview



## 获取用户收货地址

`wx.chooseAddress(Object object)`。获取用户收货地址。调起用户编辑收货地址原生界面，并在编辑完成后返回用户选择的地址。

参数 `Object object`

| 属性 | 类型 | 必填 | 说明 |
|---|---|---|---|
| success | function | 否 | 接口调用成功的回调函数 |
| fail | function | 否 | 接口调用失败的回调函数 |
| complete | function | 否 | 接口调用结束的回调函数（调用成功、失败都会执行） |

object.success 回调函数的参数 `Object res`

| 属性 | 类型 | 说明 |  |
|---|---|---|---|
| userName | string | 收货人姓名 |  |
| postalCode | string | 邮编 |  |
| provinceName | string | 国标收货地址第一级地址 |  |
| cityName | string | 国标收货地址第二级地址 |  |
| countyName | string | 国标收货地址第三级地址 |  |
| detailInfo | string | 详细收货地址信息 |  |
| nationalCode | string | 收货地址国家码 |  |
| telNumber | string | 收货人手机号码 |  |
| errMsg | string | 错误信息 |  |

## 获取地理位置

`wx.getLocation(Object object)`。获取当前的地理位置、速度。当用户离开小程序后，此接口无法调用。调用前需要 用户授权 `scope.userLocation`。

```js
wx.getLocation({
 type: 'wgs84',
 success (res) {
   const latitude = res.latitude
   const longitude = res.longitude
   const speed = res.speed
   const accuracy = res.accuracy
 }
})
```

## 自定义组件

类似于页面，一个自定义组件由 json wxml wxss js 4个文件组成。要编写一个自定义组件，首先需要在 json 文件中进行自定义组件声明（将 component 字段设为 true 可这一组文件设为自定义组件）。

注意：在组件wxss中不应使用ID选择器、属性选择器和标签名选择器。

在自定义组件的 js 文件中，需要使用 `Component()` 来注册组件，并提供组件的属性定义、内部数据和自定义方法。

组件的属性值和内部数据将被用于组件 wxml 的渲染，其中，属性值是可由组件外部传入的。

```js
Component({
  properties: {
    // 这里定义了innerText属性，属性值可以在组件使用时指定
    innerText: {
      type: String,
      value: 'default value',
    }
  },
  data: {
    // 这里是一些组件内部数据
    someData: {}
  },
  methods: {
    // 这里是一个自定义方法
    customMethod: function(){}
  }
})
```

使用已注册的自定义组件前，首先要在页面的 json 文件中进行引用声明。此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径。这样，在页面的 wxml 中就可以像使用基础组件一样使用自定义组件。节点名即自定义组件的标签名，节点属性即传递给组件的属性值。

# 浏览器

## 主流浏览器的内核分别是什么

- IE浏览器内核：**Trident**内核，也是俗称的IE内核；
- Chrome浏览器内核：统称为Chromium内核或Chrome内核，以前是Webkit内核，现在是**Blink**内核；
- Firefox浏览器内核：**Gecko**内核，俗称Firefox内核；
- Safari浏览器内核：**Webkit**内核；
- Opera浏览器内核：最初是自己的Presto内核，后来是Webkit，现在是**Blink**内核；
- 360浏览器、猎豹浏览器内核：IE+Chrome双内核；
- 搜狗、遨游、QQ浏览器内核：Trident（兼容模式）+Webkit（高速模式）；
- 百度浏览器、世界之窗内核：IE内核；
- 2345浏览器内核：以前是IE内核，现在也是IE+Chrome双内核；

## URL到渲染页面过程

一个页面从输入URL到页面加载显示完成，这个过程都发生什么？

1. 首先，在浏览器地址栏中输入url
2. 浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。
3. 在发送http请求前，需要域名解析（DNS解析），解析获取相应的IP地址。
4. 浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。
5. 握手成功后，浏览器向服务器发送http请求，请求数据包。
6. 服务器处理收到的请求，将数据返回至浏览器
7. 浏览器收到HTTP响应
8. 读取页面内容，浏览器渲染，解析html源码
9. 生成Dom树、解析css样式、js交互
10. 客户端和服务器交互
11. ajax查询

其中，步骤2的具体过程是：

- 浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；
- 操作系统缓存：如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统，获取操作系统的记录（保存最近的DNS查询缓存）；
- 路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；
- ISP缓存：若上述均失败，继续向ISP搜索。



