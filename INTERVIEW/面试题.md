根据网上的面试题整理出来的

# HTML

- Doctype 作用，严格模式与混杂模式.

答：<!DOCTYPE> 声明必须是 HTML 文档的第一行，位于 <html> 标签之前。<!DOCTYPE> 声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。HTML5 不基于 SGML，所以不需要引用 DTD。

严格模式：又称标准模式，是指浏览器按照 W3C 标准解析代码。混杂模式：又称怪异模式或兼容模式，是指浏览器用自己的方式解析代码。浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD 直接相关。DOCTYPE 不存在或格式不正确会导致文档以混杂模式呈现。

- HTML5 新特性. HTML5 兼容性.

答：语义特性（header/section/footer/article/nav）、本地存储特性、设备兼容特性（媒体 API/地理 API/拖拽 API）、连接通信、Canvas 画布。

IE9+以及谷歌、火狐、苹果等主流浏览器对大部分 HTML5 属性均为支持状态。IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签。浏览器支持新标签后，还需要添加标签默认的样式（当然最好的方式是直接使用成熟的框架、使用最多的是 html5shim 框架）。

- 语义化的理解

HTML 语义化就是让页面的内容结构化，便于阅读和维护，便于浏览器、搜索引擎解析，利于 SEO。

- HTML5 的离线储存和 cookies

localStorage 长期存储数据，浏览器关闭后数据不丢失；sessionStorage 数据在浏览器关闭后自动删除。

cookie 在浏览器和服务器间来回传递，存储空间小。

- iframe 缺点

iframe 会阻塞主页面的 Onload 事件；iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。

使用 iframe 之前需要考虑这两个缺点。如果需要使用 iframe，最好是通过 javascript 动态给 iframe 添加 src 属性值，这样可以可以绕开以上两个问题。

# CSS

- 行内元素.块级元素

行内元素有：a b span img input select strong（强调的语气）
块级元素有：div ul ol li dl dt dd h1 h2 h3 h4 p

- link 和@import 的区别

（1）link 属于 XHTML 标签，而@import 是 CSS 提供的;
（2）页面被加载的时，link 会同时被加载，而@import 引用的 CSS 会等到页面被加载完再加载;
（3）import 只在 IE5 以上才能识别，而 link 是 XHTML 标签，无兼容问题;
（4）link 方式的样式的权重高于@import 的权重.

- CSS 选择符.

标签选择器、类选择器、id 选择器、后代选择器、子选择器、相邻选择器、通配符选择器、属性选择器。

伪元素（::first-letter/::first-line/::before/::after）。

伪类（:link/:visited/:hover/:active）、结构化伪类和表单伪类。

- CSS3 新增伪类

p:first-of-type 选择属于其父元素的首个 `<p>` 元素的每个 `<p>` 元素。

p:last-of-type 选择属于其父元素的最后 `<p>` 元素的每个 `<p>` 元素。

p:only-of-type 选择属于其父元素唯一的 `<p>` 元素的每个 `<p>` 元素。

p:only-child 选择属于其父元素的唯一子元素的每个 `<p>` 元素。

p:nth-child(2) 选择属于其父元素的第二个子元素的每个 `<p>` 元素。

:enabled :disabled 控制表单控件的禁用状态。

:checked 单选框或复选框被选中。

- CSS3 新特性

布局更为丰富（CSS3 媒介查询、弹性盒子布局、格珊布局）、视觉表现更进步（圆角、阴影和渐变、transform 变换、filter 滤镜和混合模式、animation 动画）。

- 清除浮动

使用空标签清除浮动、使用 after 伪元素清除浮动、使用 overflow: auto，兼容 IE 则使用 zoom: 1、父元素设置高度

- position 属性

absolute.生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。

fixed.生成固定定位的元素，相对于浏览器窗口进行定位。元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。

relative.生成相对定位的元素，相对于其正常位置进行定位。

static	默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。

inherit	规定应该从父元素继承 position 属性的值。

# JavaScript

- 浏览器的内核分别是什么

IE 浏览器的内核 Trident、Mozilla 的 Gecko、Safari 的 Webkit、Chrome 的 Blink（WebKit 的分支）、Opera 内核原为 Presto，现为 Blink。

- 资源优化

文件合并、文件压缩、CDN 托管、缓存的使用。

- JavaScript 的 typeof 返回数据类型

Undefined、Boolean、Number、String、Function、Object、Symbol

- jsonp 原理.

要理解跨域，先要了解一下“同源策略”。所谓同源是指，域名，协议，端口相同。所谓“同源策略“，简单的说就是基于安全考虑，当前域不能访问其他域的东西。

JSONP 实现跨域请求的原理简单的说，就是动态创建`<script>`标签，然后利用`<script>`的 src 不受同源策略约束来跨域获取数据。Ajax 是页面无刷新请求数据操作。

- 数组去重方法

```JavaScript
function unique(arr){
    var res=[];
    for(var i=0,len=arr.length;i<len;i++){
        var obj = arr[i];
        for(var j=0,jlen = res.length;j<jlen;j++){
            if(res[j]===obj) break;
        }
        if(jlen===j)res.push(obj);
    }
    return res;
}
var arr=[1,1,'2','1',3,4]
arr = unique(arr);
console.log(arr);
```

- 异步 ajax 优缺点

优点：不会造成 UI 卡死，用户体验好；局部刷新页面，省流量。

缺点：后退按钮无效，多个请求回调时间不确定，对搜索引擎不友好、数据安全。

- src 与 href

href 表示超文本引用（hypertext reference），在 `<link>` 和 `<a>` 等元素上使用。src 表示来源地址，是指外部资源的位置，指向的内容将会嵌入到文档中当前标签 所在的位置，在 img、script、iframe 等元素上。

- 闭包

使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。

闭包有三个特性：

1.函数嵌套函数

2.函数内部可以引用外部的参数和变量

3.参数和变量不会被垃圾回收机制回收

- React/Vue 中组件的 key

key 的作用是为了在 diff 算法执行时更快的找到对应的节点，提高 diff 速度。vue 和 react 都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。在 vue 的 diff 函数中。

- 防抖和节流

防抖。触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间。思路，每次触发事件时都取消之前的延时调用方法。

```JavaScript
function debounce(fn) {
     let timeout = null; // 创建一个标记用来存放定时器的返回值
     return function () {
       clearTimeout(timeout); // 每当用户输入的时候把前一个 setTimeout clear 掉
       timeout = setTimeout(() => { // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数
         fn.apply(this, arguments);
       }, 500);
     };
   }

   function sayHi() {
     console.log('防抖成功');
   }
   var inp = document.getElementById('inp');
   inp.addEventListener('input', debounce(sayHi)); // 防抖
```

节流。高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率。思路，每次触发事件时都判断当前是否有等待执行的延时函数。

```JavaScript
function throttle(fn) {
     let canRun = true; // 通过闭包保存一个标记
     return function () {
       if (!canRun) return; // 在函数开头判断标记是否为 true，不为 true 则 return
       canRun = false; // 立即设置为 false
       setTimeout(() => { // 将外部传入的函数的执行放在 setTimeout 中
         fn.apply(this, arguments);
         // 最后在 setTimeout 执行完毕后再把标记设置为 true(关键) 表示可以执行下一次循环了。当定时器没有执行的时候标记永远是 false，在开头被 return 掉
         canRun = true;
       }, 500);
     };
   }
function sayHi(e) {
    console.log(e.target.innerWidth, e.target.innerHeight);
}
window.addEventListener('resize', throttle(sayHi));
```

- js垃圾回收方法

标记清除（mark and sweep）

这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。

垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了
　　
引用计数(reference counting)

在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。

在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的， 也就是说只要涉及BOM及DOM就会出现循环引用问题。

- vue生命周期

beforeCreate。组建实例化刚被创建，该过程在组件属性计算之前，在这个时候data和el,以及自定义的message都是undefined


created。组件实例化创建完成，属性已绑定，但是dom还未生成，$el属性还不存在,在这个时候data和message已经初始化了


beforeMount。模板编译/挂载之前 $el和data、message都被初始化了


mounted。模板编译/挂载之后 $el和data、message都被初始化了


beforeUpdate。组件更新之前


updated。组件更新之后


activated。keep-alive,组件激活时被调用


deactivated。keep-alive,组件移除时被调用


beforeDestory。组件销毁前被调用


destory。组件销毁后被调用
