# 1. 小册食用指南

# 2. JS 基础知识点及常考面试题（一）

## 3.1 原始（Primitive）类型

在 JS 中，存在着六种原始值，分别是

- boolean
- null
- undefined
- number
- string
- symbol

原始类型存储的都是值，是没有函数可以调用的。其中 number 类型是浮点类型的，null 不是对象类型。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。

## 3.2 对象（Object）类型

在 JS 中，除了原始类型那么其他的都是对象类型了。对象类型和原始类型不同的是，原始类型存储的是值，对象类型存储的是地址（指针）。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。

```JavaScript
function test(person) {
  person.age = 26
  person = {
    name: 'yyy',
    age: 30
  }

  return person
}
const p1 = {
  name: 'yck',
  age: 25
}
const p2 = test(p1)
console.log(p1) // {name: "yck", age: 26}
console.log(p2) // {name: "yyy", age: 30}
```

## 3.3 typeof vs instanceof

typeof 对于原始类型来说，除了 null 都可以显示正确的类型。typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型。如果我们想判断一个对象的正确类型，这时候可以考虑使用 instanceof，因为内部机制是通过原型链来判断的。

```JavaScript
const Person = function() {}
const p1 = new Person()
p1 instanceof Person // true

var str = 'hello world'
str instanceof String // false

var str1 = new String('hello world')
str1 instanceof String // true
```

对于原始类型来说，如果直接通过 instanceof 来判断类型是不行的。这其实也侧面反映了一个问题， instanceof 也不是百分之百可信的。

## 3.4 类型转换

转Boolean。在条件判断时，除了 undefined， null， false， NaN， ''， 0， -0，其他所有值都转为 true，包括所有对象。

对象转原始类型。对象在转换类型的时候，会调用内置的 [[ToPrimitive]] 函数，对于该函数来说，算法逻辑一般来说如下：

- 如果已经是原始类型了，那就不需要转换了
- 调用 x.valueOf()，如果转换为基础类型，就返回转换的值
- 调用 x.toString()，如果转换为基础类型，就返回转换的值
- 如果都没有返回原始类型，就会报错

四则运算符。加法运算符不同于其他几个运算符，它有以下几个特点：

- 运算中其中一方为字符串，那么就会把另一方也转换为字符串
- 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串

另外对于加法还需要注意这个表达式 'a' + + 'b'

```javaScript
'a' + + 'b' // -> "aNaN"
```

那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。

比较运算符。

- 如果是对象，就通过 toPrimitive 转换对象
- 如果是字符串，就通过 unicode 字符索引来比较

## 3.5 this

几个函数调用的场景

```JavaScript
function foo() {
  console.log(this.a)
}
var a = 1
foo()

const obj = {
  a: 2,
  foo: foo
}
obj.foo()

const c = new foo()
```

- 对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window。
- 对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象。
- 对于 new 的方式来说，this 被永远绑定在了 c 上面，不会被任何方式改变 this。

箭头函数其实是没有 this 的，箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this。

最后种情况也就是 bind 这些改变上下文的 API 了，对于这些函数来说，this 取决于第一个参数，如果第一个参数为空，那么就是 window。

可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高的来决定 this 最终指向哪里。首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。

# 3. JS 基础知识点及常考面试题（二）

# 4. ES6 知识点及常考面试题

# 5. JS 异步编程及常考面试题

# 6. 手写 Promise

# 7. Event Loop

# 8. JS 进阶知识点及常考面试题

# 9. JS 思考题

# 10. DevTools Tips

# 11. 浏览器基础知识点及常考面试题

# 12. 浏览器缓存机制

# 13. 浏览器渲染原理

# 14. 安全防范知识点

# 15. 从 V8 中看 JS 性能优化

# 16. 性能优化琐碎事

# 17. Webpack 性能优化

# 18. 实现小型打包工具

# 19. React 和 Vue 两大框架之间的相爱相杀

# 20. Vue 常考基础知识点

# 21. Vue 常考进阶知识点

# 22. React 常考基础知识点

# 23. React 常考进阶知识点

# 24. 监控

# 25. UDP

# 26. TCP

# 27. HTTP 及 TLS

# 28. HTTP/2 及 HTTP/3

# 29. 输入 URL 到页面渲染的整个流程

# 30. 设计模式

# 31. 常见数据结构

# 32. 常考算法题解析

# 33. CSS 常考面试题资料

# 34. 如何写好一封简历

# 35. 面试常用技巧

# 36. 前方的路，让我们结伴同行


