# 1. 小册食用指南

# 2. JS 基础知识点及常考面试题（一）

## 2.1 原始（Primitive）类型

在 JS 中，存在着六种原始值，分别是

- boolean
- null
- undefined
- number
- string
- symbol

原始类型存储的都是值，是没有函数可以调用的。其中 number 类型是浮点类型的，null 不是对象类型。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。

## 2.2 对象（Object）类型

在 JS 中，除了原始类型那么其他的都是对象类型了。对象类型和原始类型不同的是，原始类型存储的是值，对象类型存储的是地址（指针）。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。

```JavaScript
function test(person) {
  person.age = 26
  person = {
    name: 'yyy',
    age: 30
  }

  return person
}
const p1 = {
  name: 'yck',
  age: 25
}
const p2 = test(p1)
console.log(p1) // {name: "yck", age: 26}
console.log(p2) // {name: "yyy", age: 30}
```

## 2.3 typeof vs instanceof

typeof 对于原始类型来说，除了 null 都可以显示正确的类型。typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型。如果我们想判断一个对象的正确类型，这时候可以考虑使用 instanceof，因为内部机制是通过原型链来判断的。

```JavaScript
const Person = function() {}
const p1 = new Person()
p1 instanceof Person // true

var str = 'hello world'
str instanceof String // false

var str1 = new String('hello world')
str1 instanceof String // true
```

对于原始类型来说，如果直接通过 instanceof 来判断类型是不行的。这其实也侧面反映了一个问题， instanceof 也不是百分之百可信的。

## 2.4 类型转换

转Boolean。在条件判断时，除了 undefined， null， false， NaN， ''， 0， -0，其他所有值都转为 true，包括所有对象。

对象转原始类型。对象在转换类型的时候，会调用内置的 [[ToPrimitive]] 函数，对于该函数来说，算法逻辑一般来说如下：

- 如果已经是原始类型了，那就不需要转换了
- 调用 x.valueOf()，如果转换为基础类型，就返回转换的值
- 调用 x.toString()，如果转换为基础类型，就返回转换的值
- 如果都没有返回原始类型，就会报错

四则运算符。加法运算符不同于其他几个运算符，它有以下几个特点：

- 运算中其中一方为字符串，那么就会把另一方也转换为字符串
- 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串

另外对于加法还需要注意这个表达式 'a' + + 'b'

```javaScript
'a' + + 'b' // -> "aNaN"
```

那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。

比较运算符。

- 如果是对象，就通过 toPrimitive 转换对象
- 如果是字符串，就通过 unicode 字符索引来比较

## 2.5 this

几个函数调用的场景

```JavaScript
function foo() {
  console.log(this.a)
}
var a = 1
foo()

const obj = {
  a: 2,
  foo: foo
}
obj.foo()

const c = new foo()
```

- 对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window。
- 对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象。
- 对于 new 的方式来说，this 被永远绑定在了 c 上面，不会被任何方式改变 this。

箭头函数其实是没有 this 的，箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this。

最后种情况也就是 bind 这些改变上下文的 API 了，对于这些函数来说，this 取决于第一个参数，如果第一个参数为空，那么就是 window。

可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高的来决定 this 最终指向哪里。首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。

# 3. JS 基础知识点及常考面试题（二）

## 3.1 ==vs===

对于`==`来说，如果对比双方的类型不一样的话，就会进行类型转换。
- 首先判断两者类型是否相同，相同的话就是比较大小
- 类型不相同的话进行类型转换
- 会先判断是否在对比`null`和`undefined`，是的话就会返回true
- 判断两者类型是否为`string`和`number`，是的话就会将字符串转换为`number`
- 判断其中一方是否为`boolean`，是的话就会把`boolean`转为`number`再进行判断
- 判断其中一方是否为`object`且另一方为`string`、`number`或者`sybol`，是的话就会把`object`转为原始类型再进行判断

对于`===`来说就简单多了，就是判断两者类型和值是否相同。

## 3.2 闭包

闭包的定义很简单：函数 A 内部有一个函数 B，函数 B 可以访问函数 A 中的变量，那么函数B就是闭包。说闭包是函数嵌套函数，然后返回一个函数的解释，是不完整的。

首先因为 setTimeout 是个异步函数，所以会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。

```JavaScript
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i * 1000)
}
// 6 6 6 6 6 
```

解决办法有是三种，第一种是使用闭包的方式。首先使用立即执行函数将 i 传入函数内部，这个时候就被固定在了参数 j 上面不会改变，当下次执行 timer 这个闭包的时候，就可以使用外部函数的变量 j，从而达到目的。

```JavaScript
for (var i = 1; i <= 5; i++) {
  ;(function(j) {
    setTimeout(function timer() {
      console.log(j)
    }, j * 1000)
  })(i)
}
```

第二种就是使用 setTimeout 的第三个参数，这个参数会被当成 timer 函数的参数传入。

```JavaScript
for (var i = 1; i <= 5; i++) {
  setTimeout(
    function timer(j) {
      console.log(j)
    },
    i * 1000,
    i
  )
}
```

第三种就是使用 let 定义 i 了来解决问题了，这个也是最为推荐的方式。

```JavaScript
for (let i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i * 1000)
}
```

## 3.3 深浅拷贝

对象类型在赋值的过程中其实是复制了地址，从而会导致改变了一方其他也都被改变的情况。通常在开发中不希望出现这样的问题，那么可以使用浅拷贝来解决这个情况。

浅拷贝。`Object.assign`只会拷贝所有的属性值到新的对象中，如果属性值时对象的话，拷贝的是地址，所以并不是深拷贝。

```JavaScript
let a = {
  age: 1
}
let b = Object.assign({}, a)
a.age = 2
console.log(b.age) // 1
```

另外还可以通过展开运算符`...`来实现浅拷贝。

```JavaScript
let a = {
  age: 1
}
let b = { ...a }
a.age = 2
console.log(b.age) // 1
```

通常浅拷贝就能解决大部分问题了，但是浅拷贝只解决了第一层的问题，如果接下去的值还有对象的话，那么两者就享有相同的地址了。要解决这个问题，就得使用深拷贝。

深拷贝通常可以通过`JSON.parse(JSON.stringify(object))`来解决。

```JavaScript
let a = {
  age: 1,
  jobs: {
    first: 'FE'
  }
}
let b = JSON.parse(JSON.stringify(a))
a.jobs.first = 'native'
console.log(b.jobs.first) // FE
```

但是该方法也是有局限性的。这样会忽略 undefined、symbol、不能序列化函数和不能解决循环引用的对象。因此如果所需拷贝的对象含有内置类型并且不包含函数，可以使用 MessageChannel。

```JavaScript
function structuralClone(obj) {
  return new Promise(resolve => {
    const { port1, port2 } = new MessageChannel()
    port2.onmessage = ev => resolve(ev.data)
    port1.postMessage(obj)
  })
}

var obj = {
  a: 1,
  b: {
    c: 2
  }
}

obj.b.d = obj.b

// 注意该方法是异步的
// 可以处理 undefined 和循环引用对象
const test = async () => {
  const clone = await structuralClone(obj)
  console.log(clone)
}
test()
```

## 3.4 原型

当创建一个对象时`let obj = { age: 25 }`，可以发现能使用很多函数。其实每个 JS 对象都有`_proto_`属性，这个属性指向了原型。这个属性现在来说已经不推荐直接去使用它了，这只是浏览器在早期为了让我们访问内部属性`[[prototype]]`来实现的一个东西。

原型也是一个对象，并且这个对象中包含了很多函数，所以我们可以得出一个结论：对于 obj 来说，可以通过 `__proto__` 找到一个原型对象，在该对象中定义了很多函数让我们来使用。

原型的 constructor 属性指向构造函数，构造函数又通过 prototype 属性指回原型，但是并不是所有函数都具有这个属性，`Function.prototype.bind()` 就没有这个属性。

原型链就是多个对象通过`_proto_`的方式连接起来。

# 4. ES6 知识点及常考面试题

## 4.1 var、let及const区别

var 声明的变量会发生提升的情况，并且提升的是声明。使用 var 声明的变量会被提升到作用域的顶部。

```JavaScript
var a
console.log(a) // undefined
a = 1
```

同时，不仅变量会提升，函数也会被提升。并且，函数声明会优先于变量提升。

```JavaScript
console.log(a) // ƒ a() {}
function a() {}
var a = 1
```

let和const。首先在全局作用域下使用 let 和 const 声明变量，变量并不会被挂在到 window 上，这一点就和 var 声明有了区别。

```JavaScript
var a = 1
let b = 1
const c = 1
console.log(window.b) // undefined
console.log(window. c) // undefined

function test(){
  console.log(a)
  let a
}
test()
```

上面代码会出现报错的情况。报错的原因是因为存在暂时性死区，我们不能在声明前就使用变量，这也是 let 和 const 优于 var 的一点。

那么为什么要存在提升这个事情呢，其实提升存在的根本原因就是为了解决函数间互相调用的情况。

```JavaScript
function test1() {
    test2()
}
function test2() {
    test1()
}
test1()
```

## 4.2 原型继承和Class继承

其实在 JS 中并不存在类，class 只是语法糖，本质还是函数。

```JavaScript
class Person {}
Person instanceof Function // true
```

组合继承。组合继承是最常用的继承方式。

```JavaScript
function Parent(value) {
  this.val = value
}
Parent.prototype.getValue = function() {
  console.log(this.val)
}
function Child(value) {
  Parent.call(this, value)
}
Child.prototype = new Parent()

const child = new Child(1)

child.getValue() // 1
child instanceof Parent // true
```

以上继承的方式核心是在子类的构造函数中通过`Parent.call(this)`继承父类的属性，然后改变子类的原型为`new Parent()`来继承父类的函数。这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费。

寄生组合继承。这种继承方式对组合继承进行了优化，组合继承缺点在于继承父类函数时调用了构造函数，我们只需要优化掉这点就行了。

```JavaScript
function Parent(value) {
  this.val = value
}
Parent.prototype.getValue = function() {
  console.log(this.val)
}

function Child(value) {
  Parent.call(this, value)
}
Child.prototype = Object.create(Parent.prototype, {
  constructor: {
    value: Child,
    enumerable: false,
    writable: true,
    configurable: true
  }
})

const child = new Child(1)

child.getValue() // 1
child instanceof Parent // true
```

以上继承实现的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。

Class继承。以上两种继承方式都是通过原型去解决的，在 ES6 中，可以使用 class 去实现继承。

```JavaScript
class Parent {
  constructor(value) {
    this.val = value
  }
  getValue() {
    console.log(this.val)
  }
}
class Child extends Parent {
  constructor(value) {
    super(value)
    this.val = value
  }
}
let child = new Child(1)
child.getValue() // 1
child instanceof Parent // true
```

class 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super，因为这段代码可以看成 Parent.call(this, value)。

## 4.3 模块化

模块化。模块化可以有解决命名冲突、提供复用性和提高代码可维护性的作用。

立即执行函数。在早期，使用立即执行函数实现模块化是最常见的手段，通过函数作用域解决了命名冲突、污染全局作用域的问题。

```JavaScript
(function(globalVariable){
   globalVariable.test = function() {}
   // ... 声明各种变量、函数都不会污染全局作用域
})(globalVariable)
```

AMD和CMD。鉴于目前这两种实现方式已经很少见到，所以不再对具体特性细聊，只需要了解这两者是如何使用的。

```JavaScript
// AMD
define(['./a', './b'], function(a, b) {
  // 加载模块完毕可以使用
  a.do()
  b.do()
})
// CMD
define(function(require, exports, module) {
  // 加载模块
  // 可以把 require 写在函数体的任意地方实现延迟加载
  var a = require('./a')
  a.doSomething()
})
```

CommonJS。CommonJS最早是 Node 在使用，目前也仍然广泛使用，比如在 Webpack 中就能见到。当然目前在 Node 中的模块管理已经和 CommonJS 有一些区别了。

```JavaScript
// a.js
module.exports = {
    a: 1
}
// or 
exports.a = 1

// b.js
var module = require('./a.js')
module.a // -> log 1
```

另外虽然 exports 和 module.exports 用法相似，但是不能对 exports 直接赋值。因为 var exports = module.exports 这句代码表明了 exports 和 module.exports 享有相同地址，通过改变对象的属性值会对两者都起效，但是如果直接对 exports 赋值就会导致两者不再指向同一个内存地址，修改并不会对 module.exports 起效。

ES Module。ES Module 是原生实现的模块化方案，与 CommonJS有以下几个区别。

- CommonJS 支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是已有提案
- CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响
- CommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化
- ES Module 会编译成 require/exports 来执行的

```JavaScript
// 引入模块 API
import XXX from './a.js'
import { XXX } from './a.js'
// 导出模块 API
export function a() {}
export default function() {}
```

## 4.4 Proxy

如果平时有关注 Vue 的进展的话，可能已经知道了在 Vue3.0 中将会通过 Proxy 来替换原本的 Object.defineProperty 来实现数据响应式。Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。

```JavaScript
let p = new Proxy(target, handler)
```
target 代表需要添加代理的对象，handler 用来自定义对象中的操作，比如可以用来自定义 set 或者 get 函数。

```JavaScript
let onWatch = (obj, setBind, getLogger) => {
  let handler = {
    get(target, property, receiver) {
      getLogger(target, property)
      return Reflect.get(target, property, receiver)
    },
    set(target, property, value, receiver) {
      setBind(value, property)
      return Reflect.set(target, property, value)
    }
  }
  return new Proxy(obj, handler)
}

let obj = { a: 1 }
let p = onWatch(
  obj,
  (v, property) => {
    console.log(`监听到属性${property}改变为${v}`)
  },
  (target, property) => {
    console.log(`'${property}' = ${target[property]}`)
  }
)
p.a = 2 // 监听到属性a改变
p.a // 'a' = 2
```

之所以 Vue3.0 要使用 Proxy 替换原本的 API 原因在于 Proxy 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变，唯一缺陷可能就是浏览器的兼容性不好了。

## 4.5 map，filter，reduce

map 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后放入到新的数组中。另外 map 的回调函数接受三个参数，分别是当前索引元素，索引，原数组。

```JavaScript
[1, 2, 3].map(v => v + 1) // -> [2, 3, 4]
```

filter 的作用也是生成一个新数组，在遍历数组的时候将返回值为 true 的元素放入新数组，我们可以利用这个函数删除一些不需要的元素。和 map 一样，filter 的回调函数也接受三个参数，用处也相同。

```JavaScript
let array = [1, 2, 4, 6]
let newArray = array.filter(item => item !== 6)
console.log(newArray) // [1, 2, 4]
```

reduce 可以将数组中的元素通过回调函数最终转换为一个值。

```JavaScript
const arr = [1, 2, 3]
const sum = arr.reduce((acc, current) => acc + current, 0)
console.log(sum)
```

使用 reduce 还可以实现很多功能，例如通过 reduce 可以实现 map 函数。

```JavaScript
const arr = [1, 2, 3]
const mapArray = arr.map(value => value * 2)
const reduceArray = arr.reduce((acc, current) => {
  acc.push(current * 2)
  return acc
}, [])
console.log(mapArray, reduceArray) // [2, 4, 6]
```

# 5. JS 异步编程及常考面试题

# 6. 手写 Promise

# 7. Event Loop

# 8. JS 进阶知识点及常考面试题

# 9. JS 思考题

# 10. DevTools Tips

# 11. 浏览器基础知识点及常考面试题

# 12. 浏览器缓存机制

# 13. 浏览器渲染原理

# 14. 安全防范知识点

# 15. 从 V8 中看 JS 性能优化

# 16. 性能优化琐碎事

# 17. Webpack 性能优化

# 18. 实现小型打包工具

# 19. React 和 Vue 两大框架之间的相爱相杀

# 20. Vue 常考基础知识点

# 21. Vue 常考进阶知识点

# 22. React 常考基础知识点

# 23. React 常考进阶知识点

# 24. 监控

# 25. UDP

# 26. TCP

# 27. HTTP 及 TLS

# 28. HTTP/2 及 HTTP/3

# 29. 输入 URL 到页面渲染的整个流程

# 30. 设计模式

# 31. 常见数据结构

# 32. 常考算法题解析

# 33. CSS 常考面试题资料

# 34. 如何写好一封简历

# 35. 面试常用技巧

# 36. 前方的路，让我们结伴同行


