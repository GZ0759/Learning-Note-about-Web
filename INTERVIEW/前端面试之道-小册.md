# 第 1 节 小册食用指南

# 第 2 节 JS 基础知识点及常考面试题（一）

## 2.1 原始（Primitive）类型

在 JS 中，存在着六种原始值，分别是

- boolean
- null
- undefined
- number
- string
- symbol

原始类型存储的都是值，是没有函数可以调用的。其中 JS 的 number 类型是浮点类型的，在使用中会遇到某些 Bug，比如 0.1 + 0.2 !== 0.3。

null 不是对象类型。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。

## 2.2 对象（Object）类型

在 JS 中，除了原始类型那么其他的都是对象类型了。对象类型和原始类型不同的是，原始类型存储的是值，对象类型存储的是地址（指针）。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。

```JavaScript
function test(person) {
  person.age = 26
  person = {
    name: 'yyy',
    age: 30
  }

  return person
}
const p1 = {
  name: 'yck',
  age: 25
}
const p2 = test(p1)
console.log(p1) // {name: "yck", age: 26}
console.log(p2) // {name: "yyy", age: 30}
```

## 2.3 typeof vs instanceof

typeof 对于原始类型来说，除了 null 都可以显示正确的类型。typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型。如果我们想判断一个对象的正确类型，这时候可以考虑使用 instanceof，因为内部机制是通过原型链来判断的。

```JavaScript
const Person = function() {}
const p1 = new Person()
p1 instanceof Person // true

var str = 'hello world'
str instanceof String // false

var str1 = new String('hello world')
str1 instanceof String // true
```

对于原始类型来说，如果直接通过 instanceof 来判断类型是不行的。这其实也侧面反映了一个问题， instanceof 也不是百分之百可信的。

## 2.4 类型转换

转 Boolean。在条件判断时，除了 undefined， null， false， NaN， ''， 0， -0，其他所有值都转为 true，包括所有对象。

对象转原始类型。对象在转换类型的时候，会调用内置的 [[ToPrimitive]] 函数，对于该函数来说，算法逻辑一般来说如下：

- 如果已经是原始类型了，那就不需要转换了
- 调用 x.valueOf()，如果转换为基础类型，就返回转换的值
- 调用 x.toString()，如果转换为基础类型，就返回转换的值
- 如果都没有返回原始类型，就会报错

四则运算符。加法运算符不同于其他几个运算符，它有以下几个特点：

- 运算中其中一方为字符串，那么就会把另一方也转换为字符串
- 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串

另外对于加法还需要注意这个表达式 'a' + + 'b'

```javaScript
'a' + + 'b' // 因为 + 'b' 等于 NaN，所以结果为 "aNaN"
```

那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。

比较运算符。

- 如果是对象，就通过 toPrimitive 转换对象
- 如果是字符串，就通过 unicode 字符索引来比较

## 2.5 this

几个函数调用的场景

```JavaScript
function foo() {
  console.log(this.a)
}
var a = 1
foo()

const obj = {
  a: 2,
  foo: foo
}
obj.foo()

const c = new foo()
```

- 对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window。
- 对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象。
- 对于 new 的方式来说，this 被永远绑定在了 c 上面，不会被任何方式改变 this。

箭头函数其实是没有 this 的，箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this。

最后种情况也就是 bind 这些改变上下文的 API 了，对于这些函数来说，this 取决于第一个参数，如果第一个参数为空，那么就是 window。

可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高的来决定 this 最终指向哪里。首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。

# 第 3 节 JS 基础知识点及常考面试题（二）

## 3.1 ==vs===

对于`==`来说，如果对比双方的类型不一样的话，就会进行类型转换。

- 首先判断两者类型是否相同，相同的话就是比较大小
- 类型不相同的话进行类型转换
- 会先判断是否在对比`null`和`undefined`，是的话就会返回 true
- 判断两者类型是否为`string`和`number`，是的话就会将字符串转换为`number`
- 判断其中一方是否为`boolean`，是的话就会把`boolean`转为`number`再进行判断
- 判断其中一方是否为`object`且另一方为`string`、`number`或者`sybol`，是的话就会把`object`转为原始类型再进行判断

对于`===`来说就简单多了，就是判断两者类型和值是否相同。

## 3.2 闭包

闭包的定义很简单：函数 A 内部有一个函数 B，函数 B 可以访问函数 A 中的变量，那么函数 B 就是闭包。说闭包是函数嵌套函数，然后返回一个函数的解释，是不完整的。

首先因为 setTimeout 是个异步函数，所以会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。

```JavaScript
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i * 1000)
}
// 6 6 6 6 6
```

解决办法有是三种，第一种是使用闭包的方式。首先使用立即执行函数将 i 传入函数内部，这个时候就被固定在了参数 j 上面不会改变，当下次执行 timer 这个闭包的时候，就可以使用外部函数的变量 j，从而达到目的。

```JavaScript
for (var i = 1; i <= 5; i++) {
  ;(function(j) {
    setTimeout(function timer() {
      console.log(j)
    }, j * 1000)
  })(i)
}
```

第二种就是使用 setTimeout 的第三个参数，这个参数会被当成 timer 函数的参数传入。

```JavaScript
for (var i = 1; i <= 5; i++) {
  setTimeout(
    function timer(j) {
      console.log(j)
    },
    i * 1000,
    i
  )
}
```

第三种就是使用 let 定义 i 了来解决问题了，这个也是最为推荐的方式。

```JavaScript
for (let i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i * 1000)
}
```

## 3.3 深浅拷贝

对象类型在赋值的过程中其实是复制了地址，从而会导致改变了一方其他也都被改变的情况。通常在开发中不希望出现这样的问题，那么可以使用浅拷贝来解决这个情况。

浅拷贝。`Object.assign`只会拷贝所有的属性值到新的对象中，如果属性值时对象的话，拷贝的是地址，所以并不是深拷贝。

```JavaScript
let a = {
  age: 1
}
let b = Object.assign({}, a)
a.age = 2
console.log(b.age) // 1
```

另外还可以通过展开运算符`...`来实现浅拷贝。

```JavaScript
let a = {
  age: 1
}
let b = { ...a }
a.age = 2
console.log(b.age) // 1
```

通常浅拷贝就能解决大部分问题了，但是浅拷贝只解决了第一层的问题，如果接下去的值还有对象的话，那么两者就享有相同的地址了。要解决这个问题，就得使用深拷贝。

深拷贝通常可以通过`JSON.parse(JSON.stringify(object))`来解决。

```JavaScript
let a = {
  age: 1,
  jobs: {
    first: 'FE'
  }
}
let b = JSON.parse(JSON.stringify(a))
a.jobs.first = 'native'
console.log(b.jobs.first) // FE
```

但是该方法也是有局限性的。这样会忽略 undefined、symbol、不能序列化函数和不能解决循环引用的对象。因此如果所需拷贝的对象含有内置类型并且不包含函数，可以使用 MessageChannel。

```JavaScript
function structuralClone(obj) {
  return new Promise(resolve => {
    const { port1, port2 } = new MessageChannel()
    port2.onmessage = ev => resolve(ev.data)
    port1.postMessage(obj)
  })
}
var obj = {
  a: 1,
  b: {
    c: 2
  }
}
obj.b.d = obj.b
// 注意该方法是异步的
// 可以处理 undefined 和循环引用对象
const test = async () => {
  const clone = await structuralClone(obj)
  console.log(clone)
}
test()
```

## 3.4 原型

当创建一个对象时`let obj = { age: 25 }`，可以发现能使用很多函数。其实每个 JS 对象都有`_proto_`属性，这个属性指向了原型。这个属性现在来说已经不推荐直接去使用它了，这只是浏览器在早期为了让我们访问内部属性`[[prototype]]`来实现的一个东西。

原型也是一个对象，并且这个对象中包含了很多函数，所以我们可以得出一个结论：对于 obj 来说，可以通过 `__proto__` 找到一个原型对象，在该对象中定义了很多函数让我们来使用。

原型的 constructor 属性指向构造函数，构造函数又通过 prototype 属性指回原型，但是并不是所有函数都具有这个属性，`Function.prototype.bind()` 就没有这个属性。

原型链就是多个对象通过`_proto_`的方式连接起来。

总结

- Object 是所有对象的爸爸，所有对象都可以通过 `__proto__` 找到它
- Function 是所有函数的爸爸，所有函数都可以通过 `__proto__` 找到它
- 函数的 prototype 是一个对象
- 对象的 `__proto__` 属性指向原型， `__proto__` 将对象和原型连接起来组成了原型链

# 第 4 节 ES6 知识点及常考面试题

## 4.1 var、let 及 const 区别

var 声明的变量会发生提升的情况，并且提升的是声明。使用 var 声明的变量会被提升到作用域的顶部。

```JavaScript
var a
console.log(a) // undefined
a = 1
```

同时，不仅变量会提升，函数也会被提升。并且，函数声明会优先于变量提升。

```JavaScript
console.log(a) // ƒ a() {}
function a() {}
var a = 1
```

let 和 const。首先在全局作用域下使用 let 和 const 声明变量，变量并不会被挂在到 window 上，这一点就和 var 声明有了区别。

```JavaScript
var a = 1
let b = 1
const c = 1
console.log(window.b) // undefined
console.log(window. c) // undefined

function test(){
  console.log(a)
  let a
}
test()
```

上面代码会出现报错的情况。报错的原因是因为存在暂时性死区，我们不能在声明前就使用变量，这也是 let 和 const 优于 var 的一点。

那么为什么要存在提升这个事情呢，其实提升存在的根本原因就是为了解决函数间互相调用的情况。

```JavaScript
function test1() {
    test2()
}
function test2() {
    test1()
}
test1()
```

## 4.2 原型继承和 Class 继承

其实在 JS 中并不存在类，class 只是语法糖，本质还是函数。

```JavaScript
class Person {}
Person instanceof Function // true
```

组合继承。组合继承是最常用的继承方式。

```JavaScript
function Parent(value) {
  this.val = value
}
Parent.prototype.getValue = function() {
  console.log(this.val)
}
function Child(value) {
  Parent.call(this, value)
}
Child.prototype = new Parent()

const child = new Child(1)

child.getValue() // 1
child instanceof Parent // true
```

以上继承的方式核心是在子类的构造函数中通过`Parent.call(this)`继承父类的属性，然后改变子类的原型为`new Parent()`来继承父类的函数。这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费。

寄生组合继承。这种继承方式对组合继承进行了优化，组合继承缺点在于继承父类函数时调用了构造函数，我们只需要优化掉这点就行了。

```JavaScript
function Parent(value) {
  this.val = value
}
Parent.prototype.getValue = function() {
  console.log(this.val)
}

function Child(value) {
  Parent.call(this, value)
}
Child.prototype = Object.create(Parent.prototype, {
  constructor: {
    value: Child,
    enumerable: false,
    writable: true,
    configurable: true
  }
})

const child = new Child(1)

child.getValue() // 1
child instanceof Parent // true
```

以上继承实现的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。

Class 继承。以上两种继承方式都是通过原型去解决的，在 ES6 中，可以使用 class 去实现继承。

```JavaScript
class Parent {
  constructor(value) {
    this.val = value
  }
  getValue() {
    console.log(this.val)
  }
}
class Child extends Parent {
  constructor(value) {
    super(value)
    this.val = value
  }
}
let child = new Child(1)
child.getValue() // 1
child instanceof Parent // true
```

class 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super，因为这段代码可以看成 Parent.call(this, value)。

## 4.3 模块化

模块化。模块化可以有解决命名冲突、提供复用性和提高代码可维护性的作用。

立即执行函数。在早期，使用立即执行函数实现模块化是最常见的手段，通过函数作用域解决了命名冲突、污染全局作用域的问题。

```JavaScript
(function(globalVariable){
   globalVariable.test = function() {}
   // ... 声明各种变量、函数都不会污染全局作用域
})(globalVariable)
```

AMD 和 CMD。鉴于目前这两种实现方式已经很少见到，所以不再对具体特性细聊，只需要了解这两者是如何使用的。

```JavaScript
// AMD
define(['./a', './b'], function(a, b) {
  // 加载模块完毕可以使用
  a.do()
  b.do()
})
// CMD
define(function(require, exports, module) {
  // 加载模块
  // 可以把 require 写在函数体的任意地方实现延迟加载
  var a = require('./a')
  a.doSomething()
})
```

CommonJS。CommonJS 最早是 Node 在使用，目前也仍然广泛使用，比如在 Webpack 中就能见到。当然目前在 Node 中的模块管理已经和 CommonJS 有一些区别了。

```JavaScript
// a.js
module.exports = {
    a: 1
}
// or
exports.a = 1

// b.js
var module = require('./a.js')
module.a // -> log 1
```

另外虽然 exports 和 module.exports 用法相似，但是不能对 exports 直接赋值。因为 var exports = module.exports 这句代码表明了 exports 和 module.exports 享有相同地址，通过改变对象的属性值会对两者都起效，但是如果直接对 exports 赋值就会导致两者不再指向同一个内存地址，修改并不会对 module.exports 起效。

ES Module。ES Module 是原生实现的模块化方案，与 CommonJS 有以下几个区别。

- CommonJS 支持动态导入，也就是 require(\${path}/xx.js)，后者目前不支持，但是已有提案
- CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响
- CommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化
- ES Module 会编译成 require/exports 来执行的

```JavaScript
// 引入模块 API
import XXX from './a.js'
import { XXX } from './a.js'
// 导出模块 API
export function a() {}
export default function() {}
```

## 4.4 Proxy

在 Vue3.0 中将会通过 Proxy 来替换原本的 Object.defineProperty 来实现数据响应式。Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。

```JavaScript
let p = new Proxy(target, handler)
```

target 代表需要添加代理的对象，handler 用来自定义对象中的操作，比如可以用来自定义 set 或者 get 函数。

```JavaScript
let onWatch = (obj, setBind, getLogger) => {
  let handler = {
    get(target, property, receiver) {
      getLogger(target, property)
      return Reflect.get(target, property, receiver)
    },
    set(target, property, value, receiver) {
      setBind(value, property)
      return Reflect.set(target, property, value)
    }
  }
  return new Proxy(obj, handler)
}

let obj = { a: 1 }
let p = onWatch(
  obj,
  (v, property) => {
    console.log(`监听到属性${property}改变为${v}`)
  },
  (target, property) => {
    console.log(`'${property}' = ${target[property]}`)
  }
)
p.a = 2 // 监听到属性a改变
p.a // 'a' = 2
```

之所以 Vue3.0 要使用 Proxy 替换原本的 API 原因在于 Proxy 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变，唯一缺陷可能就是浏览器的兼容性不好了。

## 4.5 map，filter，reduce

map 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后放入到新的数组中。另外 map 的回调函数接受三个参数，分别是当前索引元素，索引，原数组。

```JavaScript
[1, 2, 3].map(v => v + 1) // -> [2, 3, 4]
```

filter 的作用也是生成一个新数组，在遍历数组的时候将返回值为 true 的元素放入新数组，我们可以利用这个函数删除一些不需要的元素。和 map 一样，filter 的回调函数也接受三个参数，用处也相同。

```JavaScript
let array = [1, 2, 4, 6]
let newArray = array.filter(item => item !== 6)
console.log(newArray) // [1, 2, 4]
```

reduce 可以将数组中的元素通过回调函数最终转换为一个值。

```JavaScript
const arr = [1, 2, 3]
const sum = arr.reduce((acc, current) => acc + current, 0)
console.log(sum)
```

使用 reduce 还可以实现很多功能，例如通过 reduce 可以实现 map 函数。

```JavaScript
const arr = [1, 2, 3]
const mapArray = arr.map(value => value * 2)
const reduceArray = arr.reduce((acc, current) => {
  acc.push(current * 2)
  return acc
}, [])
console.log(mapArray, reduceArray) // [2, 4, 6]
```

# 第 5 节 JS 异步编程及常考面试题

## 5.1 并发（concurrency）和并行（parallelism）区别

并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。

并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。

## 5.2 回调函数（Callback）

回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）。假设多个请求存在依赖性，你可能就会写出如下代码。以上代码看起来不利于阅读和维护。

```JavaScript
ajax(url, () => {
    // 处理逻辑
    ajax(url1, () => {
        // 处理逻辑
        ajax(url2, () => {
            // 处理逻辑
        })
    })
})
```

回调地狱的根本问题就是：

- 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身
- 嵌套函数一多，就很难处理错误
  当然，回调函数还存在着别的几个缺点，比如不能使用 try catch 捕获错误，不能直接 return。

## 5.3 Generator

Generator 最大的特点就是可以控制函数的执行。Generator 函数一般见到的不多，其实也于他有点绕有关系，并且一般会配合 co 库去使用。当然，我们可以通过 Generator 函数解决回调地狱的问题，可以把之前的回调地狱例子改写为如下代码：

```JavaScript
function *fetch() {
    yield ajax(url, () => {})
    yield ajax(url1, () => {})
    yield ajax(url2, () => {})
}
let it = fetch()
let result1 = it.next()
let result2 = it.next()
let result3 = it.next()
```

## 5.4 Promise

Promise 翻译过来就是承诺的意思，这个承诺会在未来有一个确切的答复，并且该承诺有三种状态，分别是：

- 等待中（pending）
- 完成了 （resolved）
- 拒绝了（rejected）

这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了，也就是说一旦状态变为 resolved 后，就不能再次改变

```JavaScript
new Promise((resolve, reject) => {
  resolve('success')
  // 无效
  reject('reject')
})
```

当我们在构造 Promise 的时候，构造函数内部的代码是立即执行的。

```JavaScript
new Promise((resolve, reject) => {
  console.log('new Promise')
  resolve('success')
})
console.log('finifsh')
// new Promise -> finifsh
```

Promise 实现了链式调用，也就是说每次调用 then 之后返回的都是一个 Promise，并且是一个全新的 Promise，原因也是因为状态不可变。如果你在 then 中使用了 return，那么 return 的值会被 Promise.resolve() 包装。

```JavaScript
Promise.resolve(1)
  .then(res => {
    console.log(res) // => 1
    return 2 // 包装成 Promise.resolve(2)
  })
  .then(res => {
    console.log(res) // => 2
  })
```

当然了，Promise 也很好地解决了回调地狱的问题，可以把之前的回调地狱例子改写为如下代码：

```JavaScript
ajax(url)
  .then(res => {
      console.log(res)
      return ajax(url1)
  }).then(res => {
      console.log(res)
      return ajax(url2)
  }).then(res => console.log(res))
```

Promise 也是存在一些缺点的，比如无法取消 Promise，错误需要通过回调函数捕获。

## 5.5 async 及 await

一个函数如果加上 async，那么该函数就会返回一个 Promise。

```JavaScript
async function test() {
  return "1"
}
console.log(test()) // -> Promise {<resolved>: "1"}
```

async 就是将函数返回值使用 Promise.resolve() 包裹，和 then 中处理返回值一样，并且 await 只能配套 async 使用。

```JavaScript
async function test() {
  let value = await sleep()
}
```

async 和 await 可以说是异步终极解决方案了，相比直接使用 Promise 来说，优势在于处理 then 的调用链，能够更清晰准确的写出代码，毕竟写一大堆 then 也很恶心，并且也能优雅地解决回调地狱问题。当然也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。

```JavaScript
let a = 0
let b = async () => {
  a = a + await 10
  console.log('2', a) // -> '2' 10
}
b()
a++
console.log('1', a) // -> '1' 1
```

上述解释中提到了 await 内部实现了 generator，其实 await 就是 generator 加上 Promise 的语法糖，且内部实现了自动执行 generator。

## 5.6 常用定时器函数

异步编程当然少不了定时器了，常见的定时器函数有 setTimeout、setInterval、RequestAnimationFrame。

很多人认为 setTimeout 是延时多久，那就应该是多久后执行。其实这个观点是错误的，因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 setTimeout 不会按期执行。当然了，我们可以通过代码去修正 setTimeout，从而使定时器相对准确。

setInterval 这个函数作用和 setTimeout 基本一致，只是该函数是每隔一段时间执行一次回调函数。通常来说不建议使用 setInterval。第一，它和 setTimeout 一样，不能保证在预期的时间执行任务。第二，它存在执行累积的问题。

```JavaScript
function demo() {
  setInterval(function(){
    console.log(2)
  },1000)
  sleep(2000)
}
demo()
```

以上代码在浏览器环境中，如果定时器执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题。

如果你有循环定时器的需求，其实完全可以通过 requestAnimationFrame 来实现。首先 requestAnimationFrame 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题，当然你也可以通过该函数来实现 setTimeout。

```JavaScript
function setInterval(callback, interval) {
  let timer
  const now = Date.now
  let startTime = now()
  let endTime = startTime
  const loop = () => {
    timer = window.requestAnimationFrame(loop)
    endTime = now()
    if (endTime - startTime >= interval) {
      startTime = endTime = now()
      callback(timer)
    }
  }
  timer = window.requestAnimationFrame(loop)
  return timer
}

let a = 0
setInterval(timer => {
  console.log(1)
  a++
  if (a === 3) cancelAnimationFrame(timer)
}, 1000)
```

# 第 6 节 手写 Promise

## 6.1 实现一个简易版 Promise

首先创建了三个常量用于表示状态，对于经常使用的一些值都应该通过常量来管理，便于开发及后期维护。然后，在函数体内部首先创建了常量 that，因为代码可能会异步执行，用于获取正确的 this 对象。一开始 Promise 的状态应该是 pending，value 变量用于保存 resolve 或者 reject 中传入的值。resolvedCallbacks 和 RejectedCallbacks 用于保存 then 中的回调，因为当执行完 Promise 时状态可能还是等待中，这时候应该把 then 中的回调保存起来用于状态改变时使用。

```JavaScript
const PENDING = 'pending'
const RESOLVED = 'resolved'
const REJECTED = 'rejected'

function MyPromise(fn) {
  const that = this
  that.state = PENDING
  that.value = null
  that.resolvedCallbacks = []
  that.rejectedCallbacks = []
  // 待完善 resolve 和 reject 函数
  // 待完善执行 fn 函数
}
```

接下来完善 resolve 和 reject 函数，添加在 MyPromise 函数体内部。首先两个函数都得判断当前状态是否为等待中，因为规范规定只有等待态才可以改变状态。然后，将当前状态更改为对应状态，并且将传入的值赋值给 value。最后，通过遍历回调数组并执行。

```JavaScript
function resolve(value) {
  if (that.state === PENDING) {
    that.state = RESOLVED
    that.value = value
    that.resolvedCallbacks.map(cb => cb(that.value))
  }
}

function reject(value) {
  if (that.state === PENDING) {
    that.state = REJECTED
    that.value = value
    that.rejectedCallbacks.map(cb => cb(that.value))
  }
}
```

完成以上两个函数以后，就该实现如何执行 Promise 中传入的函数了。实现很简单，执行传入的参数并且将之前两个函数当作参数传进去。要注意的是，可能执行函数过程中会遇到错误，需要捕获错误并且执行 reject 函数。

```JavaScript
try {
  fn(resolve, reject)
} catch (e) {
  reject(e)
}
```

最后实现较为复杂的 then 函数。首先判断两个参数是否为函数类型，因为这两个参数是可选参数。当参数不是函数类型，需要创建一个函数赋值给相应的参数，同时也实现了透传。接下来就是一系列判断状态的逻辑，当状态不是等待态时，就去执行相应的函数。如果状态是等待态的话，就往回调函数中 push 函数。

```JavaScript
MyPromise.prototype.then = function(onFulfilled, onRejected) {
  const that = this
  onFulfilled =
    typeof onFulfilled === 'function'
    ? onFulfilled : v => v
  onRejected =
    typeof onRejected === 'function'
      ? onRejected
      : r => {
          throw r
        }
  if (that.state === PENDING) {
    that.resolvedCallbacks.push(onFulfilled)
    that.rejectedCallbacks.push(onRejected)
  }
  if (that.state === RESOLVED) {
    onFulfilled(that.value)
  }
  if (that.state === REJECTED) {
    onRejected(that.value)
  }
}
```

## 6.2 实现一个符合 Promise/A+ 规范的 Promise

改造 resolve 和 reject 函数。对于 resolve 函数来说，首先需要判断传入的值是否为 Promise 类型。为了保证函数执行顺序，需要将两个函数体代码使用 setTimeout 包裹起来。

```JavaScript
function resolve(value) {
  if (value instanceof MyPromise) {
    return value.then(resolve, reject)
  }
  setTimeout(() => {
    if (that.state === PENDING) {
      that.state = RESOLVED
      that.value = value
      that.resolvedCallbacks.map(cb => cb(that.value))
    }
  }, 0)
}
function reject(value) {
  setTimeout(() => {
    if (that.state === PENDING) {
      that.state = REJECTED
      that.value = value
      that.rejectedCallbacks.map(cb => cb(that.value))
    }
  }, 0)
}
```

接下来继续改造 then 函数中的代码，首先需要新增一个变量 Promise2，因为每个 then 函数都需要返回一个新的 Promise 对象，该变量用于保存新的返回对象，然后先来改造判断等待态的逻辑。

首先返回一个新的 Promise 对象，并在 Promise 中传入了一个函数。函数的基本逻辑还是和之前一样，往回调数组中 push 函数。同样，在执行函数的过程中可能会遇到错误，所以使用了 try...catch 包裹。规范规定，执行 onFulfilled 或者 onRejected 函数时会返回一个 x，并且执行 Promise 解决过程，这是为了不同的 Promise 都可以兼容使用，比如 JQuery 的 Promise 能兼容 ES6 的 Promise。

```JavaScript
if (that.state === PENDING) {
  return (promise2 = new MyPromise((resolve, reject) => {
    that.resolvedCallbacks.push(() => {
      try {
        const x = onFulfilled(that.value)
        resolutionProcedure(promise2, x, resolve, reject)
      } catch (r) {
        reject(r)
      }
    })

    that.rejectedCallbacks.push(() => {
      try {
        const x = onRejected(that.value)
        resolutionProcedure(promise2, x, resolve, reject)
      } catch (r) {
        reject(r)
      }
    })
  }))
}
```

接下来改造判断执行态的逻辑。这段代码和判断等待态的逻辑基本一致，无非是传入的函数的函数体需要异步执行，这也是规范规定的。

```JavaScript
if (that.state === RESOLVED) {
  return (promise2 = new MyPromise((resolve, reject) => {
    setTimeout(() => {
      try {
        const x = onFulfilled(that.value)
        resolutionProcedure(promise2, x, resolve, reject)
      } catch (reason) {
        reject(reason)
      }
    })
  }))
}
```

实现兼容多种 Promise 的 resolutionProcedure 函数。

```JavaScript
function resolutionProcedure(promise2, x, resolve, reject) {
  if (promise2 === x) {
    return reject(new TypeError('Error'))
  }
}
```

然后需要判断 x 的类型。这里的代码是完全按照规范实现的。如果 x 为 Promise 的话，需要判断以下几个情况。

- 如果 x 处于等待态，Promise 需保持为等待态直至 x 被执行或拒绝
- 如果 x 处于其他状态，则用相同的值处理 Promise

```JavaScript
if (x instanceof MyPromise) {
    x.then(function(value) {
        resolutionProcedure(promise2, value, resolve, reject)
    }, reject)
}
```

接下来继续按照规范来实现剩余的代码。首先创建一个变量 called 用于判断是否已经调用过函数，然后判断 x 是否为对象或者函数，如果都不是的话，将 x 传入 resolve 中。如果 x 是对象或者函数的话，先把 x.then 赋值给 then，然后判断 then 的类型，如果不是函数类型的话，就将 x 传入 resolve 中。如果 then 是函数类型的话，就将 x 作为函数的作用域 this 调用之，并且传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise，两个回调函数都需要判断是否已经执行过函数，然后进行相应的逻辑。以上代码在执行的过程中如果抛错了，将错误传入 reject 函数中。

```JavaScript
let called = false
if (x !== null && (typeof x === 'object' || typeof x === 'function')) {
  try {
    let then = x.then
    if (typeof then === 'function') {
      then.call(
        x,
        y => {
          if (called) return
          called = true
          resolutionProcedure(promise2, y, resolve, reject)
        },
        e => {
          if (called) return
          called = true
          reject(e)
        }
      )
    } else {
      resolve(x)
    }
  } catch (e) {
    if (called) return
    called = true
    reject(e)
  }
} else {
  resolve(x)
}
```

# 第 7 节 Event Loop

## 7.1 进程与线程

进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。线程是进程中的更小单位，描述了执行一段指令所需的时间。

把这些概念拿到浏览器中来说，当打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁。

## 7.2 执行栈

可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。

当我们使用递归的时候，因为栈可存放的函数是有限制的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题。

```JavaScript
function bar() {
  bar()
}
bar()
// Uncaught RangeError: Maximum call stack size exceeded
```

## 7.3 浏览器中的 Event Loop

当执行 JS 代码的时候其实就是往执行栈中放入函数，当遇到异步的代码时，会被挂起并在需要执行的时候加入到 Task（有多种 Task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。

不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。

所以 Event Loop 执行顺序如下所示：

- 首先执行同步代码，这属于宏任务
- 当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行
- 执行所有微任务
- 当执行完所有微任务后，如有必要会渲染页面
- 然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数

## 7.4 Node 中的 Event Loop

Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node 的 Event Loop 分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。

# 第 8 节 JS 进阶知识点及常考面试题

## 8.1 手写 call、apply 及 bind 函数

考虑如何实现这几个函数

- 不传入第一个参数，那么上下文默认为 window
- 改变了 this 指向，让新的对象可以执行该函数，并能接受参数

实现 call

```JavaScript
Function.prototype.myCall = function(context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  context = context || window
  context.fn = this
  const args = [...arguments].slice(1)
  const result = context.fn(...args)
  delete context.fn
  return result
}
```

实现 apply

```JavaScript
Function.prototype.myApply = function(context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  context = context || window
  context.fn = this
  let result
  // 处理参数和 call 有区别
  if (arguments[1]) {
    result = context.fn(...arguments[1])
  } else {
    result = context.fn()
  }
  delete context.fn
  return result
}
```

实现 bind

```JavaScript
Function.prototype.myBind = function (context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  const _this = this
  const args = [...arguments].slice(1)
  // 返回一个函数
  return function F() {
    // 因为返回了一个函数，我们可以 new F()，所以需要判断
    if (this instanceof F) {
      return new _this(...args, ...arguments)
    }
    return _this.apply(context, args.concat(...arguments))
  }
}
```

## 8.2 new

在调用 new 的过程中会发生以上四件事情：

- 新生成了一个对象
- 链接到原型
- 绑定 this
- 返回新对象

```JavaScript
function create() {
  let obj = {}
  let Con = [].shift.call(arguments)
  obj.__proto__ = Con.prototype
  let result = Con.apply(obj, arguments)
  return result instanceof Object ? result : obj
}
```

## 8.3 instanceof 的原理

instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。

```JavaScript
function myInstanceof(left, right) {
  let prototype = right.prototype
  left = left.__proto__
  while (true) {
    if (left === null || left === undefined)
      return false
    if (prototype === left)
      return true
    left = left.__proto__
  }
}
```

## 8.4 为什么 0.1 + 0.2 != 0.3

因为 JS 采用 IEEE 754 双精度版本（64位），并且只要采用 IEEE 754 的语言都有该问题。

IEEE 754 双精度版本（64位）将 64 位分为了三段

- 第一位用来表示符号
- 接下去的 11 位用来表示指数
- 其他的位数用来表示有效位，也就是用二进制表示 0.1 中的 10011(0011)

那么这些循环的数字被裁剪了，就会出现精度丢失的问题，也就造成了 0.1 不再是 0.1 了，而是变成了 0.100000000000000002

既然 0.1 不是 0.1，那为什么 console.log(0.1) 却是正确的呢？

因为在输入内容的时候，二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程，所以打印出来的其实是一个近似值。

其实解决的办法有很多，这里我们选用原生提供的方式来最简单的解决问题

```JavaScript
parseFloat((0.1 + 0.2).toFixed(10)) === 0.3 // true
```

## 8.5 垃圾回收机制

V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。

新生代算法
老生代算法

# 第 9 节 JS 思考题

## 9.1 思考题一

JS 分为哪两大类型？都有什么各自的特点？你该如何判断正确的类型？

对于原始类型来说，你可以指出 null 和 number 存在的一些问题。对于对象类型来说，你可以从垃圾回收的角度去切入，也可以说一下对象类型存在深浅拷贝的问题。

对于判断类型来说，你可以去对比一下 typeof 和 instanceof 之间的区别，也可以指出 instanceof 判断类型也不是完全准确的。

## 9.2 思考题二

你理解的原型是什么？

起码说出原型小节中的总结内容，然后还可以指出一些小点，比如并不是所有函数都有 prototype 属性，然后引申出原型链的概念，提出如何使用原型实现继承，继而可以引申出 ES6 中的 class 实现继承。

## 9.3 思考题三

bind、call 和 apply 各自有什么区别？

首先肯定是说出三者的不同，如果自己实现过其中的函数，可以尝试说出自己的思路。然后可以聊一聊 this 的内容，有几种规则判断 this 到底是什么，this 规则会涉及到 new，那么最后可以说下自己对于 new 的理解。

## 9.4 思考题四

思考题四：ES6 中有使用过什么？

这边可说的实在太多，你可以列举 1 - 2 个点。比如说说 class，那么 class 又可以拉回到原型的问题；可以说说 promise，那么线就被拉到了异步的内容；可以说说 proxy，那么如果你使用过 Vue 这个框架，就可以谈谈响应式原理的内容；同样也可以说说 let 这些声明变量的语法，那么就可以谈及与 var 的不同，说到提升这块的内容。

## 9.5 思考题五

思考题五：JS 是如何运行的？

这其实是很大的一块内容。你可以先说 JS 是单线程运行的，这里就可以说说你理解的线程和进程的区别。然后讲到执行栈，接下来的内容就是涉及 Eventloop 了，微任务和宏任务的区别，哪些是微任务，哪些又是宏任务，还可以谈及浏览器和 Node 中的 Eventloop 的不同，最后还可以聊一聊 JS 中的垃圾回收。

# 第 10 节 DevTools Tips

# 第 11 节 浏览器基础知识点及常考面试题

# 第 12 节 浏览器缓存机制

# 第 13 节 浏览器渲染原理

# 第 14 节 安全防范知识点

# 第 15 节 从 V8 中看 JS 性能优化

# 第 16 节 性能优化琐碎事

# 第 17 节 Webpack 性能优化

# 第 18 节 实现小型打包工具

# 第 19 节 React 和 Vue 两大框架之间的相爱相杀

# 第 20 节 Vue 常考基础知识点

# 第 21 节 Vue 常考进阶知识点

# 第 22 节 React 常考基础知识点

# 第 23 节 React 常考进阶知识点

# 第 24 节 监控

# 第 25 节 UDP

# 第 26 节 TCP

# 第 27 节 HTTP 及 TLS

# 第 28 节 HTTP/2 及 HTTP/3

# 第 29 节 输入 URL 到页面渲染的整个流程

# 第 30 节 设计模式

# 第 31 节 常见数据结构

# 第 32 节 常考算法题解析

# 第 33 节 CSS 常考面试题资料

# 第 34 节 如何写好一封简历

# 第 35 节 面试常用技巧

# 第 36 节 前方的路，让我们结伴同行
