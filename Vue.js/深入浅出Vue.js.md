> 深入浅出Vue.js  
> 作者: 刘博文  
# > 2019年 3 月第1版   

# 第1章　Vue.js简介
1.1　什么是Vue.js
1.2　Vue.js简史
# 第一篇　变化侦测
# 第2章　Object的变化侦测
2.1　什么是变化侦测
2.2　如何追踪变化
2.3　如何收集依赖
2.4　依赖收集在哪里
2.5　依赖是谁
2.6　什么是Watcher
2.7　递归侦测所有key
2.8　关于Object的问题
2.9　总结
# 第3章　Array的变化侦测
3.1　如何追踪变化
3.2　拦截器
3.3　使用拦截器覆盖Array原型
3.4　将拦截器方法挂载到数组的属性上
3.5　如何收集依赖
3.6　依赖列表存在哪儿
3.7　收集依赖
3.8　在拦截器中获取Observer实例
3.9　向数组的依赖发送通知
3.10　侦测数组中元素的变化
3.11　侦测新增元素的变化
3.11.1　获取新增元素
3.11.2　使用Observer侦测新增元素
3.12　关于Array的问题
3.13　总结
# 第4章　变化侦测相关的API实现原理
4.1　vm.$watch
4.1.1　用法
4.1.2　watch的内部原理
4.1.3　deep参数的实现原理
4.2　vm.$set
4.2.1　用法
4.2.2　Array的处理
4.2.3　key已经存在于target中
4.2.4　处理新增的属性
4.3　vm.$delete
4.3.1　用法
4.3.2　实现原理
4.4　总结
# 第二篇　虚拟DOM
# 第5章　虚拟DOM简介
5.1　什么是虚拟DOM
5.2　为什么要引入虚拟DOM
5.3　Vue.js中的虚拟DOM
5.4　总结
# 第6章　VNode
6.1　什么是VNode
6.2　VNode的作用
6.3　VNode的类型
6.3.1　注释节点
6.3.2　文本节点
6.3.3　克隆节点
6.3.4　元素节点
6.3.5　组件节点
6.3.6　函数式组件
6.4　总结
# 第7章　patch
7.1　patch介绍
7.1.1　新增节点
7.1.2　删除节点
7.1.3　更新节点
7.1.4　小结
7.2　创建节点
7.3　删除节点
7.4　更新节点
7.4.1　静态节点
7.4.2　新虚拟节点有文本属性
7.4.3　新虚拟节点无文本属性
7.4.4　小结
7.5　更新子节点
7.5.1　更新策略
7.5.2　优化策略
7.5.3　哪些节点是未处理过的
7.5.4　小结
7.6　总结
# 第三篇　模板编译原理
# 第8章　模板编译
8.1　概念
8.2　将模板编译成渲染函数
8.2.1　解析器
8.2.2　优化器
8.2.3　代码生成器
8.3　总结
# 第9章　解析器
9.1　解析器的作用
9.2　解析器内部运行原理
9.3　HTML解析器
9.3.1　运行原理
9.3.2　截取开始标签
9.3.3　截取结束标签
9.3.4　截取注释
9.3.5　截取条件注释
9.3.6　截取DOCTYPE
9.3.7　截取文本
9.3.8　纯文本内容元素的处理
9.3.9　使用栈维护DOM层级
9.3.10　整体逻辑
9.4　文本解析器
9.5　总结
# 第10章　优化器
10.1　找出所有静态节点并标记
10.2　找出所有静态根节点并标记
10.3　总结
# 第11章　代码生成器
11.1　通过AST生成代码字符串
11.2　代码生成器的原理
11.2.1　元素节点
11.2.2　文本节点
11.2.3　注释节点
11.3　总结
# 第四篇　整体流程
# 第12章　架构设计与项目结构
12.1　目录结构
12.2　架构设计
12.3　总结
# 第13章　实例方法与全局API的实现原理
13.1　数据相关的实例方法
13.2　事件相关的实例方法
13.2.1　vm.$on
13.2.2　vm.$off
13.2.3　vm.$once
13.2.4　vm.$emit
13.3　生命周期相关的实例方法
13.3.1　vm.$forceUpdate
13.3.2　vm.$destroy
13.3.3　vm.$nextTick
13.3.4　vm.$mount
13.4　全局API的实现原理
13.4.1　Vue.extend
13.4.2　Vue.nextTick
13.4.3　Vue.set
13.4.4　Vue.delete
13.4.5　Vue.directive
13.4.6　Vue.filter
13.4.7　Vue.component
13.4.8　Vue.use
13.4.9　Vue.mixin
13.4.10　Vue.compile
13.4.11　Vue.version
13.5　总结
# 第14章　生命周期
14.1　生命周期图示
14.1.1　初始化阶段
14.1.2　模板编译阶段
14.1.3　挂载阶段
14.1.4　卸载阶段
14.1.5　小结
14.2　从源码角度了解生命周期
14.3　errorCaptured与错误处理
14.4　初始化实例属性
14.5　初始化事件
14.6　初始化inject
14.6.1　provide/inject的使用方式
14.6.2　inject的内部原理
14.7　初始化状态
14.7.1　初始化props
14.7.2　初始化methods
14.7.3　初始化data
14.7.4　初始化computed
14.7.5　初始化watch
14.8　初始化provide
14.9　总结
# 第15章　指令的奥秘
15.1　指令原理概述
15.1.1　v-if指令的原理概述
15.1.2　v-for指令的原理概述
15.1.3　v-on指令
15.2　自定义指令的内部原理
15.3　虚拟DOM钩子函数
15.4　总结
# 第16章　过滤器的奥秘
16.1　过滤器原理概述
16.1.1　串联过滤器
16.1.2　滤器接收参数
16.1.3　resolveFilter的内部原理
16.2　解析过滤器
16.3　总结
# 第17章　最佳实践
17.1　为列表渲染设置属性key
17.2　在v-if/v-if-else/v-else中使用key
17.3　路由切换组件不变
17.3.1　路由导航守卫beforeRouteUpdate
17.3.2　观察 $route对象的变化
17.3.3　为router-view组件添加属性key
17.4　为所有路由统一添加query
17.4.1　使用全局守卫beforeEach
17.4.2　使用函数劫持
17.5　区分Vuex与props的使用边界
17.6　避免v-if和v-for一起使用
17.7　为组件样式设置作用域
17.8　避免在scoped中使用元素选择器
17.9　避免隐性的父子组件通信
17.10　单文件组件如何命名
17.10.1　单文件组件的文件名的大小写
17.10.2　基础组件名
17.10.3　单例组件名
17.10.4　紧密耦合的组件名
17.10.5　组件名中的单词顺序
17.10.6　完整单词的组件名
17.10.7　组件名为多个单词
17.10.8　模板中的组件名大小写
17.10.9　JS/JSX中的组件名大小写
17.11　自闭合组件
17.12　prop名的大小写
17.13　多个特性的元素
17.14　模板中简单的表达式
17.15　简单的计算属性
17.16　指令缩写
17.17　良好的代码顺序
17.17.1　组件/实例的选项的顺序
17.17.2　元素特性的顺序
17.17.3　单文件组件顶级元素的顺序
17.18　总结