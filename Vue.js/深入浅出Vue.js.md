> 深入浅出 Vue.js  
> 作者: 刘博文  
> 2019 年 3 月第 1 版

# 第 1 章 Vue.js 简介

1.1 什么是 Vue.js
1.2 Vue.js 简史

# 第一篇 变化侦测

> Vue.js 最独特的特性之一是看起来并不显眼的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。这使得状态管理非常简单、直接。不过理解其工作原理同样重要，这样你可以回进一些常见的问题。——官方文档

从状态生成 DOM,再输出到用户界面显示的一整套流程叫作渲染，应用在运行时会不断地进行重新渲染。而响应式系统赋予框架重新渲染的能力，其重要组成部分是变化侦测。变化侦测是响应式系统的核心，没有它，就没有重新渲染。框架在运行时，视图也就无法随着状态的变化而变化。

简单来说，变化侦测的作用是侦测数据的变化。当数据变化时，会通知视图进行相应的更新。正如文档中所说，深入理解变化侦测的工作原理，既可以帮助我们在开发应用时回避一些很常见的问题，也可以在应用程序出问题时，快速调试并修复问题。

本篇中，我们将针对变化侦测的实现原理做一个详细介绍，并且会带着你一步一步从 0 到 1 实现一个变化侦测的逻辑。学完本篇，你将可以自己实现一个变化债测的功能。

# 第 2 章 Object 的变化侦测

2.1 什么是变化侦测
2.2 如何追踪变化
2.3 如何收集依赖
2.4 依赖收集在哪里
2.5 依赖是谁
2.6 什么是 Watcher
2.7 递归侦测所有 key
2.8 关于 Object 的问题
2.9 总结

# 第 3 章 Array 的变化侦测

3.1 如何追踪变化
3.2 拦截器
3.3 使用拦截器覆盖 Array 原型
3.4 将拦截器方法挂载到数组的属性上
3.5 如何收集依赖
3.6 依赖列表存在哪儿
3.7 收集依赖
3.8 在拦截器中获取 Observer 实例
3.9 向数组的依赖发送通知
3.10 侦测数组中元素的变化
3.11 侦测新增元素的变化
3.11.1 获取新增元素
3.11.2 使用 Observer 侦测新增元素
3.12 关于 Array 的问题
3.13 总结

# 第 4 章 变化侦测相关的 API 实现原理

4.1 vm.$watch
4.1.1 用法
4.1.2 watch的内部原理
4.1.3 deep参数的实现原理
4.2 vm.$set
4.2.1 用法
4.2.2 Array 的处理
4.2.3 key 已经存在于 target 中
4.2.4 处理新增的属性
4.3 vm.\$delete
4.3.1 用法
4.3.2 实现原理
4.4 总结

# 第二篇 虚拟 DOM

Vue.js2.0 引入了虚拟 DOM,比 Vue.js1.0 的初始渲染速度提升了 2-4 倍，并大大降低了内存消耗。

虚拟 DOM 也是 React 核心技术之一。它到底有着怎样的魔力，使前端界各大主流框架都纷份使用？

你是否好奇，虚拟 DOM 的原理是什么？

你是否好奇，为什么 Vue.js2.0 开始引入了虚拟 DOM?

你是否好奇，为什么 Vue.js 引入虚拟 DOM 后渲染速度就变快了？

又或者，你根本没听说过虚拟 DOM,那么什么是虚拟 DOM?

这一切的问题，都将在本篇揭晓。

# 第 5 章 虚拟 DOM 简介

5.1 什么是虚拟 DOM
5.2 为什么要引入虚拟 DOM
5.3 Vue.js 中的虚拟 DOM
5.4 总结

# 第 6 章 VNode

6.1 什么是 VNode
6.2 VNode 的作用
6.3 VNode 的类型
6.3.1 注释节点
6.3.2 文本节点
6.3.3 克隆节点
6.3.4 元素节点
6.3.5 组件节点
6.3.6 函数式组件
6.4 总结

# 第 7 章 patch

7.1 patch 介绍
7.1.1 新增节点
7.1.2 删除节点
7.1.3 更新节点
7.1.4 小结
7.2 创建节点
7.3 删除节点
7.4 更新节点
7.4.1 静态节点
7.4.2 新虚拟节点有文本属性
7.4.3 新虚拟节点无文本属性
7.4.4 小结
7.5 更新子节点
7.5.1 更新策略
7.5.2 优化策略
7.5.3 哪些节点是未处理过的
7.5.4 小结
7.6 总结

# 第三篇 模板编译原理

在 Vue.js 内部，模板编译是一项比较重要的技术。我们平时使用 Vue.js 进行开发时，会经常使用模板。模板赋予我们很多强大的能力，例如可以在模板中访问变量。

但在 Vue.js 中创建 HTML 并不是只有模板这一种途径，我们既可以手动写渲染函数来创建 HTML,也可以在 Vue.js 中使用 JSX 来创建 HTML。

渲染函数是创建 HTML 最原始的方法。模板最终会通过编译转换成渲染函数，渲染函数执行后，会得到一份 vnode 用于虚拟 DOM 渲染。所以模板编译其实是配合虚拟 DOM 进行渲染，这也是本书先介绍虚拟 DOM 后介绍模板编译的原因。

本篇中，我们将会详细介绍模板转换成渲染函数的详细过程。

# 第 8 章 模板编译

8.1 概念
8.2 将模板编译成渲染函数
8.2.1 解析器
8.2.2 优化器
8.2.3 代码生成器
8.3 总结

# 第 9 章 解析器

9.1 解析器的作用
9.2 解析器内部运行原理
9.3 HTML 解析器
9.3.1 运行原理
9.3.2 截取开始标签
9.3.3 截取结束标签
9.3.4 截取注释
9.3.5 截取条件注释
9.3.6 截取 DOCTYPE
9.3.7 截取文本
9.3.8 纯文本内容元素的处理
9.3.9 使用栈维护 DOM 层级
9.3.10 整体逻辑
9.4 文本解析器
9.5 总结

# 第 10 章 优化器

10.1 找出所有静态节点并标记
10.2 找出所有静态根节点并标记
10.3 总结

# 第 11 章 代码生成器

11.1 通过 AST 生成代码字符串
11.2 代码生成器的原理
11.2.1 元素节点
11.2.2 文本节点
11.2.3 注释节点
11.3 总结

# 第四篇 整体流程

前几篇介绍的是 Vue.js 在实现一些功能时所要用到的技术，其内容偏底层。

在本篇中，我们更多的是介绍距离用户比较近的内容，例如使用 Vue.js 开发项目时常用的 P1、模板中的各种指令、组件里经常使用的生命周期钩子以及使用事件进行父子组件间的通信。此外，我们还会定义一些 Vue.js 插件和过滤器。

本篇中，我们主要讲解常用功能的内部原理，同时还会介绍 Vuejs 的架构设计和代码结构，也会讨论如何组建 Vue.js 这样的开源项目的代码等内容。

在开发一些很复杂的功能时，在某些特定的场景下，本篇所介绍的内容一定会对我们有帮助。

如果熟悉所使用功能的内部实现，那么当业务功能出现 bug 时，我们就可以快速、精准地定位问题所在，知道问题是由 Vue.js 的某些特性导致的，还是代码逻辑有问题，并且在开发复杂功能时，我们可以清楚地知道 Vue.js 能提供的能力的边界在哪里，这样就可以最大限度地发挥它的价值。

# 第 12 章 架构设计与项目结构

12.1 目录结构
12.2 架构设计
12.3 总结

# 第 13 章 实例方法与全局 API 的实现原理

13.1 数据相关的实例方法
13.2 事件相关的实例方法
13.2.1 vm.$on
13.2.2 vm.$off
13.2.3 vm.$once
13.2.4 vm.$emit
13.3 生命周期相关的实例方法
13.3.1 vm.$forceUpdate
13.3.2 vm.$destroy
13.3.3 vm.$nextTick
13.3.4 vm.$mount
13.4 全局 API 的实现原理
13.4.1 Vue.extend
13.4.2 Vue.nextTick
13.4.3 Vue.set
13.4.4 Vue.delete
13.4.5 Vue.directive
13.4.6 Vue.filter
13.4.7 Vue.component
13.4.8 Vue.use
13.4.9 Vue.mixin
13.4.10 Vue.compile
13.4.11 Vue.version
13.5 总结

# 第 14 章 生命周期

14.1 生命周期图示
14.1.1 初始化阶段
14.1.2 模板编译阶段
14.1.3 挂载阶段
14.1.4 卸载阶段
14.1.5 小结
14.2 从源码角度了解生命周期
14.3 errorCaptured 与错误处理
14.4 初始化实例属性
14.5 初始化事件
14.6 初始化 inject
14.6.1 provide/inject 的使用方式
14.6.2 inject 的内部原理
14.7 初始化状态
14.7.1 初始化 props
14.7.2 初始化 methods
14.7.3 初始化 data
14.7.4 初始化 computed
14.7.5 初始化 watch
14.8 初始化 provide
14.9 总结

# 第 15 章 指令的奥秘

15.1 指令原理概述
15.1.1 v-if 指令的原理概述
15.1.2 v-for 指令的原理概述
15.1.3 v-on 指令
15.2 自定义指令的内部原理
15.3 虚拟 DOM 钩子函数
15.4 总结

# 第 16 章 过滤器的奥秘

16.1 过滤器原理概述
16.1.1 串联过滤器
16.1.2 滤器接收参数
16.1.3 resolveFilter 的内部原理
16.2 解析过滤器
16.3 总结

# 第 17 章 最佳实践

17.1 为列表渲染设置属性 key
17.2 在 v-if/v-if-else/v-else 中使用 key
17.3 路由切换组件不变
17.3.1 路由导航守卫 beforeRouteUpdate
17.3.2 观察 \$route 对象的变化
17.3.3 为 router-view 组件添加属性 key
17.4 为所有路由统一添加 query
17.4.1 使用全局守卫 beforeEach
17.4.2 使用函数劫持
17.5 区分 Vuex 与 props 的使用边界
17.6 避免 v-if 和 v-for 一起使用
17.7 为组件样式设置作用域
17.8 避免在 scoped 中使用元素选择器
17.9 避免隐性的父子组件通信
17.10 单文件组件如何命名
17.10.1 单文件组件的文件名的大小写
17.10.2 基础组件名
17.10.3 单例组件名
17.10.4 紧密耦合的组件名
17.10.5 组件名中的单词顺序
17.10.6 完整单词的组件名
17.10.7 组件名为多个单词
17.10.8 模板中的组件名大小写
17.10.9 JS/JSX 中的组件名大小写
17.11 自闭合组件
17.12 prop 名的大小写
17.13 多个特性的元素
17.14 模板中简单的表达式
17.15 简单的计算属性
17.16 指令缩写
17.17 良好的代码顺序
17.17.1 组件/实例的选项的顺序
17.17.2 元素特性的顺序
17.17.3 单文件组件顶级元素的顺序
17.18 总结
