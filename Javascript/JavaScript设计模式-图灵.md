> JavaScript设计模式
> Addy Osmani 著
> 徐涛 译
> 2013年 06 月 第一版
> [开源图书原文地址](https://addyosmani.com/resources/essentialjsdesignpatterns/book/index.html)
> [开源图书译文地址](https://www.oschina.net/translate/learning-javascript-design-patterns)

# 第1章 介绍

编写易于维护的代码，其中一个最重要方面是能够找到代码中重复出现的主题并优化它们。这也是设计模式有价值的地方。

# 第2章 什么是模式

模式是一种可复用的解决方案，可用于解决软件设计中遇到的常见问题，如在我们编写的 JavaScript 应用程序的实例中。另一种模式的方式是将解决问题的方法制作成模板，并且这些模板可应用于多种不同的情况。

设计模式有三大好处。

- 模式是已经验证的解决之道
- 模式很容易被复用
- 模式富有表达力

模式的一些其他优点。

- 复用模式有助于防止开发过程中，小问题引发的大问题。可以在结构上少花时间，从而有更多时间专注于整体解决方案的质量。
- 模式可以提供通用的解决方案，并且其记录方式不需要与某个特定问题挂钩。
- 某些模式确实能够通过避免代码复用来减少代码的总体资源占用量。
- 模式添加到开发人员的词汇中，会使沟通更快速。
- 经常使用的模式可以逐步改进，因为其他开发人员使用这些模式后总结出的共同经验又贡献给了设计模式社区。

## 我们每天都在使用模式

为页面上每个具有“foo”类的class属性的DOM元素增加一个计数器，查询列表最有效的方法？

1. 在页面上选择所有元素并存储，接着过滤该集合并使用正则表达式（或另一种方式）来存储那些具有“foo”类的元素
2. 使用浏览器原生的`querySelectorAll()`等功能来选择所有具有“foo”类的元素
3. 使用原生特性`getElementsByClassName()`等功能来重新获得所需的集合。

最快的实际是第三种，他比其他方法快8至10倍。但在实际应用中，IE9一下的版本不支持第三种方法，因此必须使用第一种方法，其他方法行不通。

使用jQuery的开发人员不必担心这个问题，因为通过使用Facade(外观)模式，它已经被抽象出来了，该模式为若干更复杂的底层代码体提供了一套简单的抽象接口(例如`$el.css()`和`$el. animate()`)正如我们看到的，这意味着在实现级细节上花费更少的时间。根据现有浏览器的支持范围，jQuery会在幕后选择最佳的元素选择方式，我们只需要使用抽象层即可。

# 第3章 模式状态测试、Proto模式及三法则

在学习设计模式时,我们不时会碰到“原始模式(proto-pattern)”这个词:一种尚未通“模式”测试的设计模式。原始模式是值得与社区分享的特殊解决方案，来自社区编程人员的心血，但因为产生的时间短，还没有机会对它们进行严格的审查。

如果模式可以执行以下操作，就被认为是“优秀”的模式

- 解决特殊问题
- 没有显而易见的解决方案
- 描述业经验证的概念
- 描述一种关系

成为有效模式的其中一个附加要求是,它们展示一些反复出现的现象。这通常可以限定在至少三个关键领域中,被称为三法则。使用该规则重现,则必须证明如下:

- 适合性
- 实用性
- 适用性

# 第4章 设计模式的结构

模式是最初提出的一种在两者之间建立关系的规则：

- 上下文
- 上下文里产生的元件系统
- 解决元件在上下文中自身问题的配置

一种设计模式应该具有：

- 模式名称和相应的描述
- 上下文大纲。模式在上下文中有效，以满足用户的需求
- 问题概述。问题的陈述已解决，因此可以理解模式的意图
- 解决方案。以可理解的步骤和看法解决用户问题的描述
- 设计。模式设计的描述，特别是与它交互的用户行为
- 实现。有关如何实现模式的指导
- 插图。模式中类的可视表示（如图表）
- 示例。最小形式的模式实现
- 辅助条件。需要那些其他模式来支持所描述模式的使用？
- 关系。这种模式像哪些模式？它是否极力模仿其他模式呢？
- 已知的用法。是广泛使用的模式？如果是这样，在哪里使用？如何使用？
- 讨论。团队或者作者对该模式所带来巨大好处的想法。

在一个组织或团队中，当在同一页面上创建和维护的解决方案时，对所有涉及到的开发者来说，设计模式能帮上大忙。如果考虑到你自己的工作模式，记住，虽然他们可能在制定计划和编写阶段，有一个较大的初期成本投入，但从投资方返回的值是值得的。然而，新的模式工作前，务必深入研究，你会发现它比起重新开始，更有利于使用或建立比现有的行之有效的模式之上。

# 第5章 编写设计模式
# 第6章 反模式
# 第7章 设计模式类别
# 第8章 设计模式分类
有关类（Class）的要点
第9章 JavaScript设计模式
9.1 Constructor（构造器）模式
9.2 Module（模块）模式
9.3 Revealing Module（揭示模块）模式
9.4 Singleton（单例）模式
9.5 Observer（观察者）模式
9.6 Mediator（中介者）模式
9.7 Prototype（原型）模式
9.8 Command（命令）模式
9.9 Facade（外观）模式
9.10 Factory（工厂）模式
9.11 Mixin模式
9.12 Decorator（装饰者）模式
9.13 Flyweight（享元）模式
第10章 JavaScript MV*模式
10.1 MVC
10.2 为JavaScript开发人员提供的MVC
10.3 MVC为我们提供了什么
10.4 JavaScript中的Smalltalk-80 MVC
10.5 MVP
10.6 MVVM
10.7 利与弊
10.8 使用更松散数据绑定的MVVM
10.9 MVC、MVP与MVVM
10.10 Backbone.js与KnockoutJS
第11章 模块化的JavaScript设计模式
11.1 脚本加载器要点
11.2 AMD
11.3 CommonJS
11.4 AMD和CommonJS：互相竞争，标准同效
11.5 ES Harmony
11.6 总结
第12章 jQuery中的设计模式
12.1 Composite（组合）模式
12.2 Adapter（适配器）模式
12.3 Facade（外观）模式
12.4 Observer（观察者）模式
12.5 Iterator（迭代器）模式
12.6 延迟初始化
12.7 Proxy（代理）模式
12.8 Builder（生成器）模式
第13章 jQuery插件设计模式
13.1 模式
13.2 Lightweight Start模式
13.3 完整的Widget Factory模式
13.4 嵌套命名空间插件模式
13.5 自定义事件插件模式（使用Widget Factory）
13.6 使用DOM-to-Object Bridge模式的原型继承
13.7 jQuery UI Widget Factory Bridge模式
13.8 使用Widget Factory的 jQuery Mobile Widget
13.9 RequireJS和 jQuery UI Widget Factory
13.10 全局选项和单次调用可重写选项（最佳选项模式）
13.11 高可配和高可变的插件模式
13.12 是什么使插件超越模式
13.13 总结
13.14 命名空间模式
13.15 命名空间基础
13.16 高级命名空间模式
第14章 总结