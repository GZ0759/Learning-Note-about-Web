> JavaScript设计模式
> Addy Osmani 著
> 徐涛 译
> 2013年 06 月 第一版
> [开源图书原文地址](https://addyosmani.com/resources/essentialjsdesignpatterns/book/index.html)
> [译文地址](https://www.oschina.net/translate/learning-javascript-design-patterns)
> [W3Cschool](https://www.w3cschool.cn/zobyhd/)

# 第1章 介绍

编写易于维护的代码，其中一个最重要方面是能够找到代码中重复出现的主题并优化它们。这也是设计模式有价值的地方。

# 第2章 什么是模式

模式是一种可复用的解决方案，可用于解决软件设计中遇到的常见问题，如在我们编写的 JavaScript 应用程序的实例中。另一种模式的方式是将解决问题的方法制作成模板，并且这些模板可应用于多种不同的情况。

设计模式有三大好处。

- 模式是已经验证的解决之道
- 模式很容易被复用
- 模式富有表达力

模式的一些其他优点。

- 复用模式有助于防止开发过程中，小问题引发的大问题。可以在结构上少花时间，从而有更多时间专注于整体解决方案的质量。
- 模式可以提供通用的解决方案，并且其记录方式不需要与某个特定问题挂钩。
- 某些模式确实能够通过避免代码复用来减少代码的总体资源占用量。
- 模式添加到开发人员的词汇中，会使沟通更快速。
- 经常使用的模式可以逐步改进，因为其他开发人员使用这些模式后总结出的共同经验又贡献给了设计模式社区。

## 我们每天都在使用模式

为页面上每个具有“foo”类的class属性的DOM元素增加一个计数器，查询列表最有效的方法？

1. 在页面上选择所有元素并存储，接着过滤该集合并使用正则表达式（或另一种方式）来存储那些具有“foo”类的元素
2. 使用浏览器原生的`querySelectorAll()`等功能来选择所有具有“foo”类的元素
3. 使用原生特性`getElementsByClassName()`等功能来重新获得所需的集合。

最快的实际是第三种，他比其他方法快8至10倍。但在实际应用中，IE9一下的版本不支持第三种方法，因此必须使用第一种方法，其他方法行不通。

使用jQuery的开发人员不必担心这个问题，因为通过使用Facade(外观)模式，它已经被抽象出来了，该模式为若干更复杂的底层代码体提供了一套简单的抽象接口(例如`$el.css()`和`$el. animate()`)正如我们看到的，这意味着在实现级细节上花费更少的时间。根据现有浏览器的支持范围，jQuery会在幕后选择最佳的元素选择方式，我们只需要使用抽象层即可。

# 第3章 模式状态测试、Proto模式及三法则

在学习设计模式时,我们不时会碰到“原始模式(proto-pattern)”这个词:一种尚未通“模式”测试的设计模式。原始模式是值得与社区分享的特殊解决方案，来自社区编程人员的心血，但因为产生的时间短，还没有机会对它们进行严格的审查。

如果模式可以执行以下操作，就被认为是“优秀”的模式

- 解决特殊问题
- 没有显而易见的解决方案
- 描述业经验证的概念
- 描述一种关系

成为有效模式的其中一个附加要求是,它们展示一些反复出现的现象。这通常可以限定在至少三个关键领域中,被称为三法则。使用该规则重现,则必须证明如下:

- 适合性
- 实用性
- 适用性

# 第4章 设计模式的结构

模式是最初提出的一种在两者之间建立关系的规则：

- 上下文
- 上下文里产生的元件系统
- 解决元件在上下文中自身问题的配置

一种设计模式应该具有：

- 模式名称和相应的描述
- 上下文大纲。模式在上下文中有效，以满足用户的需求
- 问题概述。问题的陈述已解决，因此可以理解模式的意图
- 解决方案。以可理解的步骤和看法解决用户问题的描述
- 设计。模式设计的描述，特别是与它交互的用户行为
- 实现。有关如何实现模式的指导
- 插图。模式中类的可视表示（如图表）
- 示例。最小形式的模式实现
- 辅助条件。需要那些其他模式来支持所描述模式的使用？
- 关系。这种模式像哪些模式？它是否极力模仿其他模式呢？
- 已知的用法。是广泛使用的模式？如果是这样，在哪里使用？如何使用？
- 讨论。团队或者作者对该模式所带来巨大好处的想法。

在一个组织或团队中，当在同一页面上创建和维护的解决方案时，对所有涉及到的开发者来说，设计模式能帮上大忙。如果考虑到你自己的工作模式，记住，虽然他们可能在制定计划和编写阶段，有一个较大的初期成本投入，但从投资方返回的值是值得的。然而，新的模式工作前，务必深入研究，你会发现它比起重新开始，更有利于使用或建立比现有的行之有效的模式之上。

# 第5章 编写设计模式

如果有兴趣创建新的设计模式，以下是一些建议：

- 模式的实用性：确保该模式描述了针对反复出现的问题的经过验证的解决方案，而不仅仅是描述了尚未经过验证的推测性解决方案。
- 牢记最佳实践：我们所做的设计决策应基于我们从对最佳实践的理解中得出的原则。
- 我们的设计模式对用户应该透明：设计模式对任何类型的用户体验都应该完全透明。它们主要是用来为使用它们的开发人员提供服务的，不应强迫用户体验中的行为发生变化，而这些行为如果不使用模式就不会发生。
- 独创性不是图案设计的关键：编写图案时，我们不必是记录在案的解决方案的原始发现者，也不必担心我们的设计会与其他图案的次要部分重叠。如果该方法足够强大以具有广泛的有用适用性，则有可能被认为是有效模式。
- 模式需要一组强大的示例：良好的模式描述之后必须要有一组同样强大的示例，以证明我们的模式已成功应用。为了显示广泛的用途，具有良好设计原则的示例是理想的。

模式编写是在创建通用，特定和最重要的有用设计之间进行仔细的权衡。尝试确保如果编写模式，则可以覆盖应用程序的最大范围，并且应该没问题。

# 第6章 反模式

提出了两种反模式概念。

- 描述特定问题的不良解决方案，导致出现不良情况
- 描述如何摆脱这种局面以及如何从那里得到一个好的解决方案

关于这个主题，Alexander撰写了在良好的设计结构和良好的上下文之间取得良好平衡的困难：

“这些说明是关于设计过程的；为了响应功能而发明的物理事物显示新的物理顺序，组织，形式的过程。每个设计问题都始于努力实现两个实体之间的适应性：所讨论的形式及其上下文。表格是解决问题的方法。上下文定义了问题”。

反模式是一个值得记录的不良设计。JavaScript中的反模式示例如下：

- 通过在全局上下文中定义大量变量来污染全局名称空间
- 将字符串而不是函数传递给`setTimeout`或`setInterval`，因为这会触发`eval()`内部使用。
- 修改Object类原型（这是一个非常糟糕的反模式）
- 以内联形式使用JavaScript，因为这不灵活
- 在更适合使用本机DOM替代文档（例如document.createElement）的地方使用document.write。

# 第7章 设计模式类别

著名设计书《域驱动术语》中的词汇表正确地指出：

“设计模式可以命名，抽象和标识通用设计结构的关键方面，从而使它对于创建可重用的面向对象设计很有用。设计模式标识参与的类及其实例，它们的角色和协作以及职责分配。

每个设计模式都针对特定的面向对象设计问题。它描述了何时应用，是否可以根据其他设计约束来应用，使用的后果和取舍。由于我们最终必须实现设计，因此设计模式还提供了示例代码来说明实现。

尽管设计模式描述了面向对象的设计，但它们基于已在主流面向对象编程语言中实现的实用解决方案……。”

设计模式可以分为许多不同的类别。

1. 创作设计模式

创建性设计模式着重于处理对象创建机制，其中以适合我们所处情况的方式创建对象。否则，对象创建的基本方法可能会导致项目增加复杂性，而这些模式旨在通过以下方式解决此问题：控制创建过程。属于此类别的一些模式是：构造函数，工厂，抽象，原型，单例和构建器。

2. 结构设计模式

结构模式与对象组成有关，通常会识别实现不同对象之间关系的简单方法。它们有助于确保当系统的一部分发生更改时，系统的整个结构都不需要这样做。它们还有助于将系统中不适合特定用途的部分重铸到适合的部分。属于此类别的模式包括：装饰器，外观，Flyweight，适配器和代理。

3. 行为设计模式

行为模式集中于改善或简化系统中不同对象之间的通信。一些行为模式包括：迭代器，中介器，观察者和访客。

# 第8章 设计模式分类

## 有关类（Class）的要点

此表中将有一些引用“类”概念的模式。在ES5中，JavaScript是一种无类语言，但是可以使用函数来模拟类。

实现此目的最常见的方法是定义一个JavaScript函数，然后在其中使用new关键字创建一个对象。this可用于帮助定义对象的新属性和方法，如下所示：

```js
// A car "class"
function Car( model ) {
 
  this.model = model;
  this.color = "silver";
  this.year = "2012";
 
  this.getInfo = function () {
    return this.model + " " + this.year;
  };
 
}
```

然后，我们可以使用上面定义的Car构造函数实例化对象。

```js
var myCar = new Car("ford");
 
myCar.year = "2010";
 
console.log( myCar.getInfo() );
```

Creational	根据创建对象的概念分成下面几类。
- Class
  - Factory Method(工厂方法)	通过将数据和事件接口化来构建若干个子类。
- Object
  - Abstract Factory(抽象工厂)	建立若干族类的一个实例，这个实例不需要具体类的细节信息。（抽象类）
  - Builder (建造者)	将对象的构建方法和其表现形式分离开来，总是构建相同类型的对象。
  - Prototype(原型)	一个完全初始化的实例，用于拷贝或者克隆。
  - Singleton(单例)	一个类只有唯一的一个实例，这个实例在整个程序中有一个全局的访问点。

Structural	根据构建对象块的方法分成下面几类。
- Class
  - Adapter(适配器)	将不同类的接口进行匹配，调整，这样尽管内部接口不兼容但是不同的类还是可以协同工作的。
- Object
  - Adapter(适配器)	将不同类的接口进行匹配，调整，这样尽管内部接口不兼容但是不同的类还是可以协同工作的。
  - Bridge(桥接模式)	将对象的接口从其实现中分离出来，这样对象的实现和接口可以独立的变化。
  - Composite(组合模式)	通过将简单可组合的对象组合起来，构成一个完整的对象，这个对象的能力将会超过这些组成部分的能力的总和，即会有新的能力产生。
  - Decorator(装饰器)	动态给对象增加一些可替换的处理流程。
  - Facada(外观模式)	一个类隐藏了内部子系统的复杂度，只暴露出一些简单的接口。
  - Flyweight(享元模式)	一个细粒度对象，用于将包含在其它地方的信息 在不同对象之间高效地共享。
  - Proxy(代理模式)	一个充当占位符的对象用来代表一个真实的对象。

Behavioral	基于对象间作用方式来分类。
- Class
  - Interpreter(解释器)	将语言元素包含在一个应用中的一种方式，用于匹配目标语言的语法。
  - Template Method(模板方法)	在一个方法中为某个算法建立一层外壳，将算法的具体步骤交付给子类去做。
- Object
  - Chain of Responsibility(响应链)	一种将请求在一串对象中传递的方式，寻找可以处理这个请求的对象。
  - Command(命令)	封装命令请求为一个对象，从而使记录日志，队列缓存请求，未处理请求进行错误处理 这些功能称为可能。
  - Iterator(迭代器)	在不需要直到集合内部工作原理的情况下，顺序访问一个集合里面的元素。
  - Mediator(中介者模式)	在类之间定义简化的通信方式，用于避免类之间显式的持有彼此的引用。
  - Observer(观察者模式)	用于将变化通知给多个类的方式，可以保证类之间的一致性。
  - State(状态)	当对象状态改变时，改变对象的行为。
  - Strategy(策略)	将算法封装到类中，将选择和实现分离开来。
  - Visitor(访问者)	为类增加新的操作而不改变类本身。


# 第9章 JavaScript设计模式
9.1 Constructor（构造器）模式
9.2 Module（模块）模式
9.3 Revealing Module（揭示模块）模式
9.4 Singleton（单例）模式
9.5 Observer（观察者）模式
9.6 Mediator（中介者）模式
9.7 Prototype（原型）模式
9.8 Command（命令）模式
9.9 Facade（外观）模式
9.10 Factory（工厂）模式
9.11 Mixin模式
9.12 Decorator（装饰者）模式
9.13 Flyweight（享元）模式

# 第10章 JavaScript MV*模式
10.1 MVC
10.2 为JavaScript开发人员提供的MVC
10.3 MVC为我们提供了什么
10.4 JavaScript中的Smalltalk-80 MVC
10.5 MVP
10.6 MVVM
10.7 利与弊
10.8 使用更松散数据绑定的MVVM
10.9 MVC、MVP与MVVM
10.10 Backbone.js与KnockoutJS
第11章 模块化的JavaScript设计模式
11.1 脚本加载器要点
11.2 AMD
11.3 CommonJS
11.4 AMD和CommonJS：互相竞争，标准同效
11.5 ES Harmony
11.6 总结
第12章 jQuery中的设计模式
12.1 Composite（组合）模式
12.2 Adapter（适配器）模式
12.3 Facade（外观）模式
12.4 Observer（观察者）模式
12.5 Iterator（迭代器）模式
12.6 延迟初始化
12.7 Proxy（代理）模式
12.8 Builder（生成器）模式
第13章 jQuery插件设计模式
13.1 模式
13.2 Lightweight Start模式
13.3 完整的Widget Factory模式
13.4 嵌套命名空间插件模式
13.5 自定义事件插件模式（使用Widget Factory）
13.6 使用DOM-to-Object Bridge模式的原型继承
13.7 jQuery UI Widget Factory Bridge模式
13.8 使用Widget Factory的 jQuery Mobile Widget
13.9 RequireJS和 jQuery UI Widget Factory
13.10 全局选项和单次调用可重写选项（最佳选项模式）
13.11 高可配和高可变的插件模式
13.12 是什么使插件超越模式
13.13 总结
13.14 命名空间模式
13.15 命名空间基础
13.16 高级命名空间模式
第14章 总结