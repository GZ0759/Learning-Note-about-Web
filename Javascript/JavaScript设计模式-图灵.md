> JavaScript设计模式
> Addy Osmani 著
> 徐涛 译
> 2013年 06 月 第一版
> [开源图书原文地址](https://addyosmani.com/resources/essentialjsdesignpatterns/book/index.html)
> [译文地址](https://www.oschina.net/translate/learning-javascript-design-patterns)
> [W3Cschool](https://www.w3cschool.cn/zobyhd/)

# 第1章 介绍

编写易于维护的代码，其中一个最重要方面是能够找到代码中重复出现的主题并优化它们。这也是设计模式有价值的地方。

# 第2章 什么是模式

模式是一种可复用的解决方案，可用于解决软件设计中遇到的常见问题，如在我们编写的 JavaScript 应用程序的实例中。另一种模式的方式是将解决问题的方法制作成模板，并且这些模板可应用于多种不同的情况。

设计模式有三大好处。

- 模式是已经验证的解决之道
- 模式很容易被复用
- 模式富有表达力

模式的一些其他优点。

- 复用模式有助于防止开发过程中，小问题引发的大问题。可以在结构上少花时间，从而有更多时间专注于整体解决方案的质量。
- 模式可以提供通用的解决方案，并且其记录方式不需要与某个特定问题挂钩。
- 某些模式确实能够通过避免代码复用来减少代码的总体资源占用量。
- 模式添加到开发人员的词汇中，会使沟通更快速。
- 经常使用的模式可以逐步改进，因为其他开发人员使用这些模式后总结出的共同经验又贡献给了设计模式社区。

## 我们每天都在使用模式

为页面上每个具有“foo”类的class属性的DOM元素增加一个计数器，查询列表最有效的方法？

1. 在页面上选择所有元素并存储，接着过滤该集合并使用正则表达式（或另一种方式）来存储那些具有“foo”类的元素
2. 使用浏览器原生的`querySelectorAll()`等功能来选择所有具有“foo”类的元素
3. 使用原生特性`getElementsByClassName()`等功能来重新获得所需的集合。

最快的实际是第三种，他比其他方法快8至10倍。但在实际应用中，IE9一下的版本不支持第三种方法，因此必须使用第一种方法，其他方法行不通。

使用jQuery的开发人员不必担心这个问题，因为通过使用Facade(外观)模式，它已经被抽象出来了，该模式为若干更复杂的底层代码体提供了一套简单的抽象接口(例如`$el.css()`和`$el. animate()`)正如我们看到的，这意味着在实现级细节上花费更少的时间。根据现有浏览器的支持范围，jQuery会在幕后选择最佳的元素选择方式，我们只需要使用抽象层即可。

# 第3章 模式状态测试、Proto模式及三法则

在学习设计模式时,我们不时会碰到“原始模式(proto-pattern)”这个词:一种尚未通“模式”测试的设计模式。原始模式是值得与社区分享的特殊解决方案，来自社区编程人员的心血，但因为产生的时间短，还没有机会对它们进行严格的审查。

如果模式可以执行以下操作，就被认为是“优秀”的模式

- 解决特殊问题
- 没有显而易见的解决方案
- 描述业经验证的概念
- 描述一种关系

成为有效模式的其中一个附加要求是,它们展示一些反复出现的现象。这通常可以限定在至少三个关键领域中,被称为三法则。使用该规则重现,则必须证明如下:

- 适合性
- 实用性
- 适用性

# 第4章 设计模式的结构

模式是最初提出的一种在两者之间建立关系的规则：

- 上下文
- 上下文里产生的元件系统
- 解决元件在上下文中自身问题的配置

一种设计模式应该具有：

- 模式名称和相应的描述
- 上下文大纲。模式在上下文中有效，以满足用户的需求
- 问题概述。问题的陈述已解决，因此可以理解模式的意图
- 解决方案。以可理解的步骤和看法解决用户问题的描述
- 设计。模式设计的描述，特别是与它交互的用户行为
- 实现。有关如何实现模式的指导
- 插图。模式中类的可视表示（如图表）
- 示例。最小形式的模式实现
- 辅助条件。需要那些其他模式来支持所描述模式的使用？
- 关系。这种模式像哪些模式？它是否极力模仿其他模式呢？
- 已知的用法。是广泛使用的模式？如果是这样，在哪里使用？如何使用？
- 讨论。团队或者作者对该模式所带来巨大好处的想法。

在一个组织或团队中，当在同一页面上创建和维护的解决方案时，对所有涉及到的开发者来说，设计模式能帮上大忙。如果考虑到你自己的工作模式，记住，虽然他们可能在制定计划和编写阶段，有一个较大的初期成本投入，但从投资方返回的值是值得的。然而，新的模式工作前，务必深入研究，你会发现它比起重新开始，更有利于使用或建立比现有的行之有效的模式之上。

# 第5章 编写设计模式

如果有兴趣创建新的设计模式，以下是一些建议：

- 模式的实用性：确保该模式描述了针对反复出现的问题的经过验证的解决方案，而不仅仅是描述了尚未经过验证的推测性解决方案。
- 牢记最佳实践：我们所做的设计决策应基于我们从对最佳实践的理解中得出的原则。
- 设计模式对用户应该透明：设计模式对任何类型的用户体验都应该完全透明。它们主要是用来为使用它们的开发人员提供服务的，不应强迫用户体验中的行为发生变化，而这些行为如果不使用模式就不会发生。
- 独创性在模式设计中不是重点：编写模式时，我们不必是记录在案的解决方案的原始发现者，也不必担心我们的设计会与其他模式的次要部分重叠。如果该方法足够强大以具有广泛的有用适用性，则有可能被认为是有效模式。
- 模式需要一批有说服力的示例：良好的模式描述之后必须要有一组同样强大的示例，以证明我们的模式已成功应用。为了显示广泛的用途，具有良好设计原则的示例是理想的。

模式编写是在创建通用、具体及有用的设计方面找到一种细致的平衡，要努力确保所编写的模式能够覆盖最广发的应用领域。

# 第6章 反模式

提出了两种反模式概念。

- 描述特定问题的不良解决方案，该方案会导致糟糕的情况发生
- 描述如何摆脱前述的糟糕情况以及如何创造好的解决方案

关于这个主题，Alexander撰写了在良好的设计结构和良好的上下文之间取得良好平衡的困难：

“这些说明是关于设计过程的；为了响应功能而发明的物理事物显示新的物理顺序，组织，形式的过程。每个设计问题都始于努力实现两个实体之间的适应性：所讨论的形式及其上下文。表格是解决问题的方法。上下文定义了问题”。

反模式是一个值得记录的不良设计。JavaScript中的反模式示例如下：

- 通过在全局上下文中定义大量变量来污染全局名称空间
- 将字符串而不是函数传递给`setTimeout`或`setInterval`，因为这会触发`eval()`内部使用。
- 修改Object类原型（这是一个非常糟糕的反模式）
- 以内联形式使用JavaScript，因为这不灵活
- 在更适合使用原生DOM方法（例如`document.createElement`）的地方使用`document.write`。

# 第7章 设计模式类别

著名设计书《域驱动术语》中的词汇表正确地指出：

“设计模式可以命名，抽象和标识通用设计结构的关键方面，从而使它对于创建可重用的面向对象设计很有用。设计模式标识参与的类及其实例，它们的角色和协作以及职责分配。

每个设计模式都针对特定的面向对象设计问题。它描述了何时应用，是否可以根据其他设计约束来应用，使用的后果和取舍。由于我们最终必须实现设计，因此设计模式还提供了示例代码来说明实现。

尽管设计模式描述了面向对象的设计，但它们基于已在主流面向对象编程语言中实现的实用解决方案……。”

设计模式可以分为许多不同的类别。

1. 创建型设计模式

创建性设计模式着重于处理对象创建机制，其中以适合我们所处情况的方式创建对象。否则，对象创建的基本方法可能会导致项目增加复杂性，而这些模式旨在通过以下方式解决此问题：控制创建过程。属于此类别的一些模式是：构造函数，工厂，抽象，原型，单例和构建器。

2. 结构型设计模式

结构模式与对象组成有关，通常会识别实现不同对象之间关系的简单方法。它们有助于确保当系统的一部分发生更改时，系统的整个结构都不需要这样做。它们还有助于将系统中不适合特定用途的部分重铸到适合的部分。属于此类别的模式包括：装饰器，外观，Flyweight，适配器和代理。

3. 行为设计模式

行为模式集中于改善或简化系统中不同对象之间的通信。一些行为模式包括：迭代器，中介器，观察者和访客。

# 第8章 设计模式分类

## 有关类（Class）的要点

此表中将有一些引用“类”概念的模式。在ES5中，JavaScript是一种无类语言，但是可以使用函数来模拟类。

实现此目的最常见的方法是定义一个JavaScript函数，然后在其中使用new关键字创建一个对象。this可用于帮助定义对象的新属性和方法，如下所示：

```js
// A car "class"
function Car( model ) {
 
  this.model = model;
  this.color = "silver";
  this.year = "2012";
 
  this.getInfo = function () {
    return this.model + " " + this.year;
  };
 
}
```

然后，我们可以使用上面定义的Car构造函数实例化对象。

```js
var myCar = new Car("ford");
 
myCar.year = "2010";
 
console.log( myCar.getInfo() );
```

## 创建型模式Creational

基于创建对象的概念。

- Class
  - Factory Method(工厂方法)。基于接口数据或事件生成几个派生类的一个实例。
- Object
  - Abstract Factory(抽象工厂)。创建若干类系列的一个实例，无需详述具体的类。
  - Builder (生成器)。从表示中分离对象构建，而总是创建相同类型的对象。
  - Prototype(原型)。用于赋值或克隆完全初始化的实例。
  - Singleton(单例)。一个类在全局访问点只有唯一一个实例。

## 结构型模式Structural	

根据构建对象块的方法。

- Class
  - Adapter(适配器)。匹配不同类的接口，因此类可以在不兼容接口的情况下共同工作。
- Object
  - Adapter(适配器)。匹配不同类的接口，因此类可以在不兼容接口的情况下共同工作。
  - Bridge(桥接)。将对象接口从其实现中，因此它们可以独立进行变化。
  - Composite(组合)。简单和复合对象的结构，使对象的总和不只是它各部分的总和。
  - Decorator(装饰器)。向对象动态的添加备选的处理。
  - Facada(外观)。隐藏整个子系统复杂性的唯一一个类。
  - Flyweight(享元)。 一个用于实现包含在别处信息的高效共享的细粒度实例。
  - Proxy(代理)。占位符对象代表真正的对象。

## 行为模式Behavioral	

基于对象在一起配合工作的方式。

- Class
  - Interpreter(解释器)。将语言元素包含在应用程序中的方法，以匹配预期语言的语法。
  - Template Method(模板方法)。在一个方法中为某个算法建立一层外壳，将算法的具体步骤交付给子类去做。
- Object
  - Chain of Responsibility(响应链)。在对象链之间传递请求的方法，以找到能够处理请求的对象。
  - Command(命令)。将命令执行从其调用程序中分离的方法。
  - Iterator(迭代器)。顺序访问一个集合中的元素，无需了解该集合的内部工作原理。
  - Mediator(中介者模式)。在类之间定义简化的通信，以防止一组类显示引用彼此。
  - Memento(备忘录)。捕获对象的内部状态，以能够在以后恢复它。
  - Observer(观察者模式)。向多个类通知改变的方式，以确保类之间的一致性。
  - State(状态)。状态改变时，更改对象行为。
  - Strategy(策略)。在一个类中封装算法，将选择与实现分离。
  - Visitor(访问者)。向类添加一个新的操作，无需改变类。

# 第9章 JavaScript设计模式
9.1 Constructor（构造器）模式
9.2 Module（模块）模式
9.3 Revealing Module（揭示模块）模式
9.4 Singleton（单例）模式
9.5 Observer（观察者）模式
9.6 Mediator（中介者）模式
9.7 Prototype（原型）模式
9.8 Command（命令）模式
9.9 Facade（外观）模式
9.10 Factory（工厂）模式
9.11 Mixin模式
9.12 Decorator（装饰者）模式
9.13 Flyweight（享元）模式

# 第10章 JavaScript MV*模式
10.1 MVC
10.2 为JavaScript开发人员提供的MVC
10.3 MVC为我们提供了什么
10.4 JavaScript中的Smalltalk-80 MVC
10.5 MVP
10.6 MVVM
10.7 利与弊
10.8 使用更松散数据绑定的MVVM
10.9 MVC、MVP与MVVM
10.10 Backbone.js与KnockoutJS
第11章 模块化的JavaScript设计模式
11.1 脚本加载器要点
11.2 AMD
11.3 CommonJS
11.4 AMD和CommonJS：互相竞争，标准同效
11.5 ES Harmony
11.6 总结
第12章 jQuery中的设计模式
12.1 Composite（组合）模式
12.2 Adapter（适配器）模式
12.3 Facade（外观）模式
12.4 Observer（观察者）模式
12.5 Iterator（迭代器）模式
12.6 延迟初始化
12.7 Proxy（代理）模式
12.8 Builder（生成器）模式
第13章 jQuery插件设计模式
13.1 模式
13.2 Lightweight Start模式
13.3 完整的Widget Factory模式
13.4 嵌套命名空间插件模式
13.5 自定义事件插件模式（使用Widget Factory）
13.6 使用DOM-to-Object Bridge模式的原型继承
13.7 jQuery UI Widget Factory Bridge模式
13.8 使用Widget Factory的 jQuery Mobile Widget
13.9 RequireJS和 jQuery UI Widget Factory
13.10 全局选项和单次调用可重写选项（最佳选项模式）
13.11 高可配和高可变的插件模式
13.12 是什么使插件超越模式
13.13 总结
13.14 命名空间模式
13.15 命名空间基础
13.16 高级命名空间模式
第14章 总结